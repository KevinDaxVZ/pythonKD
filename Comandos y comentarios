  ---------------------------------------------------------------------------------------------------------------------------------
|								DIA 1								|
---------------------------------------------------------------------------------------------------------------------------------
PARA MOSTRAR EN PANTALLA:
------------------------------------------
print(variable)					imprime la variable indicada en pantalla. La variable puede ser string, numeros, booleanos, etc. (los espacios son carácteres).
\carácter					le indicamos a Python que al siguiente carácter lo tome como textual. (ojo con los carácteres especiales que van con \).	
\n						dentro de los string significa nueva linea.
\t						agregar un espacio de 4 carácteres antes del carácter siguiente. Es tabular o poner una sangría mejor dicho.
\\						para poder usar \ como un carácter.


PARA INGRESAR INFORMACIÓN:
------------------------------------------
input("mensaje")				para mostrar un mensaje luego espera a que el usuario ingrese información.





---------------------------------------------------------------------------------------------------------------------------------
|								DIA 2								|
---------------------------------------------------------------------------------------------------------------------------------

TIPOS DE DATOS:
-------------------------------------------
nombre		abreviación	ejemplo				concepto
----------	------------	---------			--------------------		
string		(str)		'hola','-"·$',"123"		cadena de carácteres.
integer		(int)		1,52,34,22,-5			numeros enteros.
floating	(float)		1.23,3.5			numeros con decimales.
listas		(list)		["sal",23,True]			una lista de datos con indices, la lista es dinamica.
diccionarios	(dic)		{'hola':23,'arte':'coca'}	lista de datos sin indice, con cada clave con su valor.
tuples		(tup)		(5,3,2,1)			lista de datos estatica, tiene indice.
sets		(set)		{1,3,6,2}			conjunto de datos únicos.
boleanos	(bool)		True, False			valor booleano, es como binario 0 y 1.


VARIABLES:
-------------------------------------------
*Son letras que contienen valores.
*Consejos a tener en cuenta al declarar una variable.
	-regla1:legible.
	-regla2:unidad.
	-regla3:hispanios.
	-regla4:números.
	-regla5:signos.
	-regla6:palabra clave.


-------------------------------------------------
|		comandos:			|
-------------------------------------------------
type(variable)					nos permite conocer el tipo de dato de la variable.
int(variable)					para convertir los datos a tipo entero.
str(variable)					para convertir los datos en cadena de carácteres.
float(variable)					para convertir los datos a tipo flotante.

round(n1,#decimal)				sirve para redondear numeros, sino indicamos el 2do parámtero redondea al entero más proximo.



FORMAS DE CONCATENAR TEXTOS:
-------------------------------------------------
print("texto{} texto2 {}".format(n1,n2))		
print(f"texto{n1} texto2 {n2}")
print(n1,n2,"texto")						lo imprime como si fuera una tupla, es decir que imprime los valores de la misma.



OPERADORES MATEMATICOS:
-------------------------------------------------
simbolo			nombre				definición
----------		-----------			-------------------
+			suma				suma las variables
-			resta				resta las variables
*			multiplicación			multiplica las variables
/			división			divide las variable
//			división al piso		devuelve el cociente al dividir
%			módulo				devuelve el residuo al dividir
**			potencia			eleva a la potencia a las variables


---------------------------------------------------------------------------------------------------------------------------------
|								DIA 3								|
---------------------------------------------------------------------------------------------------------------------------------
*Los string en Python siempre empiezan por el índice 0.


---------------------------------------------------------
|	METODOS PARA MANIPULAR TEXTOS:			|
---------------------------------------------------------
*manipular textos, también archivos, etc.

variable.index("carácter")				Nos devuelve el índice del caráter o palabra indicada. Buscara respecto al primer carácter de la palabra dada.
variable.index("carácter",a,b)				'a' hace referencia al indice de donde comenzara buscar, 'b' hace referencia hasta el indice anterior llegara. la busqueda es de 								izquierda a derecha.	
variable.rindex("carácter")				Este metodo funciona igual que index, pero la busqueda es al reves, es decir; de derecha a izquierda.			
variable.rindex("carácter",a,b)				
variable.find("carácter")				fin funciona igual que index, la diferencia esta en que si find no encuentra la palabra, devolvera -1, en cambio index vota error.
variable.rfind("caráct	er")				busca de derecha a izquierda. (

texto[a:b]						muestra desde el indice a hasta el indice b-1 del texto
texto[a:b:n]						el tercer carácter hace referencia a cuanto en cuanto va avanzar.

variable.count("palabra")				Cuenta cuantas veces se repite esa palabra.
variable.startswith("palabra")				devuelve un valor booleano si palabra comienza con la indicada.
variable.endswith("palabra")				devuelve un valor booleano si la palabra comienza con la indicada.

variable.isdigit()					determina si todos los carácteres son digitos, o pueden formar números, incluido a lenguas orientales.
variable.isnumeric()					determina si todos los carácteres son numeros. Incluye también carácteres de connotación numerica que no necesariamente son digitos.
variable.isdecimal()					determina si todos los caracteres son decimales, es decir que sus carácteres esten entre 0-9
variable.isalnum()					determina si todos los caracteres son alfanumericos.(es decir numeros y letras)
variable.isalpha()					determina si todos los caracteres son alfabeticos.(solo letras del abcedario)

variable.islower()					determina si todos los carácteres de la variable son minúsculas.
variable.isupper()					determina si todos los carácteres de la variable son mayúsculas.
variable.isprintable()					determina si todos los carácteres especiales son imprimibles, es decir si no son carácteres especiales (ejemplo \...)
variable.isspace()					determina si todos los carácteres son espacios.

variable.capitalize()					retorna todo el texto con el primer carácter en mayúscula.
variable.encode()					codifica la cadena con el mapa de carácteres especificado y retorna una estancia del tipo bytes. (ejem "hola mundo".encode(utf-8))
variable.replace(a1,a2)					remplaza la cadena a1 por a2 en la variable en toda la variable.					
variable.lower()					retorna una copia de variable con todos sus carácteres en minúsculas.
variable.upper()					retorna una copia de variable con todos sus carácteres en mayúsculas.

variable.swapcase()					cambia las mayúsculas por minúsculas y visceversa.
variable.strip()					remueven los espacios en blanco de más precedentes  y/o suceden en la cadena.
variable.lstrip()					lo mismo que strip.
variable.rstrip()					lo mismo que strip.
variable.center(a,"carácter")				alinea el texto en el centro, la primera variable indica en cuantos espacios y la segunda que carácteres usara, por defecto es espacio.
variable.ljust()
variable.rjust()

variable.split()					divide las cadenas de texto de variable según el carácter que le indiquemos(por defecto son espacios). El segundo caracter indica cual
							es el maximo de divisiones que puede tener lugar (-1) por defecto

variable.splitlines()					divide una cadena por cada aparición de un salto de linea.
variable.partition("carácter")				retorna 3 tuplas, 1 un bloque de carácteres anterior al primer separador carácter indicado, 2 el carácter separador y 3 el bloque de 								carácteres posterior.
variable.rpartition()					opera lo mismo que partition pero de izquierda a derecha.

"carácter".join(variable)				une los elementos de una lista, tupla, etc. en un solo string añadiendo entre los elementos el carácter indicado.





PROPIEDADES DE LOS STRINGS:
----------------------------------
*Los string son inmutables. Es decir que tu no puedes hacer esto variable[i]="otro valor", es decir los objetos de string no soportan asignación de items.
*son multiplicables y concatenables. Ejemplo variable*2
*son verificables. Ejemplo "hola" in variable    , "hola" not in variable.
*los comentarios anchos se pueden usar como un string. variable=''' hola amigos ''' (esto es útil para hacer saltos de líneas sin usar los carácteres especiales.)
*Se puede calcular la longitud.	len(variable)   Nos dira la cantidad de carácteres de nuestro string.


---------------------------------------------------------
|		METODOS PARA LISTAS:			|
---------------------------------------------------------
*Son ordenadas.
*Aceptan cualquier tipo de dato.
*Se puede anidar listas, tener listas de listas.
*Las listas si son inmutables.
*a=[1,'a',2] esto es un ejemplo de una lista.
*lista hace referencia a una variable lista.

len(lista)						nos dira el tamaño de elementos de nuestra lista.
lista.append(elemento)					añade un elemento a nuestra lista, este elemento se agrega al final y se guarda ya en lista.
lista.insert(i,elemento)				añade en el indice dado un elemento, se autoguarda.
lista.pop()						elimina el ultimo elemento de la lista.						
lista.pop(i)						elimina el indice indicado de la lista. este valor se auto guarda, pero también se puede guardar en una variable.

lista.sort()						ordena la lista alfabeticamente y lo autoguarda.
lista.reverse()						ordena los elementos de la lista al reves (ojo no los ordena alfabeticamente). Lo autoguarda




---------------------------------------------------------
|		METODOS PARA DICCIONARIOS:		|
---------------------------------------------------------
*Estas compuestos por una palabra clave y un valor asociado a esa clave. Las claves son unicas.
*a={'hola':5,'sa':'maria'} esto es un ejemplo de diccionario.
*no tienen un orden especifico. Esto indica que no se puede buscar un valor respecto a sus indices.
*el tipo de dato es 'dict'
*diccionario hace referencia a una variable diccionario.


diccionario['clave1']					Esto nos devolvera el valor de esa clave.
diccionario["nuevaClave"]=valor				Esto es para añadir una nueva clave y su respectivo valor a nuestro diccionario. Si la clave ya existe, se modifica solo el valor.
diccionario.keys()					Muestra las claves de un diccionario.
diccionario.values()					Muestra los valores de las claves del diccionario.
diccionario.items()					Muestra cada clave con su valor en forma de tuplas.




---------------------------------------------------------
|		METODOS PARA TUPLAS:			|
---------------------------------------------------------
*Son muy parecidas a las listas, pero sus elementos son inmutables.
*Se usa por ocupan menos espacios que las listas (eficiencia).
*Se usa para hacer estructuras a pruebas de daños.
*a=(1,2,3,4,'a') Este es un ejemplo de tupla. No es necesario usar las parentesis.			
*El tipo de dato es tuple.
*Son ordenadas, es decir tienen indices como las listas.
*Muchos metodos de listas funcionan con las tuplas.




---------------------------------------------------------
|		METODOS PARA CONJUNTOS(set):		|
---------------------------------------------------------
*a={1,2,4,5} p a=set([1,2,4,5])	son dos formas de crear un set(conjunto).
*Los elementos de un set no tienen orden.
*Los elementos de un set son inmutables.
*Los elementos de un set no pueden ser listas, ni diccionarios. Pero si tuplas.
*sean set,set1,s2 variables tipo set.

len(set)						nos indicara el número de elementos de nuestro set.

set1.union(set2)					nos devolvera la unión de los elementos de nuestro set.
set1.update(set2)					une los elementos de set2 a set1 y los autoguarda.
set1.difference(set2)					nos devuelve solo los elementos del set1 que no esten incluidos en set2.
set1.difference_update(set2)				remueve de set1 todos los elementos comunes entre set1 y set2. Se autoguarda
set1.intersection(set2)					nos devuelve los elementos comunes entre el set1 y set2.
set1.intersection_update(set2)				mantiene unicamente los elementos comunes entre set1 y set2. Y los autoguarda en set1.
set1.symmetric_difference(set2)				nos devolvera la diferencia simetrica entre set1 y set2, es decir nos devuelve la unión menos la intersección.
set1.symmetric_difference_update(set2)			elimina los elementos comunes entre entre set1 y set2, y los une los demás, autoguardandolo en set1.			

set1.isdisjoint(set2)					devuelve True si no hay elementos comúnes entre set1 y set2.
set1.issubset(set2)					devuelve True si set1 esta incluido en set2.
set1.issuperset(set2)					devuelve True si set2 esta incluido en set1.

set1.add(elemento)					Agrega un elemento a nuestro set y los autoguarda.
set1.remove(elemento)					Elimina un elemento de nuestro set, si el elemento no esta votara error.
set1.discard(elemento)					Elimina un elemento de nuestrp set, pero no devolvera error si no lo encuentra.
set1.pop()						Como no indicamos el elemento a eliminar, eliminara un elemento de forma aleatoria.
set1.clear()						Elimina todos los elementos de nuestro set. Y los autoguarda.
set1.copy()						retorna una copia del set.



---------------------------------------------------------
|		METODOS PARA BOOLEANOS(set):		|
---------------------------------------------------------
*Los booleanos son tipos de datos binarios (True/False), que surgen de operaciones lógicas, o pueden declararse explícitamente.
*a=bool() esto hace referencia un valor False.

operadores de comparción:
-----------------------------
elemento1	<	elemento2			comprueba si elemento1 es menor que elemento2. y devuelve el valor booleano correspondiente.					
elemento1	>	elemento2			comprueba si elemento1 es mayor que elemento2.
elemento1	<=	elemento2			comprueba si elemento1 es menor o igual que elemento2.
elemento1	>=	elemento2			comprueba si elemento1 es mayor o igual que elemento2.
elemento1	==	elemento2			comprueba si elemento1 es igual que elemento2.
elemento1	!=	elemento2			comprueba si elemento1 es diferente que elemento2.

operadores lógicos:
----------------------
and							expresión lógica que hace referencia a 'y'
or							expresión lógica que hace referencia a 'o'
not							hace referencia a 'no'
in							hace referencia a 'en' o 'dentro'
not in							hace referencia a 'no en' o 'no dentro'
-----------------------------------------
|		CASTING:		|
-----------------------------------------
*Se dice casting al cambio de datos para darle otro uso.

tuple(variable)						convierte a variable en tipo de dato tuple
list(variable)						convierte a variable en tipo de dato list
set(variable)						convierte a variable en tipo de dato set
dict(variable)						convierte a variable en tipo de dato dict
str(variable)						convierte a variable en tipo de dato str
int(variable)						convierte a variable en tipo de dato int
float(variable)						convierte a variable en tipo de dato float
bool(variable)						convierte a variable en tipo de dato bool


---------------------------------------------------------------------------------------------------------------------------------
|								DIA 4								|
---------------------------------------------------------------------------------------------------------------------------------

control de flujo:
-----------------
if condicion:
	codigo
elif condicion:
	codigo
else:
	codigo



LOOPS(bucles):
---------------

-------------------
|	FOR	  |
-------------------
for 'elemento' in 'variable':				para cada 'elemento' de nuestra 'variable', la variable debe ser iterable. elemento tomara uno a uno el valor de nuestro iterable.
	codigo

for a,b in variable:					para elementos pares de nuestra variable.
	codigo		

-------------------
|	WHILE	  |
-------------------
while una_codicion:					Mientras la condición se cumpla, el código se seguira ejecutando.
	codigo

else:
	otro_codigo					Se ejecutara en caso el while deje de ejecutarse o no se ejecute.


---------------------------------------------------------
|		METODOS PARA LOOPS:			|
---------------------------------------------------------
*Estos metodos aplican para 'for' y 'while'.

break							Interrumpe el loop para salir directamente.
continue						Interrumpe la interación actual y pasa a la siguiente.
pass							se lo usa cuando aún no podes el código en los loops y no te salga un error por dejar espacio vacio.
	

range:
---------------
range(a)						para un rango de 0 hasta un rango menor que a.
range(a,b)						para un rango de a hasta menor que b.
range(a,b,c)						indicamos para un rango de 'a' hasta menor que 'b' aumentado de 'c' en 'c'.

list(range(a,b))					creara una lista de elementos cuyo valor va desde 'a' hacia menor que 'b'.


enumerate:
---------------
enumerate(variable)					devolvera una tupla donde sus elementos seran una tupla de cada indice con su elemento. Pero debemos pasarlo a lista o tupla por que 								sino solo nos mostrara una posición de memoria.

for i in enumerate(variable):				enumerate hace el iterador tenga por elmentos a cada indice y su elemento de nuestra variable iterable.
	print(i)					mostrara (0,elemento1)... y asi sucesivamente.



zip:
---------------
*si una lista tiene mas elementos que la otra, tomara en cuenta solo hasta que se agote la cantidad de elementos de la mas pequeña, y procede a ignorar lo demás.
*


zip(lista1,lista2)					creara un lista siendo cada elemento un tuple con elementos, el primero de la lista1 y el segundo de la lista2. 
zip(lista1,lista2,lista3)				incluso pueden ser mas listas que solo 3. (pueden ser tuplas, string; cualquiera que sea iterable)

list(zip)						debemos hacerle un casting a algún tipo de colección sino se vera solo una posición en memoria.



min y max:
--------------
*encuentran el valor minimo o maximo de una colección.(tanto numericos como alfabeticos)
*pueden ser int, float, str, list, tuple, set, diccionari,etc.
*recuerda que se basa en el código ascii.

min(variable)						encuentra el valor minimo de nuestra colección.
max(variable)						encuentra el valor maximo de nuestra colección.


random:
--------------
*estos son algunos metodos del modulo random
*para usar estos metodos no olvidemos importar el modulo random

from random import *					importa todos los metodos de este modulo.
from random import randint				importa el metodo randint del mondulo random.
import random						importa el metodo random, pero ten cuidado ya que no importa todo.

randint(a,b)						nos dara un numero entero aleatorio entre 'a' y 'b' (si incluye a b)
uniform(a,b)						nos dara un numero real aleatoria entre 'a' y 'b'
random()						no necesita parámetros, elije un numero real aleatorio entre 0 y 1.
choice(variable)					nos devuelve un elemento aleatorio de nuestra colección.
shuffle(variable)					ordena nuestra colección de manera aleatoria.(no puede ser un string), suffle se autoguarda. Por eso no puede hacer con inmutables



comprensión de listas:
-----------------------
*es poner el código en una linea.

ejemplo 1:
	palabra='python'
	lista=[letra for letra in palabra]		#cada elemento de la lista sera 'letra' para cada 'letra' en 'palabra'.

	print(lista)					#devolvera ['p','y','t','h','o','n']

ejemplo 2:
	lista=[n for n in range(0,5)]

ejemplo 3:
	lista=[n for n in range(0,10) if n*2>10]

ejemplo 4:
	lista=[n if n*2>10 else "no" for n in range(0,10)]

ejemplo 5:
	lista2=[p*5 for p in lista1]

ejemplo 6:
	(codigo) if (condicion) else (codigo)			si se cumple la condición mostrara el código a la izquierda de if, caso contrario mostrara el código a la derecha de else.

ejemplo 7:
	(codigo) if (condicion) else (codigo) for n in variable:





match:
-----------
*Esta es una nueva herramienta agregada por python, esta herramienta es como el switch en otros lenguajes.
*Pero incluso es mas potente, ya que nos permite detectar patrones, es decir detectar estructura, como se puede ver en el ejemplo 2.


sintaxis:

match variable:							Si 'variable' tiene alguno de los siguientes valores.
	case a:							si tiene el valor de 'a' se ejecuta el siguiente código
		codigo
	case b:							si tiene el valor de 'b' se ejecuta el siguiente código
		codigo
	case _:							Esto indica valor por defecto, es decir para cualquier otro valor de nuestra variable
		codigo


Ejemplo 1:
- - - - - -
serie="N-02"
match serie:
    case "N-01":
        print("Samsung")
    case "N-02":
        print("Nokia")
    case "N-03":
        print("Motorola")
    case _:							·
        print("No existe este producto")


Ejemplo 2:
- - - - - -
cliente={'nombre':'Dax',
         'edad':27,
         'ocupacion':'programador'}

pelicula={'titulo':'Call duty',
          'ficha_tecnica':{'protagonista':'Elmer Santos',
                           'director':'Pamela Victorio'}}

elementos=[cliente,pelicula,'canto']

for e in elementos:
    match e:
        case {'nombre':name,'edad':age,'ocupacion':ocupation}:
            print("Es un cliente")
            print(name, age, ocupation)

        case {'titulo':title,'ficha_tecnica':{'protagonista':protagonist,'director':director}}:
            print("Es una pelicula")
            print(title, protagonist, director)

        case _:
            print("No se que es esto")



---------------------------------------------------------------------------------------------------------------------------------
|								DIA 5								|
---------------------------------------------------------------------------------------------------------------------------------
*métodos son funciones de los objetos. Permiten manipularlos, analizarlos, ejecutar acciones.


Metodos, ayuda y documentación:
---------------------------------



-------------------------------------------------------------
|			FUNCIONES	   	            |
-------------------------------------------------------------
*

sintaxis simple:
- - - - - - - - -
1)

def mi_funcion():						definimos la función
	'''información descriptiva'''				damos información sobre que trata la función
	código							el código que se ejecuta una vez sea llamada la función


mi_funcion()							Con esto llamamos a la función


2)
def mi_funcion(argumento):
	'''Documentación para explicar de que trata'''			
	codigo


mi_funcion(valor)						Llamamos la función pero pasandola un valor



-------------------------
|	return		|
-------------------------
*Se usa para que las funciones devuelvan algo.


|-------iteración entre funciones----------|


|------argumentos indefinidos------------|
- * y ** se usan para desmpacar.
- *args nos permite definir funciones cuyo numero de argumentos sean variables.(args es solo una palabra, lo clave es * como se puede ver en el siguiente ejemplo)
ejemplo1:
def suma(*args):
	for i in args:
		print(i)

suma(1)						# Se le paso 1 argumento
suma(1,2)					# Se le paso 2 argumentos
suma(1,2,4,6,1)					# Se le paso varios argumentos y no ocurrio un error.


- **kwargs funciona de forma similar que *args , la diferencia es que trabaja muy bien con diccionarios, como veremos en el siguiente ejemplo. (kwargs es solo una palabra, lo clave es **)
ejemplo2:
def suma(**args):
	#algun_codigo

suma(a=1,b=2,c=3)				#**args guardara cada variable como si fuera un str y a la vez clave y valor de la variable como valor de un diccionario.


ejemplo3:


def prueba(num1,num2,*args,**kwargs):
    print(f"el primer valor es {num1}")
    print(f"el segundp valor es {num2}")

    for arg in args:
        print(f"arg = {arg}")

    for clave, valor in kwargs.items():
        print(f"{clave} = {valor}")


args=[10,20,30,40]
kwargs={'a':1,'b':2}

prueba(1,2,*args,**kwargs)			#Como vemos pasamos las variables desmpaquetadas.


---------------------------------------------------------------------------------------------------------------------------------
|								DIA 6								|
---------------------------------------------------------------------------------------------------------------------------------
*from io import *



-abrir y manipular archivos-:
---------------------------------

mi_archivo=open('Prueba.txt')					#abre el archivo de prueba y lo guarda en la variable, en este ejemplo el archivo esta en la misma ruta del archivo python.
mi_archivo=mi_archivo.read()					#Prepara el archivo para ser leído y mostrarlo en pantalla

una_linea=mi_archivo.readline()					#guarda la primera linea en aquella variable, volvera hacer lo mismo guardara la siguiente linea (considerar que cada fin de 									linea tiene un salto de linea que es un carácter en python)


una_linea=mi_archivo.readline().rstrip()			#Elimina el salto de linea de la linea.


una_linea=mi_archivo.readlines()				#guarda cada linea como elemento de una lista en la variable.




una_archivo.close()						#Como buena práctica cerramos el archivo que hemos abierto.




-crear y escribir archivos-:
-----------------------------
open('namearchivo','modo_apertura')				#son tres modos de apertura (r,w,a,x) . por defecto viene 'r'. 
								'r' indica abrir el archivo en modo lectura
								'w' abre el archivo en modo escritura, en caso el archivo ya existe es vaciado, en caso no exista lo crea.
								'a' abre el archivo en solo modo escritura, en caso el archivo ya existe, se posicia al final del archivo.
								en caso de que el archivo no exista lo crea.
								'x' crea un archivo, y arroja un error si el mismo ya existe en el directorio.



mi_archivo=open("prueba.txt",'w')				abre o crea el archivo en modo escritura y lo guarda en la variable.
mi_archivo.write(texto)						empieza a escribir en el archivo, borra todo su contenido

mi_archivo.write('''asd						escribe en el archivo pero tal como esta aqui, cada linea una linea en el texto
fsdf
dfsdf
sd''')


mi_archivo.writelines(lista)					escribe cada elemento de la lista juntos.
	
mi_archivo=open("prueba.txt",'a')				escribe pero esta vez al final del contenido. Los mismos metodos para 'w' se pueden usar aquí.


--------------------------
--	directorios	--
--------------------------
*importaremos os						nos permite trabajar con comandos que aplican sobre el sistema operativo

import os
os.getcwd()							nos permite obtener la dirección del directorio actual en el que nos encontramos.	
os.chdir('ruta')						nos permite cambiar la ruta del directorio actual para así poder abrir archivos de la nueva ruta en la que estamos. devuelve
								ruta="C:\\Users\\Windows" (por ejemplo esa ruta, ten en cuenta que se usa \\ por si se pone uno lo reconoce python como un 									cáracter especial) . Devuelve None

os.makedirs('ruta\\newDirectory')				permite crear un nuevo directorio en la ruta indicada
os.rmdir(ruta)							Elimina el directorio de la ruta dada, devuelve error si el directorio no esta vacio y si no existe el directorio.
os.open(namearchivo,'w')					crea un archivo
os.remove(nameArchivo)						Elimina el archivo señalado
os.unlink(nameArchivo)						Elimina el archivo señalado,es igual que os.remove()


os.path.basename('ruta\\archivo')				Nos devolvera el nombre del archivo dada una ruta.
os.path.dirname('ruta\\archivo')				Nos devolvera toda la ruta en la que se encuentra el archivo.
os.path.split('ruta\\archivo')					Nos devolvera una tupla con ('ruta_del_directorio_del_archivo','nombre_archivo')


a=os.popen('comandoCMD')					Nos genera un objeto que guarda todo lo generado por el comando en la consola y lo podemos guargar en la variable a
a.readlines()							Nos genera una lista donde sus elementos son cada linea generado de la consola generado por el comando cmd.
for e in a.readlines():print(e,end="")				Mostrara como si hubieramos captura todo lo generado por el comando de la consola.


*importaremos pathlib

from pathlib import Path

carpeta=Path('C:/Users/Windows')				Nos permite que python abra la ruta de esa carpeta no importando el sistema operativo. (pero se usa /)
archivo=carpeta / 'nombreArchivo'				y así indicamos el archivo con el que queremos trabajar. (pudimos haberlo hecho también en la misma ruta de carpeta)

carpeta=Path('/ruta/ruta2')					Pudimos también haberla declarado así, sin el 'C:'
capeta=Path('/ruta/ruta2') / 'archivo'			


carpeta=Path('ruta/archivo')
carpeta.read_text()						Nos permite leer directamente el contenido del archivo sin necesidad de abrirlo y cerrarlo.



carpeta.name							devuelve el nombre y extensión del archivo.
carpeta.suffix							nos devuelve la extensión del archivo.
carpeta.stem							nos devuelve solo el nombre del archivo sin su extensión
carpeta.exists()						verifica si el directorio de carpeta existe o no, retorna un valor booleano.

ruta_windows=pathlib.PureWindowsPath(carpeta)			Devuelve la ruta de la carpeta pero adaptandola al formato de windows, es decir con las \. y lo guarda en la variable 
								ruta_windows



-from pathlib import Path
base=Path.home()						Devuelve el directorio base de nuestro sistema.
ruta=Path(*lista)						Si pasamos una lista, Path une los elementos como si fueran directorios cada uno para crear una ruta. Pero debeos desempaquetar
								la lista

ruta=Path(base,'amigo','hola',path('peru','lima.txt'))		Crea una ruta con todos esos elementos y los guarda en la variable ruta.
ruta2=ruta.with_name('archivo')					Ahora esta ruta apunta del mismo directorio de ruta, pero a otro archivo señalado
ruta.parent							devuelve la ruta del directorio padre
ruta.parent.parent						devuelve la ruta del directorio padre del padre, esto se puede usar muchas veces hasta ir recorriendo todos los directorios.
ruta.parents[i]							i toma un valor natural que puede ir desde 0. 	i=0 indica 1 parents.
														i=1 indica 2 parents.
														i=2 indica 3 parents. Y así sucesivamente.

ruta.parents[i]							si i toma valor negativo, empezara por el principio. 	i=-1 hace referencia al directorio raíz.
															i=-2 hace referencia al siguiente de raíz. Y así sucesivamente


ruta=Path('ruta1')
for e in ruta.glob('*'):					ruta.glob, nos permite indicar si con su argumento si es '*' cualquier contenido. '*.*' cualquier tipo de archivo de la ruta 		print(e)						dada. 'e' ira tomando cada contenido que hay en esta ruta. '**/*' mostrara incluso el contenido de los directorios internos
								'**/*.*' mostrara todos los archivos e incluidos de sus subdirectorios.
							

ruta.glob('*')							muestra todos los items(carpetas y archivos de esta ruta)
ruta.glob('*.*')						muestra todo lo que tiene un . en su nombre (generalmente archivos por su extensión)
ruta.glob('**/*')						muestra todo (carpetas, archivos, subcarpetas y sus archivos, sub de subcarpetas, y sus respectivos archivos, es decir todo)
ruta.glob('**/*.*')						muestra todos los archivos (incluso de las carpetas internas que tenga y estas tienen carpetas internas, también lo muestra)
ruta.glob('*/')							muestra las carpetas del directorio en el que estamos

ruta=Path('a','b','c','d')					suponiendo que ruta sea igual a ese Path (a/b/c/d)
sub_ruta1=ruta.relative_to('a')					sub_ruta1 sera igual al path (b/c/d), ya que indicamos que sea relativo a la ruta 'a'.
sub_ruta2=ruta.relative_to('a','b')				sub_ruta2 sera igual al path (c/d), ya que indicamos que sea relativo a las rutas 'a' y 'b'. Funciona al reves del metodo 									parent


ruta.mkdir()							crea el directorio para la ruta dada.
ruta.rmdir()							Elimina el directorio para la ruta dada.

ruta2=Path('ruta1/newArchivo.txt')
ruta2.open('w')							crea el archivo de la ruta señalada.
ruta2.open('w').write('texto')					crea el archivo y escribe el texto (es la misma logica que usar io)
ruta2.unlink()							Elimina el archivo señalado.



*Para limpiar la consola
*La consola es de pychar y haremos que esta simule ser una consola de windows configurandola, puede que este metodo no te funcione con otro IDE

from os import system
codigo
system('cls')							#si tu sistema es windows o DOS.
system('clear')							#si tu sistema es linux,Unix o MacOS.



-------------------------------------------------------------------------
|	Metodos para abrir,manipular archivos y directorios		|
-------------------------------------------------------------------------
open("c:\\ruta\\archivo",'modo_apertura')				abre cualquier archivo no importa su ruta. Sino indicamos la ruta completa buscara en la ruta actual
									usamos 2 barras para que python no considere ese carácter especial. (Esto es en windows)


open("c:/ruta/archivo",'modo_apertura')					la barra invertida en mac.



import platform 
platform.system()							devuelve el nombe del sistema operativo que estamos usando, ejemplo: devuelve Windows si el sistema operativo es
									windows.

---------------------------------------------------------------------------------------------------------------------------------
|								DIA 7								|
---------------------------------------------------------------------------------------------------------------------------------
PROGRAMACION ORIENTADA A OBJETOS:
---------------------------------
*Esta basada en 6 principios básicos:
	-herencia
	-polimorfismo
	-cohesión
	-abstración
	-acoplamiento
	-encapsulamiento


Syntax básica:
--------------

class Name:
	codigo


variable=Name()



atributos:
-----------
*Existen 2 tipos de atributos. De clase y de instancia
*De instancia son las que se definen dentro de la clase, por lo general recien un valor
*De clase son aquellas que ya estan definidas dentro de la clase
*a las funciones dentro de las clases se les conoce como metodo.

class Name:
	a=False					#atributo de clase

	def __init__(self,color):		#a esta funcion se le conoce como el constructor, o también dicho metodo constructor
		self.color=color		#atributo de instancia





tipos de metodos:	
-------------------------
*metodos de instancia
	-acceden y modifican atributos del objeto	
	-acceder a otros objetos
	-modificar el estado de la clase
	-afecta a las instancias de nuestra clase
	-son las que usan self

	def mi_metodo(self):
		codigo
	
	mi_metodo()


*metodos de clase	(que se crean usando @classmethod)
	-estos metodos son propias de la clase y no necesitan de una instancia de la clase.
	-al no necesitar de la instancia, no pueden acceder a los atributos de la instancia.
	-pero si pueden acceder a los atributos de clase

	
	@classmethod
	def mi_metodo(cls):
		codigo



*metodos estaticos	(que se crea usando @staticmethod)
	-estos metodos son como funciones normales, con la limitante que estan dentro de la clase, no reciben ni self ni a la clase como parametros.
	-como no reciben la clase ni la instancia, no pueden modificar ningun atributo.

	@staticmethod
	def mi_metodo():
		codigo



---------------------------------------------
|		HERENCIA		    |
---------------------------------------------
*la herencia de clases es cuando una clase hereda atributos y metodos de otra clase(llamada clase padre) y esta pasa ser la clase hija

ejemplo de sintaxis:
---------------------
class Animal:
    def __init__(self,edad,color):
        self.edad=edad
        self.color=color

    def nacer(self):
        print("Este animal ha nacido")

class Pajaro(Animal):
    pass


piolin=Pajaro(2,'rojo')				#Como la instancia piolin de Pajaro cuenta con los metodos y atributos de la clase Animal





herencia extendida:
-----------------------
*Las clases que heredan van buscando sus metodos y atributos en sus clases padres, y luego en las padres de estas respectivamente.

ejemplo 1:
-------------
class Animal:
    def __init__(self, edad, color):
        self.edad = edad
        self.color = color

    def nacer(self):
        print("Este animal ha nacido")

    def hablar(self):
        print("Este animal emite un sonido")

class Pajaro(Animal):
    def __int__(self,edad,color,altura_vuelo):
        super().__init__(edad,color)					#super.__init__() llama al metodo constructor del padre, es la forma mas comoda de usar los atributos del padre
        self.altura_vuelo=altura_vuelo

    def hablar(self):							#en caso el padre y el hijo tengan el mismo metodo, prioriza el metodo del hijo
        print("Pio")

    def volar(self,metro):						#cada clase hijo puede tener sus propios metodos y atributos.
        print(f"Ha voldado {metro} metros")



ejemplo 2:
------------
class Padre:
    def __init__(self,p):
        self.p=p

class Hijo(Padre):
    def __init__(self, h):
        super().__init__(h)						#hereda el constructor de su padre, sino estuviera este codigo su hijo solo heredaria de aqui
        self.h = h

class Nieto(Hijo):							#hereda el constructor de su padre
    pass




ejemplo 3:
------------
class Padre:
    def hablar(self):
        print('hola')

class Madre:
    def reir(self):
        print("jaja")

    def hablar(self):
        print('que tal')

class Hijo(Padre,Madre):						#Aqui hay una herencia multiple, primero hereda de padre, luego busca en madre si no encuentra los metodos.
    pass

class Nieto(Hijo):
    pass



POLIMORFISMO:
--------------
*Es aplicar metodos del mismo nombre a distintas instancias de diferentes clases
*Como vemos en el ejemplo, de las 2 formas llamamos a distintas instancias pero llamando a metodos del mismo nombre pero que tienen distinta función.

class Vaca:
    def __init__(self,nombre):
        self.nombre=nombre

    def hablar(self):
        print(self.nombre+"dice muuu")


class Oveja:
    def __init__(self, nombre):
        self.nombre = nombre

    def hablar(self):
        print(self.nombre + "dice beee")

def Animal_habla(animal):
    animal.hablar()

vaca1=Vaca('Lola')
oveja1=Oveja('lele')

#forma1
lista=[vaca1,oveja1]

for animal in lista:
    animal.hablar()

print("\n")

#forma
Animal_habla(vaca1)


ENCAPSULAMIENTO:
-----------------------------------
*Es anteponer ' __ ' a los atributos o metodos para que estos sean inaccesible desde el exterior. 


class Persona:
    atributo_publico = "Mostrar"   # Accesible desde el exterior
    __atributo_privado = "Oculto"  # No accesible
    # No accesible desde el exterior
    def __metodo_oculto(self):
        print("Este método está oculto")
        self.__variable = 0
    # Accesible desde el exterior
    def metodo_normal(self):
        # El método si es accesible desde el interior
        self.__metodo_oculto()
alumno = Persona()
# alumno.__metodo_oculto()  # Este método no es accesible desde el exterior
alumno.metodo_normal()      # Este método es accesible


*Existe un pequeño truco (no recomendado) para acceder a los atributos y métodos ocultos. Dichos métodos están presentes con un nombre algo distinto:
	
	instancia.+ _ + NombreClase +__+ método/atributo oculto
	
Del ejemplo anterior:
----------------------
alumno._Persona__metodo_oculto()
print(alumno._Persona__atributo_privado)



Metodos especiales en las clases:
-----------------------------------------------------------------------------------------------
*También conocidos métodos magicos o metodos dunder(En ingles dunder==double underscore; o doble guion baho). Pueden ayudarnos a sobrescribir métodos incorporados de Python sobre nuestras
clases para controlar el resultado devuelto.
*Estos metodos estan en todas las clases ocultamente.
*Recuerda que todas son funciones internas de la clase, lo hemos puesto de la siguiente manera por que va acorde mas a su utilidad.


def __init__(self):							#Sirve para inicializar los atributos de una clase nueva. Conocida como constructor.
def __str__(self): return algo						#Nos sirve para modificar y poder ver algo al llamar a las intancias sin metodo. nos retorna lo que le demos
def __len__(self): return algo						#Cuando hagamos un lento a una instancia de la clase, ya no votara error, sino returnara lo que le hayamos dado en 										return, podemos hacer lo mismo para int,float, abs,etc...
def __int__(self): return algo						#al aplicarle un int ya no vatara error sino devolvera algo
def __float__(self): return algo
def __abs__(self): return algo
def __del__(self): return algo						#ahora al eliminar un objeto mostrara lo dado en return.


clase1.__bases__							#Este metodo nos muestra de que clase esta heredando nuestra clase1 (Nos muestra a su padre)
clase1.__subclasses__()							#Nos muestra una lista, donde sus elementos son las clases a las que le hereda su atributo (sus hijas)
clase1.__mro__								#Nos muestra el orden en el que se organiza la busqueda de los metodos heredados. 



super().__init__(variabl1,variable2...)					#para heredar de nuestra clase padre.
del variable								#del es una palabra clave, que elimina cualquier variable, objeto, etc. de la memoria de python




Ejmplo:
---------
class CD:
    def __init__(self,autor, album, cantidad):
        self.autor=autor
        self.album=album
        self.canciones=cantidad

    def __str__(self):
        return "Album: "+self.album+" de "+self.autor

    def __len__(self):
        return self.canciones

    def __del__(self):
        print('He sido eliminado')

mi_cd=CD('Pink Floyd','The Wall',24)

print(mi_cd)
print(len(mi_cd))


del mi_cd



---------------------------------------------------------------------------------------------------------------------------------
|								DIA 8								|
---------------------------------------------------------------------------------------------------------------------------------
*Se veran los siguientes temas:
	-como instalar paquetes
	-crear modulos y paquetes
	-manejo de errores
	-detectar error con pylint
	-probar el código con unittest
	-decoradores
	-generadores



INSTALAR PAQUETES:
-------------------
* Se le llama paquete a un conjunto de modulos y metodos(recuerda que cada modulo tiene sus metodos)
*PyPi (Se les llama así a los repositorios de python que contienen esos modulos y metodos que estamos necesitando instalar para que cumpla con nuestro requerimiento)
	http://pypi.org		es el repositorio oficial de python
*pip install (es un comando del cmd que se instala al instalar python en nuestro ordenador), estos paquetes instalados se cargan en la memoria de python y luego solo haria falta importarlos
*también podemos directamente descargarlos y instalarlos manualmente sin la necesidad de usar pip
*Hasta ahora hemos utilizado solo códigos, metodos, módulos,etc. ya instaladas por defecto en Python (también llamadas bibiliotacas integradas o estandar)
 

pasos:
	-buscar en google , se recomienda buscar en ingles por que hay mas opciones 
		-por ejemplo: python packages for console text colors	()

	-la busqueda nos dara varios sitios, se recomienda buscar en los repositorios oficiales. (http://pypi.org)
		-por ejemplo: una vez encontramos el sitio, nos dara la indicacion para instalar con pip
			-para nuestro ejemplo nos sale 'pip install colored'	
			-una vez instalado ya podemos usar sus metodos y modulos pero no olvides importarlos. (import colored) o (from colored import fb,bg,attr) para solo metodos especificos


	ejmplos2:
	-buscamos en google 'python packages for excel'
	-localizado el paquete desado; lo instalamos 'pip install openpyxl'
	-importamos openpyxl para usar sus modulos o metodos.





MODULOS Y PAQUETES:
-------------------------
*modulo se le denomina a cualquier archivo .py (osea cualquier archivo python es un modulo)
*usando 'import' podemos importar todo el contenido de un módulo.
*los paquetes son colecciones de modulos.
	-todo paquete de contener un archivo(modulo) llamado __init__.py  (esto es para que python entienda que se trata de un paquete y no de usa simple carpeta)
	-puedes tener subpaquetes dentro de tus paquetes, pero cada subpaquete de tener este archivo __init__.py para que sean considerados como paquetes




syntax:
----------
*Se pueden importar paquetes pero no se podran usar sus modulos ni metodos, conviene por eso importar modulos
*Los paquetes o modulos importados deben tener la misma ruta base del arhicvo que estamos importando.
*Solo se mira por defecto para abajo.


forma 1:
--------------
import modulo					#En el caso de que el modulo este en la misma ruta, se importa directamente el modulo
import paquete.modulo				#En el caso de que el paquete este en la misma ruta, pero no el modulo. Asi importaremos ese modulo interno de ese paquete
import paquete.subpaquete.modulo		#Para el caso en que el modulo este dentro de otros subpaquetes, asi encontraremos el modulo para usar sus metodos (ojo que el paquete base
						 debe estar en la misma ruta del archivo al cual estamos importando)

import paquete.subpaquete.modulo as nombre	#para cambiarl nombre de esa ruta por la dada y asi usar mas facil dichos metodos de esa ruta.



forma 2:
---------------
*El modulo importado debe estar en la misma ruta del archivo al cual se importa
*El paquete debe estar en la misma ruta del archivo.
*El paquete del subpaquete debe tener la misma ruta base del archivo

from modulo import metodo					#de dicho modulo importamos dicho metodo
from modulo import *						#De dicho modulo importamos todos los metodos
from paquete.modulo import metodo				#Del modulo de dicho paquete importamos dicho metodo
from paquete.modulo import *					#Del modulo de dicho paquete importamos todos sus metodos
from paquete.subpaquete.modulo import metodo			#Del modulo del subpaquete del paquete importamos dicho método 
from paquete.subpaquete.modulo import *				#Del modulo del subpaquete del paquete importamos todos sus metodos
from paquete.subpaquete.modulo import metodo as name		#Del modulo del subpaquete del paquete importamos dicho metodo como name


from paquete import modulo					#De dicho paquete importamos dicho modulo
from paquete.subpaquete import modulo				#Del subpaquete del paquete importamos dicho modulo 
from paquete.subpaquete import modulo as name			#Del subpaquete del paquete importamos dicho módulo como name


forma 3:
--------------
*para trabajar directamente con el paquete, se agrega al archivo __init__.py lo siguiente:

from .namemodulo1 import *					#cuando trabajar con ese modulo y todos sus objetos




MANEJO DE ERRORES:
-------------------------
*Se deben manejar los errores para que nuestro programa no se caiga.
*Se utiliza estas palabras claves:
	-try: 
		codigo		#código que queremos intentar ejecutar
	-except: 
		codigo		#codigo que se ejecuta si ocurre un error al ejecutar try
	-else: 
		codigo		#codigo a ejecutar si no ocurre un error en try (sirve para aumentar información a try)
	-finally: 
		codigo		#codigo que se ejecuta de todos modos



*También se pueden capturar los errores con except


	try:
		codigo

	except ValueError:			#si al intentar ejecutar el código da un error tipo ValeError, mostrara el codigo que contiene
		codigo

	except TypeError:			#si al intentar ejecutar el código da un error tipo TypeError, mostrara el codigo que contiene.
		codigo


	except:					#esto no es necesario, pero si lo pones debe ir al ultimo ya que absorveria todas las excepciones posteriores.	
		codigo



def suma():
    n1=int(input('Ingrese un numero: '))
    n2=int(input('Ingrese otro numero: '))
    print(n1+n2)
    print('Gracias por sumar')


try:
    suma()

except ValueError:
    print('los datos no son numeros')


except TypeError:
    print('no se concatena')


else:
    print('Bien hecho')

finally:
    print('Nos vemos')


def sumar():
    while True:
        try:
            n1=int(input('Ingrese un numero: '))
            n2=int(input('Ingrese otro numero: '))


        except:
            print('Ingresa solo numeros')

        else:
            print(n1 + n2)
            print('Muy bien, hasta luego')
            break
        finally:						#el código se ejecutara aún asi haya un break
            print('dabai')
sumar()



BUSCANDO ERRORES CON PYLINT
--------------------------------------
*pylint es una biblioteca que analiza tu código en busca de algunos errores. puede por ejemplo buscar problemas de estilo o algún código no valido.
*este es un paquete que se debe instalar. (desde la terminal ->pip install pylint)
*este comando se usa desde la consola. >>>pylint nameArchivo.py -r y   (para eso debes estar en la misma ruta desde la terminal)

syntax:
----------
 >>>pylint nameArchivo.py -r y   (para eso debes estar en la misma ruta desde la terminal o consola)	

ejemplo:
-----------------
*Por lo general devuelve la información de la siguiente manera.


************* Module buscador de error con pylint
buscador de error con pylint.py:2:0: C0304: Final newline missing (missing-final-newline)				#Estos con C0304 hacaen referencia al estilo
buscador de error con pylint.py:1:0: C0114: Missing module docstring (missing-module-docstring)				#Estas lineas de aqui representan por asi decirlo el resumen.
buscador de error con pylint.py:1:0: C0103: Module name "buscador de error con pylint" doesn't conform to snake_case naming style (invalid-name)
buscador de error con pylint.py:1:0: C0103: Constant name "numero" doesn't conform to UPPER_CASE naming style (invalid-name)
buscador de error con pylint.py:2:6: E0602: Undefined variable 'Numero' (undefined-variable)				#Aqui se ve el error


Report
======
2 statements analysed.

Statistics by type
------------------

+---------+-------+-----------+-----------+------------+---------+
|type     |number |old number |difference |%documented |%badname |
+=========+=======+===========+===========+============+=========+
|module   |1      |NC         |NC         |0.00        |100.00   |
+---------+-------+-----------+-----------+------------+---------+
|class    |0      |NC         |NC         |0           |0        |
+---------+-------+-----------+-----------+------------+---------+
|method   |0      |NC         |NC         |0           |0        |
+---------+-------+-----------+-----------+------------+---------+
|function |0      |NC         |NC         |0           |0        |
+---------+-------+-----------+-----------+------------+---------+



4 lines have been analyzed

Raw metrics
-----------

+----------+-------+------+---------+-----------+
|type      |number |%     |previous |difference |
+==========+=======+======+=========+===========+
|code      |3      |75.00 |NC       |NC         |
+----------+-------+------+---------+-----------+
|docstring |0      |0.00  |NC       |NC         |
+----------+-------+------+---------+-----------+
|comment   |0      |0.00  |NC       |NC         |
+----------+-------+------+---------+-----------+
|empty     |1      |25.00 |NC       |NC         |
+----------+-------+------+---------+-----------+



Duplication
-----------

+-------------------------+------+---------+-----------+
|                         |now   |previous |difference |
+=========================+======+=========+===========+
|nb duplicated lines      |0     |NC       |NC         |
+-------------------------+------+---------+-----------+
|percent duplicated lines |0.000 |NC       |NC         |
+-------------------------+------+---------+-----------+



Messages by category
--------------------

+-----------+-------+---------+-----------+
|type       |number |previous |difference |
+===========+=======+=========+===========+
|convention |4      |NC       |NC         |
+-----------+-------+---------+-----------+
|refactor   |0      |NC       |NC         |
+-----------+-------+---------+-----------+
|warning    |0      |NC       |NC         |
+-----------+-------+---------+-----------+
|error      |1      |NC       |NC         |
+-----------+-------+---------+-----------+



Messages
--------

+-------------------------+------------+
|message id               |occurrences |
+=========================+============+
|invalid-name             |2           |
+-------------------------+------------+
|undefined-variable       |1           |
+-------------------------+------------+
|missing-module-docstring |1           |
+-------------------------+------------+
|missing-final-newline    |1           |
+-------------------------+------------+




-----------------------------------
Your code has been rated at 0.00/10					#Esta linea de aqui nos indica el puntaje en estructura que tiene nuestro codigo respecto a la convesión.
									#Es recomendable tener una puntuación de 7/10 , la 10/10 es mas que nada para maquina

BUSCANDO ERRORES CON UNITTEST
--------------------------------------
*es una biblioteca incorporada en python que te va permitir probar tu programa, y ver si esta te devuelve el resultado que estabas esperando. (no se centra en los errores de código sino en el resultado esperado)


#modulo1
def devoler_mayuscula(text):
	return text.upper()


#modulo2								#En este archivo probaremos el funcionamiento de los metodos del modulo1
import unittest								#importamos el modulo unittest
import modulo1								#importamos el archivo al que vamos a testear

class nameClase(unittest.TestCase):					#heredamos metodos de unittest.TestCase
	def test_name(self):						#el nombre de cualquier funcion que creemos debe empezar con 'test'
		palabra= 'buen dia'					
		resultado= modulo1.deolver_mayuscula(palabra)
		self.assertEqual(resultado, 'resultado esperado')		#aqui se compara el resultado con 'resultado esperado'
		#self.assertEqual(resultado,'resultado esperado, mensaje')	#en caso no se de el resultado esperado, podemos pasar un tercer parametro que muestre un mensaje.
		

if __name__ = "__main__"						#esto comprueba si el modulo es interno o exportado (para mas detalle leer la documentación)			
	unittest.main()					




---------------------------
|	DECORADORES:	  |
---------------------------
*Funciones que modifican el comportamiento de otras funciones.
*La función decoradora debe tener una sintaxis parecida, analiza y recuerda porque, si lo entendiste Dax.
*Como veremos en el siguiente ejemplo, podemos hacerlo de 2 maneras.
*En python todo es un objeto, por lo tanto podemos pasar funciones como argumentos por que como dije todo es un objeto en python hasta los string.

#PRIMERA FORMA DE DECORAR:
 
###Sin parametros
def decoradora(funcion):
    def interna_decoradora():
        print('Lo lavo')
        funcion()
        print('te devuelvo')


    return interna_decoradora


def suma():
    print(5+4)

decoradora(suma)


###Con parametros
def decoradora(funcion):
    def inter_decoradora(*args):
        print('===================')
        funcion(*args)
        print('===================')

    return inter_decoradora


def suma(a,b):
    print(a+b)


suma_decorada=decoradora(suma)
suma_decorada(5,4)'''


#SEGUNDA FORMA DE DECORAR
###Sin parametros
def decoradora(funcion):
    def interna_decora():
        print('==============')
        funcion()
        print('==============')

    return interna_decora

@decoradora					#@nameFuncion  ;@ indica que la funcion de abajo quedara envuelta con esta función, osea decorada, lo que hace esto es básicamente
def suma():					pasarle a la función decoradora esta función como objeto y luego dentro de la decoradora devolverla llamaba (osea aplicar parentesis)
    print(5+4)					hace esto en pocas palabras 'suma=decorado(suma)'

suma()

###con parametros
def decoradora(funcion):
    def interna_decora(*args):
        print('==============')
        funcion(*args)
        print('==============')

    return interna_decora

@decoradora					#@nameFuncion  ;@ indica que la funcion de abajo quedara envuelta con esta función, osea decorada
def suma(a,b):
    print(a+b)

suma(5,4)



*La ventaja de la primera forma es que no afecta a la función original, en cambio en la forma 2 la función original queda envuelta con su decorador





-----------------------------------------------
|		GENERADORES		      |
-----------------------------------------------
*se utilizan dos palabras claves 'yiel' y 'next()'. 
*Un generador va producion valores a medida que le solicitemos.
*La diferencia entre una función normal con return y contra un generador es que una vez el return se ejecute, la función se termina, en cambio con yiel podemos ir recibiendo valores a medida
que lo solicitemos y la función no se terminara.

EJEMPLOS:
--------------
#----------1
def namegenerador():				#esto es una función común y corriente
    x=1
    yield x					#el generador devuelve este valor con el primer next y se queda ahí hasta recibir el siguiente next
    x=2						
    yield x					#este es el valor que devolvera al segundo next
    x=3
    yield x					#tercer valor que devolvera al siguiente next que hagamos

a=namegenerador()				#creamos una variable que tendra a nuestra funcion generadora, se crea un objeto de tipo generador
print(a)					#si imprimimos veremos que es un objeto de tipo generador
print(next(a))					#imprime el valor del primer yiel que encontremos
print(next(a))					#imprime el valor del siguiente yield
print(next(a))					#y asi sucesivamente
print(next(a))					#en caso ya no haya mas yield en la función y nosotros sigamos pidiendo valores, nos devolvera un error por que ya no habrá valores que mostrar
				
						#en ruesumen, yield una vez pedido el valor, buscara el siguiente yield por mostrar, si no lo encuentra dara un error tipo 'StopIteration'.

#----------2
def mi_funcion():
    lista=[]
    for i in range(1,5):
        lista.append(i**2)

    return lista

def mi_generador():
    for i in range(1,5):
        yield i**2				#con next podemos ir pidiendo segun lo requerigamos los valores que se dan en este loop.
						Y no te preocupes por next(generador) siempre recuerda en yield que se quedo.

print(mi_funcion())
a=mi_generador()
print(next(a))
print(next(a))
print(next(a))
print(next(a))


---------------------------------------------------------------------------------------------------------------------------------
|								DIA 9								|
---------------------------------------------------------------------------------------------------------------------------------
*Los temas que se veran en este día:
	-Collections
	-Modulo OS y Shutil
	-Modulo Datetime
	-Modulos para medir el tiempo
	-Modulo Math
	-Modulo RE
	-Comprimir y descomprimir archivos


-----------------------------------------
|	 MODULO COLLECTIONS		|
-----------------------------------------
*es una biblioteca incorporada por defecto en python, por lo tanto solo necesitaremos importarla.
*veremos algunos metodos de collections los cuales son:
	-from collections import Counter
	-from collections
	-from collections


from collections import Counter

Counters(iterable)					#lo que hara es devolvera en un subDiccionario las repeticiones de cada elemento de este iterable. (en str sera cada carácter, en 								lista cada elemento, etc)

Ejemplo:
-----------
a=[1,4,2,5,2,3,4]
print(Counters(a))					#devuelve Counter({4:2 , 2:2, 5:1 , 3:1, 1:1})

a='hola'



from collections import defaultdict

a=defaultdict(lamba: 'nada')				#esto indica que cada vez que llamemos con una clave que no existe en el diccionario 'a', devolvera 'nada' y creara un elemento del 								diccionario cuya clave sera 'la clave que escribimos' y su valor sera 'nada'. En vez de votar un error.


from collections import namedtuple


b=nameTuple('indentificar',['valor1','valor2',etc])	#esto define el comportamiento de la tupla, 'indentificador es solo un nombre'
a=b(valo1,valo2,valo3)					#aqui creamos una tupla dando esos valores respectimos

a[0]							#devuelve valo1
a.valor1						#devuelve valo1, como vemos ahora tenemos 2 formas de llamar a los elementos de la tupla, por nombre o por indice.




from collections import deque

a=deque(iterable)					asi definimos una lista deque(el iterable puede ser lista, etc)
a.append(elemento)					añade elemento al final de lista
a.appendleft(elemento)					añade elemento al principio de la lista
a.extend(iterable)					añade la colección al final de la lista
a.extendleft(iterable)					añade al principio de la lista pero los elementos entran al reves
a.pop()							elimina el ultimo elemento de la lista
a.popleft()						elimina el primer elemento de la lista
a.rotate(valor)						corre a la derecha los elementos respecto al valor dado, si es negativo lo hace a la izquierda
a.reverse()						invierte el orden de la collecion
a.remove(elemento)					elimina al elemento dado, buscando de la izquierda a la dercha (solo la primera aparición)



	Metodos:
--------------------------------------
a=Counter(iterable)					#devuelve una subdicionario don los elementos unicos pasan a ser clave y la cantidad de repeticiones de estos su valor respectivamente
a.most_common()						#devuelve al Counter en pares de tuplas, de mayor a menos respectivamente
a.most_common(i)					#para i=1 devuelve solo el mayor numero de pariciones, para i=2 los dos mayores, así respectivamente.
list(a)							#recuerda que al caster un disccionario a lista o tupla, solo quedaran como elemento las claves del diccionario.


a=defaultdict(lamba: 'nada')				#esto indica que cada vez que llamemos con una clave que no existe en el diccionario 'a', devolvera 'nada' y creara un elemento del 								diccionario cuya clave sera 'la clave que escribimos' y su valor sera 'nada'. En vez de votar un error.

b=nameTuple('indentificar',['valor1','valor2',etc])	#esto define el comportamiento de la tupla, 'indentificador es solo un nombre'
a=b(valo1,valo2,valo3)					#aqui creamos una tupla dando esos valores respectimos

a[0]							#devuelve valo1
a.valor1						#devuelve valo1, como vemos ahora tenemos 2 formas de llamar a los elementos de la tupla, por nombre o por indice.












=================================================
|		MODULO OS y SHUTIL		|
=================================================
*Algunos metodos extras para estos modulos

MODULO OS
-------------
import os


os.getcwd()					#devuelve la ruta actual del archivo en el que estamos trabajando
os.listdir()					#devuelve una lista con todo los archivos que hay en este ruta(incluyendo carpetas). Estos elementos estaran ordenandos alfabeticamente
						ignorando mayusculas

os.unlink('path\archivo')			#elimina un archivo con la ruta dada
os.rmdir(path)					#elimina un directorio vacio de la ruta dada
shutil.rmtree(path)				#elimina un directorio con todo su contenido(archivos y directorios de forma irreversible)

os.walk(path)					#devuelve un objeto generador, donde sus elemenetos seran tuplas de 3: 
						(ruta/carpeta,[subcaperta1,subcarpeta2,...],[archivo1,archivo2,...])			
						*Si existen subcarpetas seguira generando tuplas donde esta vez la subcarpeta1 pasara a ser la ruta/carepta 				
						(subcarpeta1,[sub_subcarpeta1,sub_carpeta2,...],[archivo1,archivo2]) y así sucesivamente hasta recorrer todas las carpetas.


MODULO SHUTIL
----------------
import shutil

shutil.move('nameFile','path')			#mueve el archivo a la ruta dada(también mueve directorios por mas que tenga contenido, incluso puede moverse a si misma)


carpeta_origen='ruta/nameCarpeta'					#nameCarpeta es la carpeta que vamos a comprimir, sino indicamos la ruta por defecto toma la ruta en la que estamos
archivo_destino='ruta/nameArchivo'					#namArchivo es el archivo comprimido que va crear y almazar nameCarpeta
shutil.make_archive(archivo_destino,'zip',carpeta_origen)		#Aqui creamos el archivo con un formato zip para las rutas dadas
shutil.make_archive(ruta_destino,'formato','ruta_origen')


shutil.unpack_archive(namearchivo, newdir, formato)			#para descomprimir namearchivo y crear la carpeta newdir que contendra lo descomprimido
shutil.unpack_archive(ruta/namearchivo,ruta/newdir,formato)
shutil.unpack_archive('comprimido_mama.zip','mama','zip')		#aqui un ejemplo, como no dimos las rutas, usara la ruta en la que se encuentra por defecto.		


*Cuando eliminamos nada se envia a la papelera, para que si ocurra esto necesitamos instalar un paquete 'pip install send2trash'

import send2trash

send2trash.send2trash('path')		#Manda a la papelera archivos o carpetas(no importa que tengan contenido) de la ruta dada


=================================================
|		MODULO DATETIME			|
=================================================
*Para trabajar con este módulo debemos importarlo, import datetime.
*Este modulo nos permite:
	-almacenar hora y fecha en variables.
	-cálculos de tiempo.
	-mostrar en diferentes formatos.


*import datetime
hora=datetime.time(h,m,s,microse,info horaria)			#no es necesario escribir todos los atributos, h hace referencia la hora, m a los minutos, s a los segundos,etc.
hora.hour							#muestra la hora de dicha variable
hora.minute
hora.second
hora.microsecond


fecha=datetime.date(year,mounts,day)				#guardamos en una variable la fecha, el mes y el dia dados.
fecha.year							#de la fecha dada devuelve el año
fecha.month							#de la fecha dada devuelve el mes
fecha.day							#de la fecha dada devuelve el dia
fecha.today()							#devuelve la fecha actual, 
fecha.ctime()							#de la fecha dada la devuelve pero en otro formato.


*from datetime import datetime
fecha=datetime(year,month,day,hour,minute,second,microsecond,tzinfo)		#para establecer una fecha y su hora
fecha.replace(year=newvalor)							#sirve para cambiar cualquier atributo de la fecha data, si deseas minutos, en vez de year seria minute= 
										 (no se autoguarda)
fecha.today()									#Muestra la fecha actual con la hora actual
fecha.today().time()								#Muestra solo la hora de la fecha actual
fecha.today().date()								#Muestra solo la fecha de la fecha actual.
fecha.now()									#otra forma de obtener la fecha y la hora actual.

fecha.today().strftime(%d%m%y)							#%d hace refencia, %m al dia y %y al año de la fecha actual, podriamos modificar el orden, agregar guiones
										o lo que queramos para dar otro formato a la fecha.


strftime(format='nombreFormat')	
*Valores para 'nombreFormat':
	
%Y	Año, versión completa
%y	Año, versión abreviada (sin siglo)
%B	Mes, versión completa (idioma inglés)
%b	Mes, versión abreviada (idioma inglés)
%m	Mes, versión numérica
%d	Día del mes
%j	Día del año, 001-366
%A	Día de la semana, versión completa (idioma inglés)
%a	Día de la semana, versión abreviada (idioma inglés)
%w	Día de la semana, versión numérica (0 = Domingo, 1 = Lunes, ..., 6 = Sábado)
%W	Semana del año, con lunes como primer día
%U	Semana del año, con domingo como primer día
%H	Hora, 00-23
%I	Hora, 00-12
%p	AM / PM
%M	Minuto, 00-59
%S	Segundo, 00-59
%f	Microsegundo, 000000-999999
%Z	Zona horaria
%z	Offset de UTC
%c	Versión local de fecha y hora
%x	Versión local de fecha
%X	Versión local de hora
%%	Caracter %
%G	Año ISO 8601
%u	Día de la semana ISO 8601
%V	Semana del año ISO 8601


*Se puede hacer operaciones con fechas, pero estas deberian tener el mismo formato.
fecha=fecha_actual -  fecha_anterior								#Muestra la diferencia entre las fechas dadas, se muestran la cantidad total de dias y
print(fecha)											 y la diferencia de las horas
fecha.days											#Muestra solo la cantidad de dias
fecha.seconds											#Muestra solo de la cantidad de diferencia de horas en segundos.	




*Modulos time , nos sirve para medir el tiempo de demora de un proceso, no es muy útil para procesos pequeños.
import time

inicio=time.time()					#se le da un tiempo inicial antes de la ejecución del código.
código
final=time.time()					#se le da un tiempo final despues de la ejecución del código.
print(final-inicio)					#muestra cuanto tiempo demoro la ejecución del código



*Modulo timeit, este modulo nos permite evaluar el tiempo de duración de pequeños procesos.
import timeit.timeit(declaracion,setup,number=valor), el valor de number hace referencia a cuantas veces se va a ejecutar este proceso. la declaración es la función y el valor del parametro
y el setupo es la estructura de la función a evaluar. (No es necesario que las función existan, ya que timeit evalua respecto a su setup)


Ejemplos:
----------------------
import timeit

def prueba1(numbers):
    lista=[]
    for num in range(1,numbers+1):
        lista.append(num)
    return lista

def prueba2(numbers):
    lista=[]
    contador=1
    while contador<numbers+1:
        lista.append(contador)
        contador+=1
    return lista


declaracion1='''
prueba1(10)
'''
mi_setup1='''
def prueba1(numbers):
    lista=[]
    for num in range(1,numbers+1):
        lista.append(num)
    return lista
'''
duracion1=timeit.timeit(declaracion1,mi_setup1,number=10000000)



declaracion2='''
prueba2(10)
'''
mi_setup2='''
def prueba2(numbers):
    lista=[]
    contador=1
    while contador<numbers+1:
        lista.append(contador)
        contador+=1
    return lista
'''
duracion2=timeit.timeit(declaracion2,mi_setup2,number=10000000)

print(duracion1)
print(duracion2)




=================================================
|		MODULO MATH			|
=================================================
*El modulo math contiene un conjunto de métodos y constantes que se pueden utilizar para resolver tareas matemáticas de mayor complejidad. Es el equivalente a la calculadora cientifica dentro de python.
*Puedes investigar de los metodos y atributos de este modulo en los siguientes links:
-https://docs.python.org/es/3.11/library/math.html					#Para reales
-https://docs.python.org/es/3.11/library/cmath.html#module-cmath			#Para complejos

*Algunos otros modulos para trabahar con matematica son: (algunos modulos necesitan ser instalados)
	-numpy
	-matplotlib
	-sympy	
	-scikit-learn	
	-import cv2 (conocida como open cv)
	-animatplot
	-from mpl_toolkits.mplot3d import axes3d

	



=================================================
|		MODULO RE			|
=================================================
*re:regular expresions

Expresiones regulares:
----------------------
*Nos sirve para trabajar con textos.

ejemplos:
---------
variable=r''						#Con la r'' indicamos que trate a estre string como una expresión regular.
variable=r'\d'						#la \d significa digito
	variable=r'\d\d\d-\d\d'				#cualquier estring que comience con 3 digitos de carácteres luego un - y luego 2 digitos de carácteres.
	variable=r'\d{3}-\d{2]'				#Es lo mismo de lo que esta arriba.




CARACTERES ESPECIALES EN LA EXPRESIONES REGULARES:
--------------------------------------------------
caracteres especiales			descripción						ejemplo			ejemplo aplicativo
------------------------		------------						--------		-------------------
\d					digito númerico						v\d.\d\d 		v1.23
\w					carácter alfanumerérico					\w\w\w-\w\w		sol-25
\s					espacio en blanco					numero\s\d\d		numero 21
\D					no digito numerico					\D\D.\D			ab.3
\W					no alfanumerico						\W\W.\W			??.=			
\S					no espacio en blanco					\S\S\S			12A
\					poner \ para usar como caracter a estos 		\.			ho.1
					caracteres cuantificadores especiales		



caracteres cuantificadores		descripción						ejemplo			ejemplo aplicativo
---------------------------		------------						---------		-------------------
+					que el caracter se repite 1 o más veces			codigo_\d+		codigo_1,codigo_232,etc
{n}					que el caracter se repite 'n' veces			\d{3}			234, 123,etc
{n,m}					que el caracter se repite entre n a m veces		\w{3,5}			amig, sol, panad,etc
{n,}					que se repite n veces o mas				\w{2,}			ag, sol, mar4,etc
*					1 o mas veces o ninguna					\w\s*\w			1 3, a   b, ab,etc
?					1 vez o ninguna.					casas?			casa, casas



*Los carácteres cuantificadores aplican sobre cualquier carácter (sea especial o no)



cuantificadores especiales		descripción						ejemplo			ejemplo aplicativo
----------------------------		-------------						----------		--------------------
|					o busca esto o lo otro					r'text1|text2'		text1, text2
.					cualquier caracter o simbolo(en su posicion)		r'as.22'		as122, asa22			
^					que nuestra busqueda comience con lo buscado		r'^patron'		patron de la...
$					que haya la busqueda al final del string		r'patron$'		....patron
[ca]					el caracter indicado debe estar
[ca1ca2]				o bien el caracter1 o bien el caracter2			
[ca1-ca2]				entre el rango de estos caracteres ca1 a ca2
[ca1-ca2ca3-ca4]			entre ca1 a ca2 o ca3 a ca4			
[CA1-CA2]

[^]					un caracter que ignore el patron indicado		r'[^\s]'		a,2,-   	(no buscara espacio)
												r'[^\s]+'		asda,23a


*sea ca=caracter



re.search(patron,texto,re.IGNORECASE)				#el tercer parametro es para que ignore la mayuscula o minuscula de la busqueda.

variable=re.search(patron,texto)				#devuelve un objeto re en caso se encuentre la busqueda, en caso de no encontrarla devuelve None
variable.span()							#devuelve la ubicación de la palabra encontrada (el indice de inicio y del final en una tupla)
variable.start()						#devuelve una vez encontrada la palabra, la ubicación del primer carácter
variable.end()							#devuelve una vez encontrada la palabra, la ubicación del último carácter
variable.group()						#devuelve la palabra encontrada que cumpla con el formato indicado.

re.compile(patron,)						#cada patron dado en compile, podra ser llamado, simplemente dandole un valor desde 1 en group.
patron=re.compile(r'(patron1)(patron2)..etc')			#al poner parentesis agrupa los patrones, aunque no afecta a la busqueda, sirvea la hora querer mostrar dicha busqueda
variable=re.search(patron,texto)				#busca el patron creado con re.compile en el texto
variable.group(i)						#i empieza desde el valor 1, si i=1, entonces muestra el primer parentesis, i=2 muestra el segundo, etc.


variable=re.findall(patron,texto)				#devuelve una lista con las apariciones de patron


variable=re.finditer(patron,texto)				#devuelve un objeto que se puede iterar, el cual va contener muchos re.search de la palabra buscada
for hallago in variable:
	print(hallazgo.span())					#devolvera la ubicación de los indices de cada vez que encuentre la palabra.




ejemplos:
-------------
import re
def verificar_email(email):
    patron=re.compile(r'(@\w+\.com)(\.[a-zA-Z]{2})?$')
    busqueda=re.search(patron,email)
    return "Ok" if busqueda is not None else "La dirección de email es incorrecta"

email='asdf@hot.com'
print(verificar_email(email))





=========================================================================
|		COMPRIMIR Y DESCOMPRIMIR ARCHIVOS			|
=========================================================================
import zipfile

variable= zipfile.ZipFile('nameZip.zip','w')				#abre el zip en modo escritura, sino existe lo crea (algo como lo hacia open)
	= zipfile.ZipFile('ruta/nameZip.zip','w')			#podriamos crear el zip en otra ruta
variable.write('namearchivo')						#el archivo mencionado lo comprime al zip
variable.write('namearchivo2')						#como se puede ver, se puede seguir comprimiendo mas archivos
variable.write('ruta/namearchivo3')					#podriamos tambien dar una ruta y elegir un archivo de esa ruta
variable.close()							#cerramos el zip

 
variable= zipfile.ZipFile('nameZip.zip','r')				#abrimos el zip en modo lectura con 'r'
	= zipfile.ZipFile('ruta/nameZip.zip','r')			#o podemos indicar la ruta del zip a leer
variable.extractall()							#extrae todos los ficheros y archivos del zip mencionado a la ruta en la que te encuentras(por defecto)
variable.extractall(ruta)						#o podemos indicar una ruta
variable.close()							#cerramos el zip






---------------------------------------------------------------------------------------------------------------------------------
|								DIA 10								|
---------------------------------------------------------------------------------------------------------------------------------

-------------------------
|	PYGAME:		|
-------------------------
*pygame es un paquete externo, por lo cual debemos instalarlo con pip "pip install pygame"
*Cada cosa que suceda en la pantalla de pygame es un evento.


CREAR PANTALLA:
------------------
import pygame								#importamos el modulo pygame
pygame.init()								#iniciamos pygame para que se carguen todos sus funciones, modulos, etc
pantalla=pygame.display.set_mode((700,700))				#mostramos la pantalla con una resolucion de (700,700) (ancho, alto)

running=True								#este valor nos permitira cerrar el bucle
while running:								#el bucle se ejecuta infinitamente hasta que running sea falso
	for evento in pygame.event.get():				#para que evento que se dee lo guardamos en evento
		if evento.type == pygame.QUIT:				#si el tipo de evento es pygame.QUIT (esto se da al presionar la 'x' en la esquina)
			running=False					#cambiara el valor running




CAMBIAR TITULO, ICONO Y FONDO DE PANTALLA
------------------------------------------

import pygame
#iniciamos pygame
pygame.init()

#mostrar pantalla
pantalla=pygame.display.set_mode((800,800))

#titulo, icono y fondo de pnatalla
pygame.display.set_caption('Invasion Espacial')				#sirve para poner un titulo a la pantalla pygame, en esta caso puse 'invasion espacial'
icono=pygame.image.load('ovni.png')					#cargamos una imagen a la variable
pygame.display.set_icon(icono)						#cargamos la imagen guardada a la pantalla como favicon.


#Loop del juego
running=True
while running:
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            running=False

    pantalla.fill((205,145,228))					#aqui damos el color de fondo a la pantalla mediante el formato RGB en una tupla
    pygame.display.update()						#es necesario cargar los cambios a la pantalla

pygame.quit()




AGREGAR EL PROTAGONISTA:
-------------------------

import pygame
pygame.init()

#pantalla
pantalla=pygame.display.set_mode((800,800))

#titulo y icono
icono=pygame.image.load('ovni.png')
pygame.display.set_caption('Invasion Extraterrestre')
pygame.display.set_icon(icono)

#personaje
imagen_personaje=pygame.image.load('cohete.png')			#cargamos la imagen del personaje en una variable
x_lugar=400-32								#posicion de la imagen en el eje x
y_lugar=790-64								#posicion de la imagen en el eje y
									La posicion (0,0) hace referencia a la posicion de la esquina supeior de la izquierda.
					
def personaje():							#creamos una funcion que se encargara de ubicar al personaje en la pantalla
    pantalla.blit(imagen_personaje,(x_lugar,y_lugar))			#.blit arroja la imagen que le demos a la pantalla en la posicion que le demos


#loop del juego
running=True
while running:
    pantalla.fill((205,144,228))					#pintamos la pantalla
    personaje()								#es importante cargar imagenes despues del pintado de la pantalla, por que sino lo tapara.

    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            running=False


    pygame.display.update()

pygame.quit()



MOVER AL PERSONAJE:
---------------------
def personaje(X,Y):							
    pantalla.blit(imagen_personaje,(x,y))

 
personaje(x_lugar,y_lugar)
x_lugar+=0.1								#como la funcion se invoco dentro de un loop, la imagen del personaje se ira desplazando 0.1 en el eje x



CONTROLAR MOVIMIENTO:
------------------------
*recuerda que en 'for evento in pygame.event.get()'			#evento va capturando todo lo que va sucediendo en la pantalla de pygame.

if evento.type == pygame.KEYDOWN:					#si el tipo de evento es igual a una tecla presionada (keydown hace referencia a una tecla presionada)
    if evento.key == pygame.K_LEFT:					#si la clave del evento es tipo K_LEFT(esto hace referencia a la tecla 'flecha izquieda')
        mov_x=-0.1
    if evento.key == pygame.K_RIGHT:					#si la clave del evento es tipo K_RIGHT(esto hace referencia a la tecla 'flecha derecha')
        mov_x=0.1
    if evento.key == pygame.K_UP:					#si la clave del evento es tipo K_UP(esto hace referencia a la tecla 'flecha arriba')
        mov_y = -0.1
    if evento.key == pygame.K_DOWN:					#si la clave del evento es tipo K_DOWN(esto hace referencia a la tecla 'flecha abajo')
        mov_y = 0.1
if evento.type == pygame.KEYUP:							#pygame.KEYUP hace referencia a cuando deje de presionar la tecla, al levantar el dedo.
    if evento.key == pygame.K_LEFT or evento.key == pygame.K_RIGHT:		#si la clave de la tecla presionada fue igual a K_LEFT o K_RIGHT
        mov_x=0
    if evento.key == pygame.K_DOWN or evento.key == pygame.K_UP:		#si la clave de la tecla presionada fue igual a K_DOWN o K_UP
        mov_y=0




LIMITADOR DEL MOVIMIENTO:
---------------------------
*definimos metodos simplemente en caso la posicion pase los bordes, por ejemplo los siguientes metodos.

#limita el movimiento del personaje
#para X
if pos_x <= 0:
pos_x=0
elif pos_x>=736:
pos_x=736

#para Y
if pos_y <= 0:
pos_y=0



CREAR ENEMIGOS:
-------------------
#crear enemigo
imagen_enemigo=pygame.image.load('enemigo.png')					#cargamos la imagen del enemigo en la variable
def enemigo(x,y):								#creamos una funcion encarga de posicionar al enemigo
    pantalla.blit(imagen_enemigo,(x,y))						#dibuja la imagen del enemigo en la pantalla de pygame

#variables del enemigo			
enemigo_x=random.randint(0,736)							#elejimos una posicion aleatoria para nuestro enemigo en el eje x
enemigo_y=random.randint(50,200)						#elejimos una posicion aleatoria para nuestro enemigo en el eje y







---------------------------------------------------------------------------------------------------------------------------------
|							COMENTARIOS								|
---------------------------------------------------------------------------------------------------------------------------------
*Este curso lo estoy realizando teniendo ya buena experiencia en Pyton, debido a eso no sean tomado a cuenta todos los apuntes.
*Tener cuidado al nombrar archivos python, ya que al momento de importar modulos, puede que se confunda.
*python tiene una convención de estilos conocida como 'PEP-8'
*En python todo es un objeto. incluso los int, float, str, funciones, etc.... todo.
*Recuerda que en python por convención el nombre de las funciones comienza con minusculas y el de las clases con masyusculas.
*EN GENERADORES. tu puedes crear un objeto generador y puedes interar en esta, cada elemento del loop for para el objeto generador devolvera un valor como si lo estuvieras llamando con next.
*en Pycharm a veces por el interprete y la instalación de paquetes ocurre un error, eso no significa que cuando tu corras tu archivo python vaya haber un error.



*C:\Users\Usuario\AppData\Local\Programs\Python\Python311\Lib 			->esta es la carpeta donde estan las librerias base con la que esta trabajando pycharm
*C:\Users\Usuario\AppData\Local\Programs\Python\Python311\Lib\site-packages	->esta es la carpeta donde se guardan los paquetes instalados por el pip




	Modulos vistos:
----------------------------
import io
import pathlib
import random
import os	




















