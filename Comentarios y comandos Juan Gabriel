-------------------------------------------------------------------------------------------------------------------------------------------------
							Herramientas de Google Colab								|
-------------------------------------------------------------------------------------------------------------------------------------------------
*los espacios en blanco son importantes en esta herramienta
---
#			Titulo
##			Titulo mas pequeño
###			Titulo mas pequeño, y así continua

**texto**		texto en negrita
*texto*			texto en cursiva

- elemento		elemento de una lista (no numerada)
- elemento		elemento de una lista (no numerada)

1. Elemento numerado						Elemento de una lista(numerada)
								es importante dejar espacios
	1.1 Sub elemento de la lista numerada			Sub elemento de una lista(numerada)
2. Elemento numerado						Elemento de una lista(numerada)
	1.2 Sub elemento de la lista numero			Sub elemento de una lista(numerada)

parrafo								este parrafo ya no pertenecera a las listas

[texto enlace](ruta del enlace)				Nos saldra un "texto enlace" y si damos clic ahí nos llevara al enlace 
				
![texto imagen](ruta de la imagen)			Similar pero para una imagen

$texto$					Que lo haga en la misma linea
$$texto$$				Que lo haga en la siguiente linea

-----------------------------------------------------------------------------------------------------------------------------------------
							Python										|
-----------------------------------------------------------------------------------------------------------------------------------------
Empezando Python:
-----------------

4 formas de definir una variable:
camelCase: 	nombreVariable
PascalCase: 	NombreVariable
Snake_Case: 	nombre_variable
kebab-Cae:  	nombre-variable


import keyword				--> Esta libreria contiene una lista de las palabras claves reservadas en Python
keyword.kwlist				--> con esto llamamos a la lista de palabras claves

['False',
 'None',
 'True',
 'and',
 'as',					-->nos permite poner un alias
 'assert',
 'async',
 'await',
 'break',
 'class',
 'continue',
 'def',
 'del',
 'elif',
 'else',
 'except',
 'finally',
 'for',
 'from',				
 'global',
 'if',
 'import',
 'in',
 'is',
 'lambda',
 'nonlocal',
 'not',
 'or',
 'pass',
 'raise',
 'return',
 'try',
 'while',
 'with',
 'yield']			-->Son algúnas de las palabras claves reserbadas

ejemplo para llamar a librerias y sus metodos:
----------------------------------------------	

import math as mt			-->con esto importamos el modulo math pero le cambiamos el nombre a mt, ahora trabajariamos algo así (mt.sqrt)
from math import sqrt			-->Con esto solo importamos el metodo sqrt, esto nos ayuda a ahorrar espacio en la memoria RAM
from math import sqrt as sq		-->Con esto importamos solo el metodo sqrt pero a la vez le cambiamos el nombre a sq
from math import pi, log, ex, etc	-->Nos permite importas los metodos pi, log, ex, etc del modulo math 
from math import *			-->trabajamos directamente con el metodo perteneciente a math, ya no es necesario nombrar al modulo
					   (No es recomendado ya que puede que haya metodos que se llamen igual y estos pertenezcas a difentes modulos
					    , cuando ocurra eso python no sabra con que trabajar)




declaración de multiples variables en una sola linea:
-----------------------------------------------------
n1,n2,n3...=valor1,valor2,valor3...		para cada variable debera haber un valor



---------------------------------------------------------------------------------------------------------------------------------
						sección 4: Números en pythom:							|
---------------------------------------------------------------------------------------------------------------------------------


3.0= 3. =3
*casting es hacer la transformación de un tipo de dato, ejemplo int(7.0) --> transformamos de flotante a entero
*en Python si hacemos una operación matematica entre un numero flotante y un entero, el resultado sera un número flotante
// 			para obtener una divisipón entera
%			para obtener el residuo
**			para obtener potencia
pow(base,exponente)	para obtener potencia

orden de las operacion aritmeticas: 
	-Primero se calcula lo que haya dentro de parentesis
	-a continuación, las potencias
	-Despues, productos y divisiones. En caso de haber varias, el orden que se sigue es de izquierda a derecha.
	-Finalmente, suma y resta. EN caso de haber varias el orden que se sigue es de izquierda a derecha.



números complejos:
------------------

es un par ordenado (a,b) donde el primer valor corresponde a la parte real y el segundo valor representa a la parte imaginaria
mod(z)=sqrt(a**2+b**)
Arg(z)=arctan(Im(z)/Re(z))=arctan(b/a)

representación binomica a+bi
representación polar: z=r*e**iϕ  --> donde z=numero complejo, r= modulo(z), e= número exponencial, ϕ=argumento(z),i=sqrt(-1) 

Sintaxis:
---------
para definir un número complejo en python solo hacemos lo siguiente:

forma1:
a=(valorentero)+(valorimaginario)j	-->utilizamos la j en vez de la i, la j lo usan los ingenieros, la j siempre debe ir despues del valor
	ejemplo: a=5+3j

forma2:
a=complex(valorEntero,valorImaginario)
	ejemplo: a=complex(5,3)


siendo 'z' un número complejo: z=a+bj
- - - - - - - - - - - - - - - - - - - 

z.real= el valor de la parte real lo obtenemos así
z.imag= el valor de la parte imaginaria lo obtenemos así
z.conjugate()= obtendremos el conjugado, a-bj
abs(z) = nos servira para obtener el modulo del número complejo

*si nos sale este valor 1.2246467991473532e-16 ==0, este error solo suceder cuando el argumentos es pi/2,etc. ocurre al momento de querer pasar del modo polar al modo binomica

=========================================================================================================================
			para trabajar con los argumentos importaremos la libreria 'cmath'|				|
=========================================================================================================================

cmath.phase(z)				-->nos devolvera el argumento(su angulo en radianes) del número complejo z
cmath.polar(z)				-->nos devolvera la forma polar del numero complejos, es decir una tupla con (moduloValordeZ,argumentoValordeZ)

cmath.rect(abs(z),cmath.phase(z))	-->nos devolvera el número complejo en forma binomica		
cmath.rect(cmath.polar(z))		-->Nos devolvera el número complejo en forma binomica

metodos de los complejos:
=========================

a=(valorentero)+(valorimaginario)j	-->Forma 1 de definir un número complejo , esta es la representación binomica.
a=complex(valorEntero,valorImaginario)	-->Forma 2 de definir un número complejo

z.real= el valor de la parte real lo obtenemos así
z.imag= el valor de la parte imaginaria lo obtenemos así
z.conjugate()= obtendremos el conjugado, a-bj
abs(z) = nos servira para obtener el modulo del número complejo



*si nos sale este valor 1.2246467991473532e-16 ==0, este error solo suceder cuando el argumentos es pi/2,etc. ocurre al momento de querer pasar del modo polar al modo binomica

-------------------------------------------------------------------------------------------------------------------------------------------------
							Sección 5: Strings en Python:								|
-------------------------------------------------------------------------------------------------------------------------------------------------

*Python no trabaja bien con los acentos así que mejor tratar de evitarlos


stirng literals:
- - -- - - - - -
\\Blackslash ,\			-> Un backslash es un letra escapante para algúnos carácteres, permite usar ciertos carácteres especiales
\' comilla simple ,'		-> Nos permitira usar comillas simples
\" Comilla doble ,"		-> Nos permitira usar comillas dobles
\n salto de linea		
\t tabulación horizontal



repetición de string:
- - - - - - - - - - -
string * n			-> Repetira el string 'n' veces y lo concatenera



función print():
- - - - - - - - -
*Sirve para mostrar en pantalla los string

función str():
- - - - - - - -
*Str sirve para concatenar variables de cualquier tipo, por que convierte otro tipo de dato a tipo string


metodo .format():
-----------------
"texto1{}texto2{}texto3...".format(variable1,variable2...)		-->dentro de cada {} ubicara el valor de las variables respectivamente


Substrings:
-----------
*Podemos acceder a cualquier carácter del string usando [i] despues de la variable, si i es positivo empieza a contar de izquierda a derecha, si i es negativo empieza a contar desde el final


---------------------------------------------------------------------------------------------------------------------------------------------------
						SECCIÓN 6: Tema4 - Operadores de desición					 		  |
---------------------------------------------------------------------------------------------------------------------------------------------------

operadores lógicos: (True, False)
-------------------
not		-> Cambia el valor de un booleano hacia lo contrario
and		-> conjunción
False		-> disyunción


operadores de comparación:
--------------------------
*Sirven para obtener valores booleanos

>	mayor que
<	menos que
>=	mayor igual que
<=	menor igual que
==	igual que
!=	diferente que


comparación de strings:
-----------------------
texto1<texto2				-->Comparara los primeros carácteres de cada texto y sera mayor según su código ACSII,A=65 y a=97
					   Si los primeros terminos son iguales, pasara al siguiente carácter, etc.

metodos strings:
----------------
*Los carácteres alfanúmericos son aquellos que pertenecen de la A-Z (o en minuscula) y los números

variable.startswith("texto1")		-->Nos devolvera un valor boleano dependiendo de que si es verdad que la variable comienza con "texto1" 
variable.endswith("texto1")		-->Nos devolvera un valor boleano dependiendo de que si es verdad que la variable finaliza con "texto1"

variable.isalnum()			-->Nos devolvera un valor boleano dependiendo si todos los carácteres de variable son alfanúmericos
					   (Tener cuídado con los espacios en blanco ya que no son alfanúmericos)
variable.isalpha()			-->Nos devolvera un valor boleano dependiendo si todos los carácteres son del alfabeto
variable.isdigit()			-->Nos devolvera un valor boleano dependiendo si todos los carácteres son números.
variable.isspace()			-->Nos devolvera un valor boleano dependiendo si todos los carácteres son espacios en blanco.
variable.islower()			-->Si todos los carácteres son minusculas nos devolvera True, caso contrario False
variable.isupper()			-->Nos devolvera True o False dependiendo si todos los carácteres de variable con Mayuscula
variable.istitle()			-->Nos devolvera True o False dependiendo si todas las letras comienzan con Mayuscula y el resto minuscula


operadores de desición:
-----------------------
*Es recomendado usar 4 espación en blanco(o tabular) en la identación despues de los 2 puntos.
*if - else - elif

sintaxis:
---------
if condición:
	operación
elif condición2:
	operación
else:
	operación

if "texto" in variable:			--->verificara si texto pertenece a variable, si es cierto devolvera True y False si no es cierto.



operador ternario:
------------------
*Si queremos hacer un simple if/else en una sola línea de código, podemos utilizar el operador ternario, que tiene la siguiente estructura 

Sintaxis:
---------

consecuencia_cierta   if   condición    else   consecuencia_falsa 	--> si cumple la condición se ejecutara la consecuencia_cierta, sino la otra.

variable= operar_cierto if condición else operar_falsa	-->variable tomara el valor dependiendo si cumple la condición o no
 

ejemplos:
- - - - -
age=20
texto_mayor="Eres mayo de edad en España"
texto_menor="Eres menor de edad en España"

print(texto_mayor) if age>=18 else print(texto_menor)


ejemplo2:
- - - - -

n=int("Digite un número: ")

message= "numero es par" if n%2==0 else "numero es impar"
print(message)



-------------------------------------------------------------------------------------------------------------------------------------------------
						SECCIÓN 7: Tema - Operadores de iteración							|
-------------------------------------------------------------------------------------------------------------------------------------------------

bucle while:
------------

while condición verdadera:		-->Mientras cumpla se condición se seguira ejecutando
	instruccion 1
	instruccion 2
	instruccion 3
	.
	.
	.
	instruccion n
		
	break				-->Salir del proceso llevado a cabo




bucle while - else:
-------------------
*Cuando el while no se cumpla se ejecutara el else, tiene casi la misma funcionalidad que if-else
ord("caracter")				-->Recibe de parametro un carácter y devolvera su valor entero en ASCII
chr(valor)				-->Recibe de parametro un valor entero y devolvera su carácter correspondiente en ASCII


ejercicio:
- - -- - -

n = int(input("Introduce una rotación: "))
i = 65

while i <= 90:
  if i + n <= 90:
    print(chr(i) + ": " + chr(i + n))
  else:
    print(chr(i) + ": " + chr((i - 26) + n))
  i += 1


-----------------
bucle FOR	|
-----------------
range(x,y,z)			-->start(x): que comienza desde x, stop(y): que se detiene en y(y no se incluye), step(z): de cuanto en cuanto avanza
for _ in variable:		--> en caso de no usar el iterador, nos conviene usar guion bajo que hara de iterador pero nos guardamos el valor



ejemplos:
- - - - -
range(5)		--> que el rango sera entre 0 al 5


a=[]
a=[i for i in range(5)]		-->Creara una lista con 5 elementos, del 0 al 5.
				   (esta forma de usar el for lo podemos aplicar a listas,tuplas,diccionarios,etc. recordad que tiene que ser iterable)

Para interrumpir la iteración:
------------------------------
break		-->para cerrar el bucle
continue	-->interrumpe la iteración actual para iniciar la siguiente




-------------------------------------------------------------------------------------------------------------------------------------------------
					    SECCIÓN 8: Tema 6 - Estructuras de datos: Listas							|
-------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------
	Listas:		|	
-------------------------
*En otros lenguajes de programación son conocidos también como Arrays, pero en Python Array es otra cosa.
*Los elementos de una lista empiezan desde el indice 0, si utilizas i<0 empezara desde el final
*!Cuidado¡ Si dada una lista llamamos a un elemento cuyo indice no existe, python automaticamente nos devolvera un error

*las listas:
	-heterogeneas: Los elementos pueden ser de distinto tipo en una lista
	-mutables: Los elementos pueden ser modificados


len(Listaname)		--> Para saber la longitud o tamaño de una lista
		
listaname[i]		-->imprimira el elemento de indice i
listaname[i:y]		-->imprimira los elementos desde el indice i hasta el indice y (sin contar este ultimo)
listaname		-->imprimira todos los elementos de la lista.

listaname.append("texto")	-->añade 'texto' como elemento a la lista, los elementos añadidos se incluyen al final	
listaname.insert(i,"texto")	-->añade 'texto' como elemento a la lista en el indice i, los elementos posteriores se corren un indice a la derecha.
				   si el indice en el que queremos insertar es> que el indice de la lista, insertara como si fuese un append()

listaName=[]			-->listaName sera una lista vacia		

bucles con listas:
------------------
for i in namelista:			--> La 'i' es i de item, i ira tomando el valor de cada elemento de lista.
for i in range(len(namelista))		--> La 'i' es i de posición


concatenación de listas:
------------------------
listaname1 + listaname2			--> concatenaremos ambas listas como si fueran string


repetición de listas:
---------------------
listaname*x				-->al igual que string, la lista se concatenara a si misma x veces

ejemplos:
- - - - -

queremos una lista de longitud 10
listaName=[0]*10 	#ListaName=[""]*10, a lo que tu quieras, pero la cosa es que la lista tendra longitud 10



-----------------------------------------------------------------
			listas anidadas				:
-----------------------------------------------------------------
*Las listas anidadas son listas dentro de listas. Es decir, las listas también pueden contener a otras listas.
*Son muy utilces para matrices

listaname[][]		-->en el caso de querer llamar a un valor de la lista que tenga una lista anidada
listaname[][][]		--> lo mismo que arriba
listaname[][][]...[]	-->para acceder a los valores dentro de las listas anidadas

ejemplos:
- - - - -

lista_ani=[["Vale","y","Dax"],[[1,2,3,4,5],["a","b","c","d","e"],[True,False,5,"Dax","Queso"]],5]

print("{}\n".format(lista_ani))
print(lista_ani[0][0])
print(lista_ani[0][2])
print(lista_ani[1][1][1])

*otra forma para visualizar mejor los elementos de listas anidadas:
*Como vemos abajo, cada elemento de la lista principal esta en una linea

lista_ani=[["Vale","y","Dax"],
	   [[1,2,3,4,5],["a","b","c","d","e"],[True,False,5,"Dax","Queso"]],
           5]



Metodos de listas:
------------------
namelista.count("elemento")		-->Recibe como parametro un elemento y cuenta la cantidad de veces que aparece en la lista.
namelista.extend("lista")		-->Recibe como parametro un texto,lista,etc. y lo concatena a dicha misma desde el final. 	
namelista.append("lista")		-->Recibe como parametro un texto,lista,etc. y lo concatena al final todo como un elemento a la lista.
					   los elementos del parametro pasan a ser elementos de la lista.
namelista.extend(range(9,16))		-->Range devuelve iterables, por lo tanto pueden ser iterados a la lista como elementos uno por uno.

namelista.index(elemento)		-->Recibe como argumento un elemento y devuelve el índice de la primera aparición en la lista.
namelista.pop()				-->Devuelve el ultimo elemento de la lista y lo borra de la misma.
namelista.remove(elemento)		-->Recibe como parametro un elemento y borra su primera aparición en la lista. (se autoguarda)
namelista.reverse()			-->devuelve la lista en orden inverso sobreescribiendola.	
namelista.sort()			-->Ordena la lista en forma creciente (respecto al valor en codigo ascii), tiene que ser del mismo tipo 				           (string con string,int con int, etc) (y lo autoguarda en la variable namelista	)

namelista.sort(reverse=True)		-->Ordena la lista en forma decreciente.

list(objeto iterable)			-->Convierte un objeto iterable a tipo lista, como puede ser un range(), un string, una tupla, colecciones,etc.
variable.join(nameLista)		-->Hace lo contrario a list(variable). funciona así. Al terminar cada elemento de la lista añade los carácteres
					   de variable. (convierte a string una lista)




Ejemplos:
- - - - -
*Este ejemplo sirve para contar cuantas veces se repite un elemento dentro de la lista.

numbers=[0,1,1,2,2,2,3,3,3,3]
counted=[]
for elemento in numbers:
    if elemento not in counted:				-->Si el elemento no esta dentro de counted (devuelve un valor booleano)
        counted.append(elemento)			-->Lo agrega para ya no tomarlo en cuenta, porque ya lo va contar
        print("El elemento {} aparece {} veces".format(elemento,numbers.count(elemento)))


ejemplo2:
list(range(0,100,10))	-->creara una lista con elementos que van desde el 0 al 90


-------------------------------------------------------------------------
				Matrices				|
-------------------------------------------------------------------------
*Son un tipo muy especial de listas anidadas.
*Se trata de una lista, formada por n listas
*En python una matriz se guarda como una lista con elemento lista.
*lista[i][j]		-->La 'i' indica la posición de la fila, y la 'j' indica la posición de la columna.


ejemplo1:
- - - - -
	
#Sea 'matrix' nuestra lista matriz ya definida
#m numero de fila y 3 n numero columna
m=len(matrix)
n=len(matrix[0])

for i in range(m):
	for j in range(n):
		print(j,end=" ")
	print("")

EJemplo2:
- - - - -

matrix=[[1,2,3],[4,5,6],[7,8,9]]

#Accediendo a la matriz por posición
m=len(matrix)
n=len(matrix[0])

for i in range(m):
	for j in range(n):
		print(matrix[i][j],end=" ")
	print("")

print("\n")
 
 #Accediendo a la matriz por elemento

for row in matrix:
	for elemento in row:
		print(elemento,end=" ")
	print("")


-----------------------------------------------------------
		operaciones con matricez	          :
-----------------------------------------------------------
Suma de matricez:
-----------------
*Para poder sumar matrices, necesitamos que tengan las mismas dimensiones. Encontes dadas matrices A y B de dimensiones mxn, la matriz suma también tendra dimensiones mxn

ejemplo:
-  -  -
A=[[1,0,-3],[2,0,1],[-1,-1,0]]
B=[[-1,-2,0],[-2,3,0],[0,0,-3]]

C=[]
for i in range(len(A)):
    C.append([])
    for j in range(len(A[0])):
        C[i].append(A[i][j]+B[i][j])       
        
print(C)    




Producto de matrices:
---------------------
*Para poder multiplicar matrices, necesitamos que la matriz izquierda tenga el mismo número de columnas que número de filas de la matriz derecha
Entonces A y B sean de dimensiones mxn y nxp respectivamente, su producto sera una matriz de dimensiones mxp
	AxB=Sumatoria de (aij)x(bji)

ejemplo1:
- - - - - 

#PRODUCTO DE MATRICES

A=[[1,0,-3],[2,0,1]]
B=[[-1,-2,3,7,5],[-2,0,5,9,2],[0,-3,4,0,1]]

for row in A:
    print(row)

print("---------------")

for row in B:
    print(row)

m=len(A)
n=len(B[0])
p=len(B)
C=[]

print("-----------------")
for i in range(m):                   #Para la fila
    C.append([])
    for j in range(n):               #Para las columna
        suma=0
        for k in range(p):           #Para cada elemento de la columna
            suma=suma+A[i][k]*B[k][j]
        C[i].append(suma)

print(C)

ejemplo2:
- - - - -

#Vamos a crear una matriz manualmente 4x4 y guardarla en una lista

lista=[]

for i in range(4):
    lista.append([])
    for j in range(4):
        lista[i].append(float(input("Introduce el elemento ({},{}): ".format(i,j))))

for row in lista:
    for elemento in row:
        print(lista[i][j],end="  " if lista[i][j]>=0 else " ")

    print("")



=================================================
	Matrices con numpy:		       ||
=================================================
*numpy	('num' de numero y 'py' de python)
*type() El tipo de dato es numpy.ndarray

import numpy as np	-->Importamos numpy para trabajar con ella y le ponemos un alisas 'np' 

============================================
	metodos de numpy para listas:	   | 
============================================
nameMatriz=numpy.empty((m,n))			-->Para crear una matriz vacia con 'm' filas y 'n' columas
nameMatriz2=numpy.empty_like(nameMatriz)	-->Creara una matriz con las dimensiones de 'nameMatriz'

nameMatriz=numpy.zeros((m,n))			-->Creara una matriz nula(todos los elementos valen 0), de m filas y n columnas
nameMatriz2=numpy.zeros(nameMatriz)		-->Creara una matriz nula con las mismas dimensiones de 'nameMatriz'

nameMatriz=numpy.ones((m,n))			-->Crea una matriz de orden mxn cuyos elementos todos valen 1
nameMatriz2=numpy.ones_like(nameMatriz)		-->Crea una matriz del mismo orden que 'nameMatriz' y cuyos elementos valdran 1

nameMatriz=numpy.matrix(lista)			-->Creara una matriz con los elementos de lista

nameMatriz.shape				-->Para saber el tamaño de la matriz devolvera una tupla (m,n): m is filas y n is columnas



operación con matrices utilizando numpy:
----------------------------------------

---------------------------
	sumar matrices	  :
---------------------------
*con numpy solo necesitamos usar '+' para sumar 2 matrices -->(A+B)



ejemplo: 
--------
import numpy

A=numpy.matrix([[2,3,1],[4,-1,-3],[0,2,0]])
B=numpy.natrix([[-2,-1,-1],[-3,1,2],[1,2,3]])

C=A+B

print(C)

'''
[[ 0  2  0]
 [ 1  0 -1]
 [ 1  4  3]]
'''



---------------------------------
	Producto de matrices	:
---------------------------------
*con numpy solo necesitamos usar el metodo .dot() 	-->(A.dot(B))


Ejemplo:
--------
import numpy

A=numpy.matrix([[2,3,1],[4,-1,-3],[0,2,0]])
B=numpy.matrix([[-2,-1,-1],[-3,1,2],[1,2,3]])
C=A.dot(B)
print(C)
 



-------------------------------------------------------------------------------------------------------------------------------------------------
					  SECCIÓN 9: Tema 7 - Estructuras de datos:Diccionarios							|
-------------------------------------------------------------------------------------------------------------------------------------------------
*En los diccionarios, cada elemento esta conformado por clave:valor
*En los diccionarios las claves deben ser unicas, si llegase a ver 2 claves iguales, la clave se quedaria con el último valor asociado.
*Los diccionarios, al igual que las listas son:
	-heterogeneas: los elementos pueden ser de distintos tipos en un diccionario
	-mutables: los elementos pueden ser modificados

*Los diccionarios no son ordenados, es decir que no podremos acceder a ellos por indice. perdemos indice pero ganamos la clave
*No es recomendable que las claves seas datos de distintos tipo

sea 'dicci' un diccionario:
	*En memoria se guardara las claves en orden alfanumericos, los números primero y luego compara las claves string
	*Pero al imprimir mostrara el orden en el que fue creado

*si pedimos un valor para una clave que no existe, devolvera el error el programa


sintaxis:
---------

nameDicci={clave1:valor1, clave2:valor2....}	-->recordad que las claves deben ser únicas.



acceder a un diccionario:
-------------------------
NameDiccionario[valorClave]			

ejemplo:
- - - -
dicc=["names":["Ana","Borja","Carmen"],"ages":[31,25,16]]
dicc["names"]	#nos devolvera el valor de la clave "names", es decir devuelve la lista ["Ana","Borja","Carmen"]



bucles y diccionarios:
----------------------
*un diccionario es una estructura iterable, es decir que podemos trabajarla con lista, en este caso la lista for.

ejemplo:
- - - - 
dicc = {"Username":"msf",
	"name":"Maria",
	"age":22,"city":
	"Palma de Mallorca"}

for key in dicc:			#key ira iterando tomando el valor de cada clave
	print(key,"{}".format(dicc[key])		


ejemplo de usar .items()		
- - - - - -- - - - - - - 
dicc.items()			# CREA: dict_items([('Username', 'msf'), ('name', 'Maria'), ('age', 22), ('city', 'Palma de Mallorca')])
for i in dicc.items():
    print(i)


for key,value in dicc.items():	#al tener cada tupla 2 valores, podemos guardar cada uno respectivamente en cada iteración (key,value)
				  key=clave y value=valor de cada elemento de la tupla. (es como hacer un bucle doble)				 

	print(key,":",value)	



Ejemplo 3:
- - - - - 
dicci={i:i for i in range(1,5)}
	#Creara un diccionario de la siguiente forma
	#dicci={1:1, 2:2, 3:3, 4:4}
	


Ejemplo 4:
- - - - - 
A={"name":[input("Digite #{}:".format(i)) for i in range(3)]}




diccionarios y listas:
----------------------
*Como se ha mencionado antes, un diccionario puede contener listas u otros diccionarios. Por su parte, una lista también puede contener diccionarios.
*Es la base de los ficheros .json

Ejemplo:
- - - -

dicc_1 = {"name": "Elisa",			#un diccionario con elementos tipo lista y tipo diccionario
        "age": 30,
        "gender": "female",
        "ID": [4, 4, 2, 1, 5, 6, 7, 2, "L"],
        "user&password": {
            "username": "eli88",
            "password": "1234catsareawesome"
            }
          }
dicc_2 = {"name": "Henry",			#un diccionario con elementos tipo lista y tipo diccionario
        "age": 27,
        "gender": "male",
        "ID": [1, 1, 0, 1, 3, 8, 6, 9, "A"],
        "user&password": {
            "username": "superhenry",
            "password": "1432superme"
            }
          }
lista = [dicc_1, dicc_2]		#A su vez esta lista tiene de elementos 2 diccionarios

for item in lista:
  print(item)


Ejemplo2:
- - - - -
'
Tenemos un diccionario con 5 claves: Math, English, History, Science, IT. Cada clave contiene una lista de tamaño 3, donde cada una de esas 
entradas se corresponde con una nota de 0 a 10. El usuario va a ser quien introduzca esas notas por teclado. Finalmente, para cada clave, 
mostraremos la media de las 3 notas. PISTA: Necesitarás la función sum().
import numpy
'
numpy.empty((1,3))

dicci={"Math":[float(input("Digite #{}:".format(i))) for i in range(3)],
       "English":[float(input("Digite #{}:".format(i))) for i in range(3)],
       "History":[float(input("Digite #{}:".format(i))) for i in range(3)],
       "Science":[float(input("Digite #{}:".format(i))) for i in range(3)],
       "IT":[float(input("Digite #{}:".format(i))) for i in range(3)]}

for key in dicci:
    print("El promedio de",key,"es: {}".format(sum(dicci[key])/3))



Ejemplo2.2:
------------
import numpy

numpy.empty((1,3))

dicci={"Math":[],
       "English":[],
       "History":[],
       "Science":[],
       "IT":[]}

for key in dicci:
    print("======",key,"========")
    for i in range(1,4):
        dicci[key].append(float(input("Nota trimestre #{}: ".format(i))))

print("Media por asignaturas")
for key,valu in dicci.items():
    print(key,":",(sum(valu)/3))



uso de fromkeys:
----------------
B=dict.fromkeys([4,1,2,4],"amigo")
print(B)
#devuelve {4: 'amigo', 1: 'amigo', 2: 'amigo'}


=================================================================
		metodos de diccionarios:			|
=================================================================
*Siendo dicci un diccionario


dicci.keys()			-->Devuelve una lista con las claves de dicci.
dicc.values()			-->Duvuelve una lista con los valores de cada clave de los diccionarios 

dicc={}				-->Crea un diccionario vacio
dicci["clave1"]=valor1		-->en caso no haya la clave1, crea una nueva clave y le asigna dicho valor, aquí podemos usar input,etc.
				   str(valor1), si agregamos así, podemos forzar a indicar que el valor dado si o si es un string

len(dicci)			-->devolvera la cantidad de parejas clave:valor que tiene el diccionario (cantidad de elementos)

dicci.items()			-->Obtendremos una lista de tuplas (clave,valor) para cada elemento de un diccionario. Al ser una lista, sabemos que 
				   es iterable y podemos mostrar sus entradas haciendo uso de un bucle .for

sum(dicci.values())		-->Suma los elementos de una lista iterable. (tiene que ser una lista, tupla, etc)

dicci.clear()			-->vacia todo el diccionario y guarda el cambio. El diccionario queda vacio

dicci2=dicci.copy()		-->devuelve una copia del diccionario original, la diferencia : si hacemos una copia con '=', es que  = al modificar el diccionario original, el diccionario 					   copiado también cambia. En cambio copy() evita ese comportamiento


dicci=dict.fromkeys(iterable,valor)	-->Recibe como parametro un iterable(ejem: lista) y como valor lo que sea. lo que hace fromkeys es devolver un 						   diccionario cuyas claves seran cada iterable con el mismo 'valor'-
dicci=dict.fromkeys(iterable)		-->Si no recibe el valor, nos devolvera 'None' en cada una de las claves. None es ausencia de valor


dicci.get("clave")			-->Devuelve el valor de la 'Clave', la ventaja sobre corchete es que si no encuentra el valor devolvera 'None'
					   evitando que el programa caiga o muestre un error como ocurria con los []

dicci.pop("clave")			-->Devuelve el valor de la clave y luego elimina dicha clave con su valor del diccionario.
					   si no encuentra la clave, nos dara un error

dicci.setdefault("clave")		--> Devuelve el valor de la clave (funciona como .get("clave"))		
dicci.setdefault("clave",valor)		--> Si la clave no existe, crea una nueva clave:valor y lo guarda en el diccionario. Pero si existe devuelve 						    el valor como un get("clave") (no modifica el valor de la clave existente)

dicci.update(dicci2)			-->El metodo update recibe como parametro otro diccionario. En caso de tener claves iguales, acutaliza el 						   valor de la clave repetida. En caso de no haber claves iguales, el par newclave:newvalor es agregado al 						   .diccionario al que es aplicado el metodo
					   (Es decir, primero agrega las claves:valor de dicc2 que no existe y luego actualiza el valor de todas las 						   claves que se repiten a dicci)


dicci=dict(iterable)			-->El iterable tendrá de elementos iterables de 2 valores. Ya que dict lo que hace es al primer elemento
					   convertirla en clave y al segundo en su valor


ejemplo de uso de los metodos:
-------------------------------
uso de fromkeys:
----------------
B=dict.fromkeys([4,1,2,4],"amigo")
print(B)
#devuelve {4: 'amigo', 1: 'amigo', 2: 'amigo'}

uso de update:
--------------
ejemplo
dicc1 = {"a": 1, "e": 2, "i": 3, "o": 4, "u": 5}
dicc2 = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5}

dicc1.update(dicc2)		#dicc1 guardara el update modificando su estructura
print(dicc1)			#{'a': 1, 'e': 5, 'i': 3, 'o': 4, 'u': 5, 'b': 2, 'c': 3, 'd': 4}	

uso de DICT:
------------
ejemplo1:
l=[["a",1],["b",2]]
dict(l)				#devolvera un diccionario de la forma {a:1,b:2}

ejemplo2:			
dicc1=dict(x=0,y=1,z=-1)	#devolvera un diccionario de la forma {'x':0,'y':1,'z':-1},  x y z son variables que luego los tomara como claves

ejemplo3:
dicc2=dict({"x":0,"y":1,"z":-1}) #devolvera un diccionario de la forma {"x":0,"y":1,"z":-1}, como vemos dict a diccionarios no tiene mucho sentido.

ejemplo4:



curiosidad: a=["a",2],["b",1],{"c":1}	-->no marca error por que 'a' sera un iterable tipo tupla




-------------------------------------------------------------------------------------------------------------------------------------------------
					  SECCIÓN 10: Tema 8 - Estructuras de datos:Conjuntos							|
-------------------------------------------------------------------------------------------------------------------------------------------------
Carácteristicas:
----------------
*Es una estructura de datos donde no hay orden. No se admiten multiples ocurrencias de un mismo elementos
*Los conjuntos son heterogeneos. Es decir que los elementos pueden ser de distinto tipo
*no mutables: Los elementos no pueden ser modificados una vez el conjunto haya sido creado.
*Un conjunto no admite elementos repetidos
*Colección de elementos que pertenecen a la misma categoria y cuya agrupación puede ser considerada o identificada en si misma como un objeto
 Un conjunto queda definido únicamente por sus elementos y nada más. En particular, un conjunto puede escribirse como una lista de elementos
*Cambiar el orden de dicha lista(conjunto) o añadir elementos repetidos no define un conjunto nuevo.


	-Definición1: Se pueden definir dando de parametro una lista,tupla a la función .set()
		Ejemplo:	
			
	set1=set([1,2,7,4])	# crea el conjunto {1,2,7,4}	
	print(set1)		# Cuando vayamos a mostrar el conjunto nos mostrara ordenado los elementos primero en orden númerico y luego 					  alfabetico. si en el conjunto hay string los negativos invierten su comportomaiendo, caso contrario no
	type(set1)		# set (set de conjunto)
	
	-Definición2: O se pueden poner los elementos entre llaves separados por 1 coma (la diferencia con los diccionarios es que estos no estan en 			      forma clave:valor) (curiosidad por que en las matemáticas los conjuntos también estan entre llaves)
		


		Ejemplo:
	
	set1={2,4,5}		#Crea el conjunto	



subconjunto:
------------
*subconjunto: Se denota subconjutno si B⊆A, es decir si B contiene algúnos elementos de A(quizá todos).
*subcojunto propio: Se denota subconjunto propio si B⊂A, es decir si B tiene algúnos elementos de  A(pero no todos).

A, B = {0, 3, 7, 2, 5}, {2, 3, 0,7,2,5}
B.issubset(A)	#Devuelve True ya que B tiene todos los elementos de A
B <= A		#
B < A		#Devuelve False ya que no puede tener todos los elementos de A



superconjunto:
--------------
*Superconjunto: Un superconjunto A de un conjunto B es un conjunto que contiene a B. Se denota por A⊇B 
*Superconjunto propio: Un superconjunto A de un conjunto B es un conjunto que contiene a B y consta de almenos 1 elemento más. se denota por A⊃B

A,B= {0,3,7,2,5} , {2,3,0}
A.issuperset(B)			# Devolvera True ya que A contiene todos los elementos de B
A>=B				# Devolvera True ya que A contiene todos los elementos de B
A>B				# Devolvera True ya que A además de contener a B tiene elementos propios


==========================
Operaciones con conjuntos:
==========================
*Dado los conjuntos A y B


unión: A.union(B) o B.union(A)
------
A | B 		#o A.union(B)	,La unión de 2 conjuntos resulta en nuevo conjunto con los elementos de estos ultimos

intersección: A.intersection(B) o B.intersection(A)
-------------
A & B		#o A.intersection(B), dara un nuevo conjunto con la intersección de estos ultimos


diferencia de conjuntos: A.difference(B)
------------------------
A - B		# o A.difference(B), Devuelve todos los elementos de A menos los que también contenga B


diferencia simetrica: A.symetric_difference(B)
---------------------
A.symetric_difference(B)	#Devuelve los elementos de la unión de AuB menos los de la intersección de A^B

*A la diferencia simetrica lo podemos trabajar también como la unión de las diferencias de A y B ((A-B)u(B-A)) 


=========================
  Bucles y conjuntos:
-------------------------
*Recordar que un conjunto es iterable.

ejemplo:
--------
A={1,2,"Manzana",4}
	
for i in A:			#i ira tomando el valor de cada elemento de A, uno a uno pero sin seguir un orden.
	print(A)		#imprime el valor que va tomando i


=========================================================================
|			Metodos para conjuntos:				|
=========================================================================
A=set()			     --->Crea un conjunto vacio.
A=set(iterable)		     -->convierte el iterable(lista, tupla,etc) a conjunto. Un conjunto no admute elementos repetidos en sus elementos.
				las repeticiones desaparece
B.issubset(A)		     -->Para saber si B esta incluido en A, es decir si B es subconjunto de A, devolvera True y es cierto y Falso si no.
B <= A			     -->Para saber si B es subconjunto de A, devolvera un booleano
B < A			     -->Para saber si B es un subconjunto propio de A, devolvera un booleano

A.issuperset(B)		     -->Para saber si A contiene todos los elementos de B. Devuelve un valor booleano 
A>=B			     -->Para saber si A contiene todos los elementos de B. Devuelve un valor booleano
A>B			     -->Para saber si A contiene todos los elementos de B además de otros. Devuelve un valor booleano

A.union(B)			-->Une al conjunto A con B y devuelve un nuevo conjunto (es conmutativo)
A | B				-->Une al conjunto A con B y devuelve un nuevo conjunto

A.intersection(B)	 	--> devuelve un nuevo conjunto con la intersección de A y B
A & B				--> devuelve un nuevo conjunto con la intersección de A y B

A.difference(B)			--> devuelve un nuevo conjunto con todos los elementos de A menos los que también haya en la intersección o tenga B
A-B				--> devuelve un nuevo conjunto con todos los elementos de A menos los de B

A.symmetric_difference(B)	--> Devuelve un conjunto con todos los elementos de AuB salvo los que pertenecen a la intersecció.
			  	     (A | B) - (A & B)   o    (A-B) | (B-A)


A.add(elemento)			--> Elimina el conjunto y crea un nuevo conjunto con los mismos elementos añadido 'valor' 
				    (Es como añadir un nuevo elemento al conjunto A)

A.update(B)			--> Para añadir elementos de otro conjunto B en el conjunto actual A. Update también permite añadir elementos de un 					    iterable, como una lista,etc.

elemento in A			--> Para averiguar si un elemento pertenece al conjunto A

A.remove(elemento)		--> Elimina 'elemento' del conjunto A. Sino encuentra el elemento devuelve un error
A.discard(elemento)		--> Elimina 'elemento' del conjunto A. Sino encuentra el elemento no duelve ningún error.


lent(A)				--> Para saber cuantos elementos tiene un conjunto.

A.pop()				-->Nos devuelve un objeto del conjunto (como no hay orden no podemos saber cual) y lo elimina de este.

A.clear()			--> Vacia el conjunto de todos sus elementos y deja un conjunto vacio.


ejercicios usando los metodos:
------------------------------
Ejercicio1:
- - - - - -
#Vamos a guardar en un conjunto los números primos comprendidos entre 2 y el número  n  que nos indique el usuario mediante la criba de Eratóstenes
#forma 1

n=int(input("Introduce un número entero mayor que 2: "))
primes=set(range(2,n+1))
numbers=list(range(2,n+1))
multiples=[True for x in range(len(numbers))]

for i in range(len(numbers)):
    if multiples[i]==False:
        continue
    for j in range(i+1,len(numbers)):
        if numbers[j]%numbers[i]==0:
            multiples[j]=False
            primes.discard(numbers[j])

print(primes)





#forma 2:

n=int(input())
a=set(range(2,n+1))
i=2

while i<n+1:
    if i in a:
        j=0
        
	while j<n+1:    
            a=a-{j}
            j=j+i
        a.add(i)

    i=i+1

print(a) 
    





-------------------------------------------------------------------------------------------------------------------------------------------------
					  SECCIÓN 11: Tema 9 - Estructuras de datos: Tuplas							|
-------------------------------------------------------------------------------------------------------------------------------------------------
Carácteristicas:
----------------
*La ventaja de la tupla es que ahorran mas espacio en memoria a diferencia de un lista, ya que esta reserva mas memoria para poder crecer.
*Es como el intermedio entre carácteristicas de una lista y conjunto.
*Tienen un orden pero no pueden mutar
	-heterogeneos: Los elementos pueden ser de distinto tipo en una misma tupla
	-no mutables: los elementos no pueden ser modificados una vez la tupla ha sido creado.


*La tupla son elementos separados por comas y escritos entre ()
*Podemos declarar una tupla sin la necesidad de indicar sus elementos entre parentesis.
*Podemos acceder a los elementos de una tupla mediante la sintaxis del [] ya que son datos ordenados.
*Son las herederas casí en comportamiento de los string


unpacking:
----------
*La cantidad de variables debe ser iguales a la cantidad de elementos que vamos a necesitar. Hay 2 formas de hacerlo para tuplas, una poniendo parentesis y otra no.

Sea: Variable=elemento1,elemento2,elemento3...


variable1,variable2,variable3...=Variable
(variable1,variable2,variable3...)=Variable

Metodo del *:
-------------
*A la variable que acompañe lo transformara en tipo lista y guardara en ella los elementos necesarios para que la cantidad de elementos coincida con la cantidad de variables respetando el orden en la que estan.
*Solo puede haber 1 expresión con *.

variable1,*variable2=Variable
print(variable1)	-->devolvera 'elemento1'
print(variable2)	-->devolvera [elemento2,elemento], como vemos el * indica que esta variable tendrá el resto de elementos como valor


*variable1,variable2=Variable
print(variable1)	-->devolvera [elemento1,elemento2], como vemos el * da tantos valores a esta variable de manera que coíncida el numero de 				   elementos con el número de variables
print(variable2)	-->devolvera 'elemento 3'

Metodo del _ :
--------------
*donde valla _ indicara que sabemos que hay algo pero que no lo vamos a utilizar.(solo esta ahí para completar el unpacking), nos sirve para presindir el de utilizar variables que no vayamos a utilizar.

variable1,_,variable3=Variable 


combinando *_ :
---------------
*indicamos que no vamos a utilizar los demás elementos.
variable1,*_,variable2,variable3=Variable



-------------------------------------------------
	Concatenación de Tuplas			:
-------------------------------------------------
sean t1,t2,t3... tuplas y t también otra tupla

t1+t2	--> Se concatenaran las tuplas pero el resultado sera una nueva tupla, no modificaras ningúna tupla
t1*5	--> El resultado sera una nueva tupla concatenada con los elementos de t1 '5' veces


---------------------------------
	Bubles y Tuplas		:
---------------------------------
t1= 'a','b','c','d','e','f','g','h'

for i in t1:
	print(i)		# i ira tomando el valor de elemento a elemento de la lista y se imprimira por print

t2=('a','b'),('c','d'),('e','f'),('g','h')

for i, j in t2:			# Utilizamos la tecnica del unpacking
	print(i,j)		#i tomara el primer valor de cada tupla y j el segundo valor.

t3=('a','b','c'),('d','e','f'),('g','h','i'),('j','k','m')

for i,j,k in t3:			# Utilizamos la tecnica del unpacking
	print(i,j,k)		#i tomara el primer valor de cada tupla, j el segundo valor y k el tercer valor.



ejemplo:
--------
a=[1,2,3,4]

for i,n in enumerate(a):		#i tomara el valor del indice y n el valor del elemento peteneciente a dicho indice.
	print(i,j)


------------------------------------------
Tuplas y el resto de estructuras de datos:
------------------------------------------
*Una tupla puede contener listas, diccionarios, conjuntos y tuplas
*Las listas pueden contener tuplas, conjuntos, diccionarios y otras listas.
*Los diccionarios pueden contener listas, tuplas, conjuntos y otros diccionarios.
*Los conjuntos no pueden contener ni listas, ni diccionarios ni siquiera otro conjunto pero si tuplas.

-------------------------------------------------
		función zip()		    	:
-------------------------------------------------
*Sirve para juntar listas en tuplas. Juntara elemento a elemento ambos del mismo indice y guardara cada par en una tupla. 



Sintaxis:
---------
zip(lista1,lista2,lista3,lista4...)

Ejemplo:
	objetos=['libreta','pluma','portaminas','cable']
	precios=['2','1','2','10']
	items=zip(objetos,precios)	#items contendra a zip pero en memoria
	print(items)			#Nos mostrara una posición en memoria
	print(list(items))		#Nos mostara recién lo contiene zip que es ('libreta',2),('pluma',1),('portaminas',2),('cable',10) pero dentro
					 unos corteches, ya que utilizamos list.

*Podemos iterar directamente sobre el resultado del zip


=========================================================================
|			Metodos para Tuplas:				|
=========================================================================
t= ()					--> tupla vacia
t= (elemento,)				-->OJO, si declaramos tupla de 1 solo elemento tendremos que poner una coma despues por que si no sera visto 						   como un dato tipo string	

t=(string,)				-->Transforma todo el string como un único elemento de la tupla, si usamos la función tuple el string se 						   dividira carácter por carácter.

t=((string1,string2),)			-->lo mismo, una tupla de 2 elementos. no necesariamente string, puede ser númerico. la ',' es importante. 

		
t= tuple((elementos))			-->Para declarar una tupla con dichos elementos
t= tuple(iterable)			-->Podemos convertir otros iterables tipo tupla, listas, conjuntos, etc.

len(t)					-->Para saber cuantos elementos tiene una tupla.

enumerate(iterable)			-->devuelve por cada elemento del iterable una tupla con 2 elementos, (i,valor) donde el primer elemento 						   corresponde al indice que ocupa y valor al elemento del iterable.

zip(lista1,lista2,lista3,lista4...)


=================================================================================================================================================
							SECCIÓN12: Tema- Funciones 								|
=================================================================================================================================================
*Las variables que definimos dentro de la función solo existen dentro de ella.
*Consta de 3 partes:
		-inputs: Son los valores que le pasamos como entrada a la función
		-cuerpo: Son todas las operaciones que lleva a cabo la función
		-ouput: Es el resultado que devuelve la función.

def nameFunción(input1,input2,input3.....)	#La función consta de un nombre(tiene que ser significativo) y sus inputs(no necesariamente)
	cuerpo					#Son las operaciones que lleva a cabo la función
	return ouput				#es lo que devuelve la función al ser llamada, puede no devolver nada.

nameFunción()					#utilizamos el nombre que le dimos a la función y parentesis para llamarla.



x=nameFUnción()				#Para que x tome algún valor, la función debe devolver algo

*Los parametros son posicionales. Es decir cada inputs que pasemos sera tomado por la primera variable de la función, y así sucesivamente.
 Pero también podemos definir que valores tomara cada input de la función.
	Ejemplo:
		def good_morning(name):					#Definimos nuestra función y el nombre de su variable parametro interna
			print("Buenos días {}".format(name))	
		
		good_morning(name="camila")				#Aquí nosotros expectamos que habra una variable interna de la función que se 										 llama name y esta recibira ese valor



*Tenemos que pasar la cantidad de entradas que espera recibir la función.

Número arbitrario de argumentos: 
---------------------------------
Si no sabemos el número de parametros que van a ser introducidos, entonces añadimos un * (recordad esto de tuplas)
previo al nombre del parámtero en la definición de la función. Los valores introducidos serán guardados en una tupla. (el * funciona igual que en el desempaquetado de tuplas)


Número arbitrario de claves de argumento:
-----------------------------------------
Si definimos los valores parametros que tomara cada función y luego queremos que un parametro tome mas valores, usamos el ** para permitirlo.

ejemplo1:
- - - - -

def complete_name(name,**surname):			#surname guardara en un diccionario todas las variables internas que no hay con sus 								 respectivos valores
	
	print("El nombre completo es {}".format(name),end=" ")
	for i in surname.items():
		print("{}".format(i[1]),end=" ")

complete_name(name="Maria",surname1="Santos",surname2="Fernández")	#Como vemos declaramos variables internas que no habran




Parametros por defecto:
-----------------------
Ejemplo1:
- - - - -

def nombreFuncion(n1,n2=1):		#Como vemos aquí un parametro ya esta definido, por lo tanto no es necesario pasarle un valor
	return n1-n2


nombreFuncion(n1=4)			#n2 ya esta definido, por lo tanto solo es necesario pasarle 1 parametro. 
nombreFuncion(n2=5)			#Dara un error, por que n2 ya esta definido. n1 es el que necesita un valor
nombreFuncion(3,4)			#n1=3 y n2=4. Los parametros recibiran un nuevo valor correspondientemente a su posición
nombreFuncion()				#Si n1 estaria definido. ya no seria necesario pasarle parametros.


=========================================================================================
				Docstring						|
=========================================================================================
*Son comentarios explicativos que ayudan a comprender el funcionamiento de una función. 
	-van entre trile comilla doble
	-pueden ser multilínea
	-Se sitúan al principio de la defición de la función

Un buena documentanción es de la siguiente forma:
Ejemplo1:
- - - - -

def euclidean_division(x, y):
  """
  Esta función calcula el cociente y el resto de la		--->Tiene una explicación del para que sirve
  división entera de x entre y.

  Args:
    x (int): dividendo						--->Indica que argumentos recibé y que son
    y (int): divisor (que no puede ser cero)

  Returns:
    (q, r): tupla con el valor de (cociente, resto)		--->Indica lo que retorna y que es. 
  """
  q = x // y
  r = x % y
  return q, r

=========================================================
		Metodos de Docstring			|
---------------------------------------------------------
nameFuncion.__doc__				-->Nos sirve para leer la documentación que tiene nuestra función, nuestra clase, etc.





variables locales y variables globales:
---------------------------------------
*variable local: Aquella que es creada y solamente existe dentro de la función.
*variable global: Aquella que es creada en el entorno global.

*Si dentro de un función utilizamos la palabra reservada 'global' y la colocas antes de una variable local, esta pasa a ser una variable local previamente definida.

Ejemplo1:
- - - - -
n=7
		
def nex_n():
	global n		#n pasa a ser una variable global y toma su valor correspondiente que fue asignado.
	return n+1

nex_n()				#Llamamos a la función




Paso por copia de variables vs Paso por referencia de variables:
----------------------------------------------------------------
*Dependiendo del tipo de dato que pasemos como parametro a la función, podemos diferenciar entre
	-Paso por copia: Se crea una copia local de la variable dentro de la función.
	-Paso por referencia: Se maneja directamente la variable y los cambios realizados dentro de la función afectan también a nivel global.

*En general, los tipos de datos básicos como enteros, en coma flotante, strings o booleanos se pasan por copia, mientras que estructuras de datos como
listas, diccionarios, conjuntos o tuplas u otros objetos se pasan por referencia.



Ejemplo paso por copia.
- - - - - - - - - - - -
#Paso por copia

def vemos(a):       #Esta a es una copia de la variable 'a' global, el cambio que le hagamos actuara sobre la copia.
    a=a+5       
    return a
a=3

print(vemos(a))     #Aquí pasamos una copia de a y su valor, imprime 8
print(a)            #Como vemos a no ha modificado su valor, imprime 3


*Podemos decir que ambas variables tienen el mismo nombre, pero hacen referencia a distinta posición en memoria.



Ejemplo paso por referencia:
- - - - - - - - - - - - - - -
#Paso por referencia
a=[1,2,3,4,5]

def doble_valor(a2):
    for i,n in enumerate(a2):
        a2[i]*=2

print(doble_Valor(a))       '''pasamos por referncia a la lista 'a', el cambio que le hagamos hacia a2 también se lo hara a la lista 'a'
                            ya que no es una copia y ambas hacen referencia a la misma posición de memoria'''
print(a)                    #Como vemos el valor de a también se modifico.

print(doble_valor(a[:]))        #Con esto recién pasamos una copia de la lista 'a' a la función
print(doble_valor(a.copy()))    #Otra forma de pasar una copia a la función.



*Podemos decir que por mas que hayan llamado distinto, ambas hacian referncia a la misma posición de memoria, por tanto si
una sufria cambios, es como si esos cambios se lo aplicasemos a la original.

*Esto es así, ya que cuando trabajamos con gigantescas estructuras de datos, no conviene para nada que se cree una copia de la misma,
ya que ocupariamos demasiada memoria.




-------------------------------------------------
		Funciones recursivas		|
-------------------------------------------------
*Es una función que se llama asi misma.
*Tener cuidado por que una función recursiva puede devolver None. Ya que primero devuelve eso dentro de ella misma(ahí fue llamada por ultima vez).

ejemplos:
- - - - -
def power(x,n)				#Este es un ejemplo de un función que se llama así misma
	if x**n>1000000			#Aquí tenemos la condición para parar el bucle, si no lo hacemos la función se llamara infinitamente.
		return x**n		
	power(x,n+1)			#Tiene sentido si cada vez que le llamamos va cambiando de resultado.


Ejemplo2:
- - - - -
#Vamos a crear una función recursiva que calcula el factorial de un número

def facto(n):
    if n==0:
        return 1
    return n*facto(n-1)

n=int(input("Digite un número: "))
facto(n)


*Caso final: Toda función recursiva tiene un caso final que detiene que el llamado sea un bucle infinito.


Ejemplo  3:
- - - - - -
#Calcular el termino 'n' de una sucesión de fibonacci.
def fibonacci(index):
    if index==0 or index==1:
        return 1
    return fibonacci(index-1)+fibonacci(index-2)

n=int(input("Digite el termino deseado: "))
fibonacci(n)



		funciones helper
-----------------------------------------------
*Es una función cuyo propósito es evitar la repetición de código.
*Es decir una función que nos ayudara a que nuestro código sea mas simple y más fácil de manipular. 

Caso 1: (sin helper)
- - - -
#Podriamos tener definida una función así
def sign_sum(x,y):
    if x+y>0:
        print("El resultado de sumar {} más {} es positivo".format(x,y))
    elif x+y==0:
        print("El resultado de sumar {} más {} es cero".format(x,y))
    else:
        print("El resultado de sumar {} más {} es negativo".format(x,y))

sign_sum(3,5)
sign_sum(-3,3)
sign_sum(3,-5)
#Como vemos, el código es medio repetitivo, y si desearamos modificar el mensaje de print, tendríamos que hacerlo 1 por 1



Caso 2:
- - - -
#Usando una función helper que nos ayude a simplificar y poder modificar más fácil a todas las lineas de código.

def helper_sign(x,y,sign):
    print("El resultado de sumar {} más {} es {}".format(x,y,sign))

def sign_sum(x,y):
    if x+y>0:
        helper_sign(x,y,'positivo')
    elif x+y==0:
        helper_sign(x,y,'cero')
    else:
        helper_sign(x,y,'negativo')

sign_sum(7,8)
sign_sum(7,-8)
sign_sum(7,-7)

#Aquí vemos que si quisieramos agregarle 1 punto a nuestro print, solo tendríamos que ir a nuestra helper_sign.

=================================================================================================================================================
|						SECCIÓN13: Tema11- Funciones Lambda 								|
=================================================================================================================================================
*Son un tipo especial de funciones de Python que tienen la siguiente sintaxis.
	
Sintaxis:          Lambda parámetros: expresión

	-Son útiles para ejecutar funciones en una sola línea
	-Pueden tomar cualquier tipo de argumento.
	-Tienen una limitación: Solamente pueden contener una expresión.


ejemplos:
- - - - -

plus10= lambda x: x+5
plus10(5)		#retorna 10








=========================================================
		función filter				|
=========================================================
*Aplica una función a todos los elementos de un iterable.
*Devuelve un objeto generador, de ahí que usemos la función list para convertirlo a lista.
*Como outút, devuelve los elementos para los cuales el aplicar la función ha devuelto True.

sintaxis:

filter(nameFuncion,iterable)		--->A cada elemento del iterable que le pasemos, le aplicara la función y solo devolvera aquellos que cumplan
					    La condición de la función.

ejemplo:
- - - - -
num=[2,4,167,652,357,421,234]
list(filter(lambda x: x%2==0 , num))		#Usamos list, por que al final filter devuelve un objeto generador que necesita ser convertirdo a una
						 estructura de datos.


=========================================================
		función reduce				|
=========================================================
*Aplica una misma función a los elementos de un objeto iterable.
	- Aplica la función a los primeros 2 elementos
	- Aplica la función al resultado del paso anterior y tercer elemento.
	- Aplica la función al resultado del paso anterior y cuarto elemento.
	- Sigue así hasta que solo queda un elemento.
*Devuelve el valor resultante.

	Sintaxis	:
-------------------------
from functools import reduce	#Primero importamos esta libreria que nos permitira trabajar con reduce()

reduce(nameFunción, iterable)	



Ejemplo1:
- - - - -
from functools import reduce

nums= [1,2,3,4,5,6]

reduce(lambda x,y: x*y , nums)		#Nos devolvera el producto de los elementos de nums.

*Como vemos reduce(función, iterable) devuelve todo un iterable hasta que solo quede un elemento.


Ejemplo2:
- - - - -
from functools import reduce

def mayor(n1,n2):
    if n1>n2:
        return n1
    return n2

nums=[-13,5,7,-10,5,18]
reduce(mayor,nums)			#Nos devolvera el número mayor.




=========================================================
|		función map				|
=========================================================
*Aplica una misma función a todos los elementos de un objeto iterable
*Devuelve un objeto generador, de ahí que usemos la funcipon list() para convertirlo a lista.
*Como output, devuelve el resultado de aplicar la función a cada elemento.

Sintaxis:
---------

map(nameFuncion,iterable)



Ejemplos:
- - - - -
words=['zapato','amigo','yoyo','barco','xilófono','césped']
list(map(lambda w: len(w),words))	#Devolvera una lista con la longitud de cada palabra de words

list(map(len,words))			#Devolvera una lista con la longitud de cada palabra de words, ya que 'len' es una función


=========================================================
|		función sorted				|
=========================================================
*Ordena los elementos del objeto iterable que indiquemos de acuerdo a la función que pasemos por parametro.
*Como ouput, devuelve una permutación del objeto iterable ordenado según la función indicada.


sintaxis:
---------
sorted(nameLista, key=nameFuncion)			#ordenara la lista en base a la función en forma ascendente
sorted(nameLista, key=nameFuncion,reverse=True)		#ordenara la lista en base a la función en forma descendente.
sorted(nameLista, key=nameFuncion,reverse=False)	#ordenara la lista en base a la función en forma ascendente(es lo mismo que no poner este 								 parametro, ya que es el valor que tomar por defecto)

Ejemplos:
- - - - -

words = ["zapato", "amigo", "yoyo", "barco", "xilófono", "césped"]	#Nuestra lista
sorted(words,key=lambda x:len(x))					#Ordenara en forma ascendente en función de los len de cada elemento de lista.
sorted(words,key=lambda x:len(x),reverse=True)				#Ordenara en forma descendete en función de los len de cada elemento de lista.
		

sorted(words,key=len)							#Ordenara en forma ascendete en función de len a cada elemento de la lista.
sorted(words,key=len,reverse=True)					#Ordenara de forma inversa.
sorted(words)               #Ordenara en base al orden alfabetico	#Ya que no pasamos ningúna clave, ordenara a los elementos de words en función 										 del orden alfabetico.



Ejemplo2:
- - - - -

#Vamos a ordenar una lista de palabras por el número de apariciones de la letra indicada por el usuario. EL orden será descendente.

words = ["zapato", "amigo", "yoyo", "barco", "xilófono", "césped"]
n=input("Indique la palabra:")

#def apariciones()


sorted(words,key=lambda x,y=n:x.count(y),reverse=True)		#El segúndo parametro coge el valor de 'n' para trabajarlo dentro de la lista.
sorted(words,key=lambda x:x.count(n),reverse=True)		#podemos trabajar directamente con 'n' por ser una variable global?



-------------------------------------------------
|	OBTENER NÚMEROS ALEATORIOS:		|	
-------------------------------------------------
from numpy import random		#Sirve para trabajar con el metodo random.

random.randint(low,higt=None,size=None,dtype=int)	#'low','higt' hace referencia entre que rango se generara un número aletorio. 'Size' al tamaño
							 de número que se generara, 'dtype' al tipo de dato que sera, por defecto es int y los demás 								 como se ve en la sintaxis.


random.randrange(low,hight)				#la diferencia con randint es que esta si incluye al ultimo valor de hight


Ejemplos:
- - - - -
#1
random.randint(5)	#Generara unos aleatorios entre '0'(valor por defecto) y 5(sin tomar a este en cuenta)

#2
random.randint(5,12,size=12)	#devolvera una lista con 12 números random entre 5-12 (sin tomar al 12)	


lista de flotantes aletorios:
-----------------------------
from numpy import random
random.randint().astype("f")	#el truco es usar astype


obetener lista de string aletorios:
-----------------------------------
import random, string			#Nos permite trabajar con los metodos de abajo
words=["".join(random.choice(string.ascii_letters) for _ in range(8)) for _ in range(6)]

=========================================================================================================
					Funciones especiales						|	
=========================================================================================================
abs(valor)			-->Devuele el valor absoluto de un número.


=======================================================================================================================================================
|					Sección 14: Tema12 - Dataframes con el módulo pandas							      |
=======================================================================================================================================================
*Los dataframes son utilces para el campo del big data, analisis de datos, estadisticas de datos, etc.
*Dataframe: Es una estructura bidimensional mutable de datos con los ejes etiquetados donde:
	- Cada fila representa una observación diferente.
	- Cada columna representa una variable diferente.

*En python para definir un dataframe, en primer lugar necesitamos importar el modulo pandas
'import pandas as pd'			#como vemos importamos pandas y le damos un alias, pd.




Ejemplo1:
- - - - -
import pandas as pd			#Importamos el modulo panda
data = {"x": [1, 2, 3, 4, 5], "y": [2, 4, 6, 8, 10]}	#Tenemos un diccionario, las listas(los valores de cada clave) deben ser del mismo tamaño para 								 poder aplicar data frames

df1=pd.DataFrame(data=data)		#Creamos nuestro dataframe, pasando a 'data' nuestro diccionario 'data'. Creado nuestro data frame lo 						 guardamos en df1
print(df1)				#Mostramos nuestro DataFrame en pantalla.
					#Se generara también una columna que sera de observación(como el código).






Ejemplo2:
- - - - -
import pandas as pd
def2=pd.DataFrame([[1,2],[2,4],[3,6],[4,8],[5,10]],columns=['x','y']) 		#pasamos una lista, cada elemento esta formado por 2 valores. x y y 											 hacen referencia al nombre que tendrá cada columna(por parametro 											 0,1,2...). La cantidad de valores que tendrá un elemento dependera de 											 cuantas columnas vamosa  a querer.
print(def2)

*columns sirve para ponerle el nombre a nuestras columnas.





Ejemplo3:
- - - - -
import pandas
data = {"x": [1, 2, 3, 4, 5], "y": [2, 4, 6, 8, 10]}
lista=['obs1','obs2','obs3','obs4','obs5']
df3=pandas.DataFrame(data=data, index=lista)    #Index sirve para cambiarle el nombre a nuestras filas en dataframe
df3

#Curiosidades
import pandas
data = {"x": [1, 2, 3, 4, 5], 
        "y": [2, 4, 6, 8, 10],
        "y2":[11,12,13,14,15]}
df=pandas.DataFrame(data=data,columns=['x','y','z'])    #Si a un dataFrame creado con un diccionario creado con un diccionario le ponemos el nombre de 								 una columna que no esta en el diccionario, este creara la columna pero sus valores seran NaN, 								 es sucede por que al usar un diccionario ya esta creado el nombre de cada columna, y con 								 columns solo harian referencia a las columnas que queremos ver(sirve como un filtrado)	      
df




Ejemplo4:
- - - - -
import pandas
data=[{'x':1,'y':2},
      {'x':3,'y':4},
      {'x':5,'y':6},
      {'x':7,'y':8},
      {'x':9,'y':10}]

df4=pandas.DataFrame(data=data)			#Como vemos siempre y cuando los datos que le demos sean rectangulares, pandas sabre interpredar los 							 datos que le pasemos, en este caso le pasamos una lista de columnas. 
df4					



Ejemplo5:
- - - - - 

import pandas
a=(1,2,3,4,5)
b=(2,4,6,8,10)
data=list(zip(a,b)) #Creamos una lista usando zip
df5=pandas.DataFrame(data=data, colums=['x','y'])   #Creamos nuestro dataFrame y como no tenia nombre, le damos un nombre con columns


--------------------------------------
Creando dataframes con .from_dict()  |
--------------------------------------
*Sirve también para crear dataframes, la diferencia esta que usa un atributo llamado orient que sirve para que cuando trabajemos con data=diccionarios, con oriento podremos cambiar de lo que son nombre para las columnas, seran nombre de las filas.

Ejemplo1:
- - - - -
import pandas
d={'x':[1,2,3,4],'y':[2,4,6,8],'z':[1,4,9,16],'w':[-1,-2,-3,-4]}
df=pandas.DataFrame.from_dict(data=d)        #Creara un dataframe
df                                      # Como vemos, sin orient no se ve ninǵun cambio si creasemos con DataFrame()


Ejemplo2:
- - - - -
d={'fila1':[1,2,3,4],'fila2':[2,4,6,8],'fila3':[1,4,9,16],'fila4':[-1,-2,-3,-4]}
df=pandas.DataFrame.from_dict(data=d,orient="index",columns=['x','y','z','w'])		#La clave de cada diccionario paso a ser el nombre de cada fila
df




---------------------------------
|  Dimensiones de un DataFrame	|
---------------------------------
df.shape			#Devuelve una tupla con valores, el primero corresponde al número total de filas, y el segundo al de columnas del data 					 frame df.


df.size					#Calcularemos el número total de valores que tiene nuestro datraframe df.
df.shape[0]*df.shape[1]=df.size		#df.size, representa al producto del total de filas y columnas


df.ndim				#Nos devolvera el número de dimensiones que tiene nuestro dataFrame, por lo general devolvera 2 ya que al iniciar 				         aprendiendo trabajaremos solo con Dataframes de 2 dimensiones, existen muchos dataframes con 3 				 dimensiones(Ejemplo:TensorFlow)



=================================
|	Subdataframes:		|
=================================
*Dado un dataframe, un subdataframe no es mas que la selección de unas filas y columnas en particular.
*Cuidado! extraer un subdaraframes, dependera de algúnas circunstancias.

columnas:
- - - - -
	-Indicando el nombre de la columna entre claudators, []
	-Con el metodo '.columns[]'
	-Con el metodo .loc (por nombre o etiqueta)
	-Con el metodo .iloc (Por posición)

	Ejemplos	:
- - - - -----------------
Sea:
fdata = {"Name": ["Alicia", "Bill", "Carlos", "Diana"],
        "Age": [22, 28, 19, 34],
        "Pet": [True, False, False, True],
        "Height": [157, 190, 175, 164],
        "Birthday": ["Mayo", "Junio", "Agosto", "Diciembre"]}

df=pandas.DataFrame(data=fdata,index=['obs1','obs2','obs3','obs4'])	#Aquí ya esta creado nuestro dataframe df

Ejemplo1
- - - -- 
#Forma1 de extraer una columna por el nombre

df['Birthday']		#Extraemos toda la información de esa columna con sus observaciones. también nos muestra una información adicional        				 'Name: Birthday, dtype: object', name al nombre del campo que extraimos, y object a su tipo de dato.

df[['Birthday','Age']]	#Para extraer de varias columnas, tendremos que poner el nombre de las columnas dentro de una lista.
			 #Se usa listas para extraer mas datos



Ejemplo2:
- - - - -
"Forma2 de extraer una columna con el metodo .columns[i]
df[df.columns[4]]	#df.columns devolvera el nombre de la columna de esa posición(inicia en 0), y luego sera igual que la forma1 


df.columns[i]		#Devuelve solo el nombre de la columna, recordad eso
df[def.columns[[i,j,k]]]	#para extraer de varios indices, esto lo indicamos como listas.
df[def.columns[[i:j]]]		#para extraer de varios indices, aquí usamos un rango de indices.



Ejemplo3:
- - - - -
#Forma3 de extraer una columna con el metodo .loc[]
df.loc[:, 'nombreColumna']	#Hay 2 formas. 1 Es poniendo el nombre de la columna.
df.loc[:, 'nomColumna1':'nomColumnax']	#Extraeremos todas las columnas desde nomColumna1-nomColumnax, incluyendo esta ultima.


df.iloc[:,i]			#Otra es poniendo el indice. Los : hacen referencia a que busque en todas las filas. '.iloc' es aquí 
df.iloc[:, i:j]			#Mostrara las columnas desde los indices i hasta j-1


-----------------------------------------
	Seleccionando filas:		|
-----------------------------------------
*Dado un dataframe, podemos seleccionar una fila en particular de diversas formas:
	-con el método .loc   (por nombre o etiqueta)
	-con el método .iloc  (por posición)


	Ejemplos:
- - - - - - - - - - - - - -
Sea: 
fdata = {"Name": ["Alicia", "Bill", "Carlos", "Diana"],
        "Age": [22, 28, 19, 34],
        "Pet": [True, False, False, True],
        "Height": [157, 190, 175, 164],
        "Birthday": ["Mayo", "Junio", "Agosto", "Diciembre"]}

df=pandas.DataFrame(data=fdata,index=['obs1','obs2','obs3','obs4'])


Ejemplo1:
- - - - -
df.loc['obs2']			#Nos mostrara solo la fila obs2 con su etiqueta(columna) de manera vertical


Ejemplo2:
- - - - -
df.iloc[-1]			#Nos mostrara la ultima fila.


*Para mostrar mas filas, tendremos que pasar listas. Para mostrar mas filas sigue la misma metodologia que para mostrar mas columnas, los mismos trucos vistos arriba.

*df.loc[:,:]	#Podemos interpretar lo siguiente, los 2 primeros : puntos hacen referencia a la cantidad de filas a mostrar,y los 2 : a las columnas. 
*df.iloc[:,:]	#Los mismo que .loc 

---------------------------
| Seleccionando elementos |
---------------------------
*Para seleccionar un elemento en concreto, hay que indicar la fila y la columna y lo podemos hacer de 2 formas:
	-Con el método .loc[] (Por nombre y etiqueta)
	-Con el método .iloc[] (Por posición)
	

	Ejemplos:
- - - - - - - - - - - - -

Ejemplo1:
- - - - -

print(df.loc['obs2','Age'])		#Nos devolvera el valor de esa posición

print(df.loc[1,1])			#Nos devolvera el valor de dicha posición


*Podemos jugar así, con todo lo que sabemos para mostrar filas y columnas, se mostrara la intersección. la intersección puede ser 1 elemento o muchos
o todo el dataframe, dependera de los parametros que pasemos.



-------------------------------------------------------
|		Bucles y Dataframes:		      |
-------------------------------------------------------
*Para iterar sobre las filas de un dataframe, podemos utilizar los metodos.
	- .iterrows()	:Para iterar el índice de cada fija junto al contenido de cada una.
	- .itertuples()	: Para obtener una tupla con toda la información de cada fila


*Para iterar sobre las columnas:
	- .iteritems : Para obtener el nombre de cada columna junto al contenido de la misma.
	- list(df): devuelve una lista con el nombre de todas columnas.	





	Ejemplos:
- - - - - - - - - - - - - - - -
Ejemplo1:
- - - - -

for i,j in df.iterrows():
    print("Índice de la fila: {} ,\n\nContenido de la fila:\n{}".format(i,j))		#'i' tomara el valor del indica de cada fila y 'j' el valor de 												su contenido(es decir, de todas las coulmnas.)
											j sera el contenido de las columnas en forma de vector.
Ejemplo2
- - - - -

for i in df.itertuples():								#'i' tomara el valor de toda la fila, sus elementos seran
	print("Contenido de la fila:\n{}".format(i), end="\n\n")			tuplas de 2 valores, el 1ro hace referencia al nombre de la 												columna(empiza por index, ya que es el nombre de las 												observaciones por defecto), y en el 2do el valor que 												corresponde a cada columna.


Ejemplo3:
- - - - - 

for i,j in df.iteritems():
	print("Nombre de la columna: {},\n\nContenido de la columna:\n{}".format(i,j),end="\n\n\n")




========================================================================
|	Los ficheros CSV y su papel en el análisis de datos	       |
========================================================================
CSV (Comma Separated Values) (Valores separados por coma)	
*Un fichero CSV es aquel donde la información se guarda separando los campos por ',' y cuando termina la fila separando por 'intro' 



- - - - - - - - - - - - - - - - - - - - - -
cagando csv desde la carpeta google drive:
- - - - - - - - - - - - - - - - - - - - - -


Dataframes a partir de archivos csv:
- - - - - - - - -- - - - - - - - - -
*Podemos guardar la información de un archivo csv en un dataframe usando la función. read_csv()
El archivo puede:
	-Estar guardado en nuestro directorio de trabajo
	-Proceder de una url




Desde directorio de trabajo (con Google Drive):
===============================================

from google.colab import drive			#Importamos la libreria google.colab para trabajar con el metodo drive
drive.mount('/content/drive')			

simpsons_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/DataSets/characters-simpsons.csv")	#Nos permite leer el archivo csv y crear un 														 datafram
simpsons_df.head()


*simpsons_df es el nombre del dataframe que estamos dando al leer el archivo csv y crear un dataframe
*Este código es para que nuestro colab tenga acceso a nuestro google drive.
*Conecta y monta google colab a nuestro google drive.


Cargando un CSV a partir de una URL:
====================================
letters_freq_df=pd.read_csv("https://people.sc.fsu.edu/~jburkardt/data/csv/letter_frequency.csv")  #Leemos y montamos el fichero csv como un dataframe 													   y lo igualamos a la variable letters_freq_df
letters_freq_df.columns=['Letra','Frecuencia','Porcentaje']			#Cambiamos el nombre de las columnas



*pd.read_csv()			#Es el que nos permite leer ficheroes csv tanto para archivos locales como para URLs.




-----------------------------------------
 Los ficheros JSON y su carga con pandas:
-----------------------------------------
*Podemos guardar la información de un archivo JSON usando el método .read_json()
El archivo puede:
	- Estar guardado en nuestro directorio de trabajo
	- Proceder de una URL


Desde un directorio de trabajo:(con Google Colab):
- - - - - - - - - - - - - - - - - - - - - - - - - 
*Para leer un fichero JSON se procede igual que con un CSV, se conecta el google colab con nuestro drive, y nuestro fichero desde estar ubicado en algúna carpeta de nuestro drive.


pd.read_json(url, orient="")		#Lee un fichero json y lo convierte en un dataframe de pandas, orient admite 3 valores 'index' 'columns' 						 'vaules'


Ejemplo1:
- - - - - 
import pandas as pd
quiz_index=pd.read_json("/content/drive/MyDrive/Colab Notebooks/DataSets/json_index_example.json",orient="index")
quiz_index          #Aquí usamos orient=index por que queremos que las claves del JSON pasen a ser los nombres de las filas




Ejemplo2:
- - - - -
quiz_column=pd.read_json("/content/drive/MyDrive/Colab Notebooks/DataSets/json_columns_example.json",orient="columns")
quiz_column         #Aquí usamos orient=columns por que queremos que las claves del JSON pasen a ser los nombres de las columnas





Ejemplo3:
- - - - -
quiz_values=pd.read_json("/content/drive/MyDrive/Colab Notebooks/DataSets/json_values_example.json",
                         orient="values")
quiz_values         #Cuando la información del JSON viene en listas (la más empaquetada posible)




--------------
Desde una URL:
--------------

quiz_url= pf.read_json("https://api.exchangerate-api.com/v4/latest/USD")


--------------------------------------------------------------------
|		Tratamiento de los datos faltantes		   |
--------------------------------------------------------------------
*Los datos faltantes, o en Inglés, Missing Data, se dan cuando no hay información para uno o más elementos.
*Este es un problema muy común en la vida real, en la librería *pandas*, identificamos los missing data con valores 
NA (Not Available) o NaN (Not a Number).
*Para indentificar valores faltantes de un dataframe de pandas, podemos usar los métodos .isnull() o notnull()

df.isnull()		#Muestra el datafram con True y False, True ira en los valores que son nulos.

df.notnull()		#Muestra el dataframe con True y False, True ira en los valores que no son nulos.


df.fillna(valor)	#Remplaza todos los valores NaN por el 'valor' que le pacemos por parametro. (no se autoguarda)
df.replace(valor,newvalor)	#remplaza todos los "valor" por los "newvalor"
df.replace(np.nan,newvalor)	#remplaza todos los valores NaN por los "newvalor"
df.interpolate()		#Sustituye los valores NaN por valores interpolados. Este metodo consta de muchos parametros para elegir el metodo(que 					 por defecto es 'linear') por el cual se lleva a cabo la interpolación.
				 (Es decir remplaza los valores NaN por la media aritmetica de sus costados)
df.dropna()			#Elimina las filas que tengan valores NaN (no se autoguarda)

==========================================
Metodos para tratar con valores faltantes:
==========================================
#Necesitaremos la libreria numpy para crear dataframe con valores NaN
import numpy as np

np.nan			#Sirve para crear valores NaN



==========================================
	Filtrando Dataframes	
==========================================
*Dado un dataframe podemos filtrar sus filas comprobando cuales satisfacen una condición.

df[df[nameColumn] 'condición' valor]	#Filtrara todas las filas cuya columna indicada cumpla la condición. 
		*El valor puede ser un valor del dataframe, un valor entero, string, etc.
		*La condición puede ser >, < ,==, cualquier tipo de operación que ya conocemos.

Ejemplo:
- - - - -
df[df[nameClumn] > 5]		#Filtrara y mostrara solo las filas de cuales la columna cumpla esa condición


*El metodo .query nos puede ser útil para este cometido, pero funciona únicamente cuando los valores de la columna no contienen espacios en blanco.

df.query('namecolum condición valor')		#filtarara y mostrara todas las filas cuyas columnas cumplan la condición.

df.querY('`name column ` condicion valor')	#usamos comillas invertidas para columnas que tengan de nombre 2 o más palabras.

Ejemplo:
- - - - -
df.query('Porcentaje > 5')

df.query('Porcentaje >5 and Porcentaje<=8')



===============================================
	Las series de pandas
===============================================
*Serie. Una Serie de pandas es como una columna de un dataframe.
*Podemos construir Series de pandas a partir de una lista unidimensional.


		Ejemplos:
- - - - - - - - - - - - - - - - - - - - - - - -
#
a=[1,2,3,4,5]
my_Series=pd.Series(a)      #Construye un vector de una columna con los elementos de la lista que le pasamos
my_Series                   #Veremos la columna series y sus observaciones(filas)
my_Series[1]                #Podemos ver un elemento a travez de los indices.


my_Series=pd.Series(a,index=['a','b','c','d','e'])  #podemos darle un nombre a sus observaciones.
my_Series

day={'day1':5,'day2':9,'day3':7,'day4':6,'day5':8}
my_series=pd.Series(day)                #Si creamos una serie a partir de un diccionario, las claves del diccionario pasaran a ser el
                           	 	 nombre de las filas y su valor el contenido de cada fila.

my_series



*Siendo nameDataFrame=df
=========================================================================
|		Metodos de dataframe					|
=========================================================================
*Representando df a cualquier namedataframe

df.head()			-->Sirve para mostrar las primeras filas del dataframe. Por defecto solo mostrara las 5 primeras filas.
df.head(valor)			-->Nos mostrara la cantidad de filas dependiendo al valor. Ejem: df.head(1) nos mostrara 1 fila
de.tail()			-->Sirve para mostrar las ultimas filas del dataframe por defecto.
df.tail(valor)			-->Nos mostrara las ultimas filas dependiendo al valor. Ejem: df.tail(2) nos muestra las ultimas 2 filas.

df2=df.copy()			-->Hace una copia del dataframe df , esto es útil por que esto si es una copia de df y no una referencia.

df.rename(columns={nameColumna1:nuevoNameColumna1			#Cambias el antiguo valor de la columna por la nueva.
		   nameColumna2:nuevoNameColumna2}
		   nameColumna3:nuevoNameColumna3...},inplace=True)	#implace igual a True para que los cambios se guarden en df, caso contrario 										 guardar en otra variableFrame. 

df.rename(index={nameFila1:newNamefila1
		 nameFila2:newNamefila2
		 nameFila3:newNamefila3...},inplace=True)		#Los mismo pero para las filas

df.rename(index={:},columns={:},inplace=True)		#Como vemos podemos hacer al mismo tiempo tanto para filas y columnas.


df.insert(loc=i, column='nameColumna',value=[lista])	#Insertaremos una nueva columna a nuestro dataframe,
							 'i' es el indice en el que insertaremos, 'nameColumna' nombre de la columna, [lista] los 								 valores que tendra nuestra columna insertada, debe ser igual cantidad que las otras columnas. 
							(Una vez hecho esto, se autoguarda)
*Si 'i' ya esta ocupado, las demás columnas se correran y esta ingresa. *Si a value, solo le damos 1 valor, todos los demás valores seran igual a esta.  						


df.drop(labels=[nombre1,nombre2],axis=0)	#Eliminara aquellas filas que se llamen nombre1, nombre2 . axis=0 hace referencia a la fila
df.drop(labels=[nombre1,nombre2],axis=1)	#Eliminara aquellas columnas que se llamen nombre1, nombre2 . axis=0 hace referencia a la columna.
						 (no se autoguarda) (si queremos que se autoguarde, agregamos el parametro "inplace=True"

df.dropna()				#Elimina todas las filas donde haya un valor que valga NaN. (No se autoguarda y no es recomendable ya que 						 perdemos mucha información)
 
df.pop('nameColumna')			#Elimina la columna que indiquemos por parametro. (se autoguarda). y devuelve la fila eliminada.
df2=df.pop('nameColumna')		#df2 guarda toda la información en forma de vector de la columna que eliminamos.

df['newColumn']=df2			#Agregamos una nueva columna con todo el valor vector que tiene df2.
df['newColumn']=valor			#Si no existe el nombre de la columna, lo agregara y todos los valores de esa columna sera iguales.

df.columns[i]=newvalor			#Cambia el valor de esa col

df.nsmallest(valor,'namecolumn')	#Nos devuelve las n filas con menor valor de la columna que indiquemos. Si valor=3
					 mostrara las 3 filas de menor valor de namecolumn. y lo ordena ascendentemente.

df.nlargets(valor,'namecolumn')		#Nos devuelve las n filas con mayor valor de la columna que indiquemos. Ordenandolo descendentemente
				         si valor=4. devuelve las 4 filas con mayor valor en la columna que indiquemos.

df.dtypes				#Nos devuelve un vector indicando que tipo de dato hay en cada columna.	


*Para iterar bucles con columnas o filas
		
list(df)				#devuelve una lista con el nombre de las columnas como elemento.
df.iteritems() 				#Para obtener el nombre de cada columna junto al contenido de la misma.	/for i in df.iteritems()
df.iterrows()				#Para iterar el índice de cada fija junto al contenido de cada una. / for i,j in df.iterrowrs()
df.itertuples()				#Para obtener una tupla con toda la información de cada fila	/for i in df.itertuples()
					 para acceder a cada elemento podemos usar el metodo de loso corchetes.

df.isnull()				#Muestra el datafram con True y False, True ira en los valores que son nulos.
df.notnull()				#Muestra el dataframe con True y False, True ira en los valores que no son nulos.

numpy.nan			#Sirve para crear valores NaN (necesitaremos la libreria numpy)

nameSeries.to_frame()		#Convierte un vector series en un dataframe.

nameSeries.tolist()		#Para convertir un vector series a tipo lista.

df[df[nameClumn] > 5]		#Filtrara y mostrara solo las filas de cuales la columna cumpla esa condición
df.query('namecolum condición valor')		#filtarara y mostrara todas las filas cuyas columnas cumplan la condición.

*Recuerda que si igualas una variable a una estructura de dato, esa variable es solo una referencia a la estructura de datos. si modificas la variable tambien estarias modifcando la estructura de datos. Esto es para ahorrar memoria.
*El tipo de objeto de type(df.loc['obs2']) es pandas.core.series.Series
======================================================================
			Metodos de pandas			     |
======================================================================
pandas.DataFrame()			#para crear Dataframes.
pandas.DataFrame(data= ,index= , columns= )
pandas.DataFrame.from_dict()		#para crear Dataframes pero con orient="index", las claves de los diccionarios seran nombre de filas.
nameDataframe.shape			#Devuelve una tupla con la cantidad total de filas y de columnas
nameDataframe.size			#Devuelve el total de datos, es multiplicar el total de filas*total de columas
nameDataframe.ndim			#Devuelve el total de dimensiones de nuestro dataframe.
nameDataFrame.head()			#Sino indicamos nos mostrara por defecto solo las 5 filas de nuestro dataFrame
nameDataFrame.set_index('nameColumn')	#Dicha namecolumn pasara a ser nuestras observaciones.
nameDataFrame.index.names=[None]	#Sirve para cambiar el nombre titulo de nuestras observaciones y lo autoguarda, si damos 'None' no mostrara 						 nada.

nameData['nameColumns']			#Nos devuelve toda esa columna con sus obs.
nameData[[]]				#Cuando queramos mostrar varias columnas con algúno de los metodos, tendremos que pasar listas.
nameData.columns[i]			#Nos devuelve el nombre de esa columna para ese indice
nameData[nameData.columns[i]]		#Nos devuelve toda esa columna para ese indice
nameData[nameData.columns[i:j]]		#Nos devuelve todas las columnas contenidas para ese indice

nameData.loc[:,'nameColumns']		#Nos mostrara todas las filas para esa columna
nameData.loc[:,'namColum1':'namColumN']	#Nos mostrara todas las columnas que esten en ese rango de nombres, incluyendo a los 2 extremos.	
nameData.iloc[:,i]			
nameData.iloc[:, i:k]			#Mostrara todas las columnas de los i hasta el indice j-1

list(nameDataFrame)			#la lista de un dataframe nos devuelve una lista con sus columnas.

nameData.loc['nameFila','nameColum']=newValor		#cambia el valor para esa intersección.	
nameData.iloc[valor,valor]=newValor			#cambia el valor para esa posicióm.

nameData.columns			#Nos devuelve una lista con los nombres de las columnas
nameData.columns=[lista]		#La lista debe tener la cantidad elementos como numero de columnas tenga el dataframe, cada elemento de la 						 lista remplazara al nombre de la columna, asi sucesivamente (cambia nombre a las columnas)

nameData.index				#Nos devuelve una lista con los nombres de las filas
nameData.index=[lista]			#La lista debe tener la cantidad elementos como numero de filas tenga el dataframe, cada elemento de la 					lista remplazara al nombre de la fila, asi sucesivamente (cambia nombre a las filas)

df.rank()				devuelve todas las posiciones sobre que corresponde a cada columna respecto a sus elementos.
df.['nameColumn'].rank()		#Devuelve sobre la columna indicada, las posiciónes de sus elementos ordenada alfabeticamente ascendente. El 						ranking Siempre empieza desde 1. 
					*Si las posiciones se repiten, suman sus posiciones y se dividen entre el total de repetidas.
					


df.['nameColumn'].rank(ascending=False) 	#Devuelve sobre la columna indicada, las posiciónes de sus elementos ordenada  alfabeticamente 							 descendente. El ranking, siempre empieza desde 1.


df['newcolumn']=df[namecolumn].rank()		#Añadira esa columna a nuestro dataframe.


df.nunique()					#Nos devuleve un vector con los valores únicos que hay para cada columna del dataframe
df['nameColumn'].unique()			#Nos devuelve una lista con los valores únicos de esa columna


		
df[nameColumn].duplicated(keep)		#Nos devuelve un booleano que nos indicara True según el valor que tenga keep (No se autoguarda)
	df2=df[nameColumn].duplicated(keep=False)#Aquí devuelve el booleano				
	df[df2]					#Nos mostrara para el caso de False solo los repetidos.

					#El metodo duplicated nos ayuda analizar los valores duplicados. El parámetro keep sirve para controlar	 como 						 proceder con los valores duplicados, keep=:
					 	-"firts": Considera la primera aparición del valor repetido como único y el resto como duplicados.
						-"last": Considera la última aparición como único y el resto como duplicados.
						-False: Considera todos los repetidos iguales como duplicados.
					
df.drop_duplicated(subset=nameColumn ,keep=)	#Sirve para eliminar los duplicados del dataframe. subset selecciona la columna, y keep funciona igual 							 que lo de arriba, con 'firts' eliminamos los demás menos el primero, co 'last' todos menos el último 							 y con False eliminamos todo. (No se autoguarda)





df.sorted_values('namecolumn',ascending=valorBool)	#para ordenar el dataFrame en base a la columna data y de forma ascendente o no.
df.sorted_values('namecolumn',ascending=valorBool,inplace=valorBool) #inplace indica que si queremos que los cambios se autoguarden

=================================================================================================================================================
|						Multiíndices en Pandas para Análisis de Datos							|
=================================================================================================================================================
*FrozenList([None])		#FrozenLista, indica indices congelados. 'None' indica que ningúna de las columnas se ha establecido que seran los 					 indicen del dataframe, esto lo hacemos con set_index('column')	recuerda que con esto pasabamos columnas para que 					 fueran nuestro indice







=======================================================================================================================================================
|					Sección 15: Tema13 - Programación orientada a Objetos							      |
=======================================================================================================================================================
CLASE:
------
*Una clase es una plantilla para crear objetos. Las clases contienen la definición de los objetos (sus carácteristicas).
*Un objeto es una instancia de una clase. 
	-Estado: Representado por los atributos del objeto, que reflejan su propiedad
	-Comportamiento: Representado por los metodos del objeto, que reflejan su resupuesta a otros objetos.
	-Identidad: Cada objeto tiene un nombre único que le permite interactuar con otros objetos.


Mi primera clase en python:
---------------------------
class Book():
	is_electronic=False	




book1=Book()			
type(book1)				#El tipo de dato de un objeto es __main__.clase
Book.is_electronic			#	
book1.is_electronic			#


*Para acceder a una variable estatica también podemos usar el nombre de la clase

-----------------------------------------
	el metodo constructor		:
-----------------------------------------

*Que es llamada cuando inicializemos una objeto de la clase.Por parametro puede recibir valores para los atributos de cada objeto.
*El constructor es llamado cada que usamos la clase(): 


class name():

	def __init__(self,a,b,...):		#Asi se construye el constructor de una clase. Los parametros que reciba nuestra clase al momento de 		  self.variable1=a			 crear un objeto se los pasar por aquí.	El primer parametro de un constructor es 'self' esta variable 		  	self.variable2=b			 significa uno mismo
						

objeto=name(a,b,...)			#Por como construimos nuestro construcctor, deberemos pasar la cantidad de parametros que espera recibir
					 sin contar el self(ya que esta hace referencia al objeto, en el que vamos a guardar estos atributos).
					 A no ser que los parametros del constructor ya tengan valores por defecto.


Ejemplo:
--------


clase Book():
	def __init__(self,a,b=5)
	    pass

libron=Book('c')				#como vemos, cuando un parametro ya tiene un valor por defecto no es necesario pasarle un valor a ese 							 parametro. Como vemos solo pasamos un valor



-----------------------------------------
	el metodo destructor		:
-----------------------------------------
*Asi como existe un método constructor, existe un metodo destructor cuyo contenido consiste en eliminar instancias de una clase. Es decir, elimina un objeto.
*Eliminar objetos una vez ya no lo vayamos a usar es útil por que nos ahorra memoria, ya que este seguira ejecutandose.
*EL metodo destructor es el metodo es el .__del__()
*usaremos la palabra reservada del


Ejemplo:
- - - -

class name():
	def __init__(self,..):
		pass
	def __del__(self):
		'''
		Podemos guardar el objeto en una base de datos, fichero, hacer una copia, mostrar un mensaje, etc. antes de que sea destruido
		'''

book=name(...)			


del book			#Usamos del para eliminar el objeto, antes de que este se elimine se ejecutara su comportamiendo del que tiene.


-------------------------------------------------------------------------
			Métodos de una clase				:
-------------------------------------------------------------------------
Existen 3 tipos de metodos:
	-Métodos de instancia
	-Métodos estáticos
	-Métodos de clase


Metodos de instancia:
---------------------
*Siempre toman el parametro self como primer párametro.
*El párametro self representa la instancia del método. Lo que hace python es pasar el propio objeto como argumento del método.

Ejemplo:
- - - -

class name():
	def __init__(self...):
		pass
	def metodo1(self...)
		pass
		return	...
	def metodo2(self...)
		pass	
		return ...


	def __str__(self,...)
		pass
		return ...


book=name(...)			#Se contruye el objeto book
book.metodo1(...)		#Se llama a su metodo 'metodo1'


*el método .__str__(self,...)	es un metodo de instancia. Es el metodo que debe ser llamado cuando el objeto se representa como un strin.
Es decir, lo que este método devuelve es lo que se muestra cuando hacemos un print del objeto en cuestión.
*Es lo que se muestra cuando usamos el objeto y no llamamos algún comportamiento o atributo.




Metodos estaticos:
------------------
*A diferencia de los metodos de instancia, los métodos estáticos no pasan como párametro el argumento posicional 'self'. Los métodos estáticos se definen usando el decorador '@staticmethod', que se añade antes de definir el método estático respectivo.
*Los decoradores nos permiten alterar el funcionamiento de de las funciones o clases. Son utilizados para guardar utilidades relacionadas con la clase.


Ejemplo:
--------
class Rectangle():

  def __init__(self, base = 1, height = 1, color = "blue"):
    self.base = base
    self.height = height
    self.color = color
  
  def perimeter(self):
    return 2 * self.base + 2 * self.height

  def area(self):
    return self.base * self.height

  def is_base_big(self, min = 5):
    if self.base > 5:
      return True
    return False

  def __str__(self):
    return ("Base: {}\nAltura: {}".format(self.base, self.height))

  @staticmethod							#Aquí definimos que el metodo de abajo sera estatico
  def are_equal_size(rect1, rect2):				#Este metodo sera estatico, por lo tanto no necesita de self
								  
    if rect1.base == rect2.base and rect1.height == rect2.height:		
      return True
    return False


rect1=Rectangle(7,5,"green")
rect2=Rectangle(3+4,7-2,"blue")

print(rect1,"\n")
print(rect2,"\n)
print(Rectangle.are_equeal_size(rect1,rect2))		#Como vemos aquí, no necesitamos de un objeto para llamar al metodo estatico. De parametro
							 le pasamos los 2 objetos




Metodos de clase:
-----------------
*La carácteristica de estos métodos es que la clase entera es pasada como primer argumento, cls. Para los metodos de clase vuelve a usarse un decorador
@classmethod

Ejemplo:
- - - - -
import random
class Rectangle():

  def __init__(self, base = 1, height = 1, color = "blue"):
    self.base = base
    self.height = height
    self.color = color
  
  def perimeter(self):
    return 2 * self.base + 2 * self.height

  def area(self):
    return self.base * self.height

  def is_base_big(self, min = 5):
    if self.base > 5:
      return True
    return False

  def __str__(self):
    return ("Base: {}\nAltura: {}".format(self.base, self.height))

  @staticmethod
  def are_equal_size(rect1, rect2):
    if rect1.base == rect2.base and rect1.height == rect2.height:
      return True
    return False

  @classmethod						#Indicaremos que construiremos abajo un metodo de clase
  def random_rectangle(cls):				#'cls' indica cualquier clase
    base=random.randint(1,10)
    height=random.randint(1,10)
    
    return cls(base,height)

rect3=Rectangle().random_rectangle()
print(rect3)






=============================================
		Propiedades		    |
=============================================
*Para manejar los atributos de un objeto, podemos utilizar el decorador '@property' que permite a un método ser accedido como un atributo,
omitiendo así el uso de paréntesis vacios.
	!Ojo¡ los paréntesis son vacios cuando no hay parametros que indicar.


*Estos pasarana ser como atributos pero de solo lectura, no se les puede modificar su valor como si fuesen un atributo variable.	


Ejemplo :
- - - - -
#Del ejercicio anterior, en la clase Rectangle agregamos @property para convertir esos metodos en atributo.
 @property
  def perimeter(self):
    return 2 * self.base + 2 * self.height

  @property
  def area(self):
    return self.base * self.height



*Para modificar una propiedad de lectura, necesitaremos el método '.setter()'
*Como lo dice arriba, solo se puede aplicar .setter sobre métodos que hayan sido transformados en propiedad. (solo sobre propiedades por así decirlo)


Ejemplo :
- - - - -
  @property						#definimos este metodo como un atributo
  def complete_name(self):								
    return "{} {}".format(self.name, self.surname)		

  @complete_name.setter					#utilizamos '.setter' sobre el metodo que queremos que se pueda modificar recibiendo valores.
  def complete_name(self, name_surname):		#name_survanme recibira el valor asignado
    name, surname = name_surname.split(" ")		#usamos un split para obtener 2 elementos de una lista y lo desempaquetamos en 2 variables
    self.name = name					#igualamos los nuevos valores
    self.surname = surname
							
person1=Person('Kevin','Dax')
person1.complete_name='Mario Luis'
person1.complete_name

*Ahora nuestro metodo tendrá la propiedad de escritura y lectura, una vez se haya terminado de escribir, pasara a leer con los nuevos cambios aplicados sobre su propiedad de lectura. 


Ejemplo 2:
- - - - - -
class Circle():

  def __init__(self, center = (0, 0), radius = 1):
    self.center = center
    self.radius = radius

  @property
  def diameter(self):
    return 2 * self.radius

  @diameter.setter
  def diameter(self, value):
    if value <= 0:
      raise ValueError("El diámetro no puede valer menor o igual a 0")  #raise muestre un error
    self.radius = value / 2
  

===================================================
		Herencia de clase		  |
===================================================
*Permite que los atributos y metodos de una clase sean pasada a otra.
*Esta clase permite a los atributos y metodos ser pasados de una a otra. Es útil cuando ya existe una clase que hace todo lo que necesitamos, a la cúal querriamos añadair algún atributo o método extra.

*las clases hijas heredan atributos o metodos de la clase madre.


----------------------------------
	herencia simple		 |
----------------------------------
*Implica crear clases hijo que heredan atributos y métodos de una sola clase padré. 
*La clase que esta por encima de ellos también se le conoce como super clase.
*Dato la clase object es la principal, todas heredan de ella.

syntaxis:
---------
Sea: boy, adult y person clases. 


class person()
	atributos y metodos	#tenemos nuestra clase person con sus metodos y atributos


class boy(person):		#indicamos que la clase boy heredara todos los metodos y atributos de la clase person
	atributos y metodos	#a parte tendra sus propios metodos y atributos.
		
class adult(person)		#indicamos que la clase adult heredara todos los metodos y atributos de la clase person
	atributos y metodos	#a parte esta clase tendrá sus propios metodos y atributos.

*cuando usamos un metodo que no esta por ejemplo en la clase adult, python lo que hara es subir un rango mas y subir a su clase padre, y si no lo encuentra seguira subiendo.

*De este modo, la lógica del .__init__() solo se especifica una vez, haciendo mucho más sencillo el modificarlo en un futuro desde la clase padre. Del mismo modo, también sera mas sencillo crear subclases diferentes de la clase person. Además también es posible crear subclases de la ya subclases children, como por ejemplo teenager dependiendo del rango de edad dentro del intervalo [0,18>

*Se pueden crear inmensas estructura de clases.

Ejemplo1:
- - - - -

class Person(object):		#Definimos nuestra clase person que hereda de object (ya que todos heredan de ella)(por eso es que no es necesario 					 ponerla). Esta sera nuestra clase padre ya que las otras clases también seran personas

  def __init__(self, name, surname, age):
    self.name = name
    self.surname = surname
    self.age = age

  @property
  def complete_name(self):
    return "{} {}".format(self.name, self.surname)

  @complete_name.setter
  def complete_name(self, name_surname):
    name, surname = name_surname.split(" ")
    self.name = name
    self.surname = surname



class Children(Person):		#creamos nuestra clase niño que hereda las propiedades y metodos de la clase padre person
  is_adult = False



class Adult(Person):		#creamos nuestra clase adulto que hereda las propiedades y metodos de la clase padre person.
  is_adult = True



child = Children("Juan", "Sánchez", 6)		#definimos nuestro objeto children. los parametros se lo pasara al constructor de la clase padre ya que
						 children no tiene un constructor.
child.name



*Así como hemos heredado de la clase que hemos creado, person, podemos heredar de una clase ya existente en python, como por ejemplo la clase int.

Ejemplo :
- - - - -
class MyInt(int):				#por ejemplo creamos una clase MyInt que hereda de la clase ya existente int
  def is_divisible_by(self, divisor):
    return self % divisor == 0


n=MyInt(27)					#Int ya tiene un constructor que hace la conversión para que n sea 27.
n.is_divisible_by(9)				#ya al metodo is_disible... y efectua la operación, return 27%9==0 , return True
					


-----------------------------------------
	Sobreescribiendo métodos	:
-----------------------------------------
*Con las herencias de clases, no solo podemos extender el comportamiento de clases más generales, sino que también podemos modificar algunos atributos o métodos heredados de la clase padre.

Ejemplo:
--------
class Person(object):					#tenemos nuestra clase padre person (object se pone como buena practica), nuestra clase 
							 tiene sus propios atributos y metodos.

  def __init__(self, name, surname, age):
    self.name = name
    self.surname = surname
    self.age = age

  @property
  def complete_name(self):
    return "{} {}".format(self.name, self.surname)

  @complete_name.setter
  def complete_name(self, name_surname):
    name, surname = name_surname.split(" ")
    self.name = name
    self.surname = surname


class SecondNamePerson(Person):				#creamos una subclase de person, y nosotros queremos modificar el comportamien de algúnos 								 metodos de la clase padre
  
  @property						#Hacemos un metodo igual a la que haya en la clase padre, lo hacemos una propiedad de esta 
  def complete_name(self):				clase
    return "{} {}".format(self.name, self.surname)

  @complete_name.setter					#luego procedemos a que esta clase acepte modificaciones en base a la clase SecondNamePerson
  def complete_name(self, names_surname):
    names = names_surname.split(" ")
    self.surname = names[-1]
    if len(names) > 2:
      self.name = " ".join(names[:(len(names)-1)])
    elif len(names) == 2:
      self.name = names[0]




person2 = SecondNamePerson("Juan", "Gomila", 32)	#Creamos nuestro objeto person2 de clase secondNamePerson
person2.complete_name = "Juan Gabriel Gomila"		#modificamos sus valores, aquí se llamara primero al metodo de la clase en la que creamos.
print(person2.name)					 por eso podemos verlo como sobreescribir metodos.
print(person2.surname)


----------------------------------
	El método .super	 |
----------------------------------
*Nos sirve para acceder a un metodo de la clase padre a la cual estamos sobreescribiendo. Es decir nos permite utilizar todo el contenido de ese metodo de la clase padre aún asi lo estuviesemos sobreescribiendo.

Ejemplo1:
- - - - -
class Person(object):

  def __init__(self, name, surname, age):
    self.name = name
    self.surname = surname
    self.age = age

  @property
  def complete_name(self):
    return "{} {}".format(self.name, self.surname)

  @complete_name.setter
  def complete_name(self, name_surname):
    name, surname = name_surname.split(" ")
    self.name = name
    self.surname = surname
  
  @property
  def introduction(self):
    print("Hola, mi nombre es {}".format(self.complete_name))

class TalkativePerson(Person):
    @property
    def introduction(self):
        #print("Hola, mi nombre es {}".format(self.complete_name))	#Forma1(no recomendada): sobre escribimos a lo bruto sin reciclar nada  
        super().introduction						#Forma2: utilizamos lo que ya hay en la clase padre para este mismo metodo
        print("Un placer conocerte")					#agregamos cosas extras al metodo si gustamos.


persn1=TalkativePerson('Kevin','Victorio',29)
persn1.introduction					#Nos imprimira lo que llame el super y lo demás que tenga introduction


Ejemplo2:
- - - - -

class Point2D(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return "({}, {})".format(self.x, self.y)

    @classmethod
    def zero(cls):
        return cls(0, 0)

class Point3D(Point2D):
    def __init__(self,x,y,z):
        super().__init__(x,y)
        self.z=z


    def __str__(self):
        return super().__str__()[:-1]+", {})".format(self.z) 

    @classmethod
    def zero(cls):
        return cls(0,0,0)

point=Point2D.zero()
ppoint=Point3D.zero()
ppoint=Point3D(4,5,-1)
print(ppoint)


----------------------------------------------------
		HERENCIA MULTIPLE	       	   |
----------------------------------------------------
*Implica crear clases hijo que heredan atributos y metodos de múltiples clases padre.

Ejemplo :
- - - - -
class Person(object):                                   #Creamos la clase Person

  def __init__(self, name, surname, age):
    self.name = name
    self.surname = surname
    self.age = age

  @property
  def complete_name(self):
    return "{} {}".format(self.name, self.surname)

  @complete_name.setter
  def complete_name(self, name_surname):
    name, surname = name_surname.split(" ")
    self.name = name
    self.surname = surname
  
  @property
  def introduction(self):
    print("Hola, mi nombre es {}".format(self.complete_name))

class Adult(Person):                                    #Creamos la Adult que hereda de Person
  is_adult = True


class Calendar(object):                                 #Creamos la clase Calendar

  @staticmethod
  def new_event(title, day, hour, duration = "All day"):
    print("Reservado el día {} a las {} durante {} para {}".format(day, hour, duration, title))



class Bussinessman(Adult,Calendar):                 #Creamos una clase que heredara de Adult(Que esta a su vez hereda de Person) y Calendar  

    pass                   			    #pasamos por que no queremos implementar nada


bussinessman = Bussinessman("Manuel", "Gómez", 38)              #Creamos el objeto bussinessman
bussinessman.introduction                                       #llamamos a este metodo propiedad(de la clase padre de padre de Bussinessman)
Bussinessman.new_event("Reunión", "30 de Septiembre", "16:30", "2 horas")       #llamamos a este metodo de la clase padre llamada Calendar.
	



---------------------------------------------------------------------------------
|		El metodo super() en multiple herencia.				|
---------------------------------------------------------------------------------
*Si ninguna de las clases padres tiene algún metodo con el mismo nombre, entonces no hay problema. No obstante, si nos encontramos en el caso contrario, donde hay uno o más métodos con el mismo nombre en ambas clases, entonces el método que va a ser usado al llamarlo con el método .super()
es el perteneciente a la primera clase padre del cual se hereda.
*Es decir si ambas clases tienen un metodo o atributo con el mismo nombre, se heredara solo del primer padre. El orden de jerarquia es de izquiera a derecha al heredar clases.

*Esto no solo ocurre cuando usamos el método .super(), sino también cuando queremos acceder a un método cuyo nombre está presente en más de una clase padre.


Ejemplos:
- - - - -
class ClassA():					#Creamos la clase claseA

  def say_letter(self):
    print("Mi letrita es la A")

  
class ClassB(): 				#Creamos la clase claseB
  
  def say_letter(self):
    print("Mi letrita es la B")

class ClassAB(ClassA, ClassB):			#Creamos la clase que hereda la claseA y claseB

  def my_letter(self):
    print("A pesar de que heredo las letras A y B (así lo indica mi nombre)")
    super().say_letter()			#El super() invocara al metodo say_letter() de la primera clase

ab = ClassAB()					#creamos el objeto
ab.my_letter()					#aquí vemos que super() solo hereda de la primera clase A cuando se repiten metodos


class ClassAB(ClassB, ClassA):		

  def my_letter(self):
    print("A pesar de que heredo las letras A y B (así lo indica mi nombre)")
    super().say_letter()



ab = ClassAB()
ab.my_letter()
ab.say_letter()					#corroboramos que si una clase hereda de otras y en las otras hay metodos que tienen el mismo nombre,
						 los metodos que se heredan sera de la primer clase padre que hayamos pasado. 



curiosdad:
- - - - -
*si existen 2 clases en un programa con el mismo nombre, al momento de crear el objeto para dicha clase, el programa sera un objeto de la ultima clase
EJemplo:
-------
class A:
    a=5

class A:
    b=3

a=A()			#toma el valor de la clase A ultima
a.b			#existe por que 'b' es propiedad de la clase A ultima		
a.a			#no existe por que 'a' no es propiedad de la clase ultima



class A(A):		#también podemos hacer que una clase se autollame, tomara todas las propiedades que tiene.(tomara las propiedades de la clase
			 que este arriba de ella)



Ejemplo2:
---------
class A:
    a=5

class A(A):		#esta de la que esta arriba
    b=3

class A(A):		#esta clase hereda de la que esta arriba
    c=2

a=A()			#el objeto entonces hereda todos los atributos de la clase A

a.a
a.b
a.c

-------------------------------------------------
|		POLIMORFISMO			|
-------------------------------------------------
*Pofimorfismo signififca que una función con el mismo nombre se utiliza para diferentes tipos de objeto.
*Un ejemplo perfecto es la función len() que sirve tanto para objetos de tipo string como listas,etc.

Ejemplo:
--------
class Spain(): 
    def capital(self): 
        print("Madrid es la capital de España") 
  
    def language(self): 
        print("En España se habla el español") 

  
class Portugal(): 
    def capital(self): 
        print("Lisboa es la capital de Portugal.") 
  
    def language(self): 
        print("En Portugal se habla el portugués") 

  
spain = Spain() 
portugal = Portugal() 
for country in (spain, portugal): 			#iteramos para que contry sea cada clase, y ver que contiene esos mismos metodos para 								 diferentes clases 
    country.capital() 
    country.language()
    print("") 


*La idea del poliformismo es entender que hacen metodos del mismo nombre en diferentes clases.



---------------------------------------------------------------------------------------------------------
			VARIABLES PRIVADAS EN PYTHON: LA TECNICA DEL MANGLING				|
---------------------------------------------------------------------------------------------------------
*Es añadir privacidad a unas variables, para que no puedan ser modificadas desde el exterior.
*Tampoco podran ser accedidos desde la clase padre a un hijo o de un hijo a su padre.

Ejemplo 1:
- - - - - -
class A:                    #Creamos una clase, ya que no va recibir parametros podemos no poner la parentesis
    def __init__(self):     #Creamos el constructo
        self.__var=123          #Creamos un atributo privado, que no podra ser accedido desde el exterior
                                #los __ delante de la variable indican eso, que la variable sera privada
                                # __ se les conoce como la tecnica del mangling
        self.name="Kevin Dax"

    def printVar(self):
        print(self.__var)
        print(self.name)

    def __printName(self):      #el manglin hace lo mismo, hara que nuestro metodo sea privado 
        print(self.name)




Ejemplo 2:
- - - - - -
class Info:
    def __init__(self,iterable):
        self.list=[]
        self.__generator(iterable)      

    def generator(self,iterable):       #
        for i in iterable:
            self.list.append(i)


    __generator = generator     #hacemos que este atributo estatico privado '_generator' sea igual al metodo de instancia 'generator'

class InfoSubclass(Info):
    def generator(self,keys,values):
        for item in zip(keys,values):
            self.list[item]


a=[4,2,3,4,5]
mus=InfoSubclass(a)

#cuando llamemos a self.list este llama a su vez al generator privado de esta clase. Si no fuera así llamaria al metodo generator del hijo
#este es un caso de mas complejo de como nos ayuda a usar el manglin



		


			
=====================================================================================================
					METODOS DE CLASES					    |
=====================================================================================================
nameObjeto.__dict__			#Nos permite acceder y mostrar todos los atributos de un objeto y a los valores que tiene asignados en forma
					 de diccionario. 
del nameObjeto
def __str__(self,...)









=======================================================================================================================================================
|					Sección 16: Tema14 - Scripts y Módulos en Python							      |
=======================================================================================================================================================
	Scripts		
-------------------------
*Es un archivo que contiene lineas de código. En nuestro caso, dichas lineas estarán escritas con el lenguaje de programación python.
*Un script de python tiene la extensión '.py'.
*Para ejecutar un script de python necesitamos un interprete como bien puede ser spyder, jupyter, google colab,...etc. pero para crearlos nos basta un editor de código como por ejemplo Text editor.


	Creando un scripts de python:		
------------------------------------------------
*En primer lugar, para trabajar con scripts desde google drive necesitaremos la aplicación gratuita 'Text Editor' que se consigue en link de la chrome web store.
*Creamos nuestro scripts y lo subimos a nuestro drive.
*montamos (como hicimos al leer archivos csv, json) conectando nuestro google colab con nuestro drive. O sino ejecutamos el código de abajo
		from google.colab import drive
		drive.mount('content/drive')


Ejemplo:
- - - - -
%cd /content/drive/MyDrive/Colab Notebooks/Mis Scripts  			
#esta linea es de bash,cmd, etc. No puede ir comentarios en la misma linea por que son lenguajes diferentes.
#Le indicamos a colab que nos cambie y nos situe en ese directorio
#Una vez estemos situados en ese directorio podremos acceder directamente a nuestros scripts.

import my_first_scripts		#ahora solo nos queda usar 'import' luego el nombre de 'nuestro scripts'. Listo nuestro scripts esta importado

*¡Cuidado! Si realizas algún cambio en el script, no bastara con guardarlo y volver a importar el scripts, habrá que reiniciar el kernel y volver a ejecutar todas las lineas de código anteriors: desde la vinculación de google drive a nuestro notebook hasta la importación del script.
*Esto sucede por que el scripts ya esta guardado en el kernel.




Módulos:
--------
*Es una librería de código. Es un script que contiene un conjunto de funciones.
*Un módulo de python, al ser un script, tiene la extensión '.py'
*Para ejecutar un módulo de python necesitaremos seguir los mismos pasos que cuando trabajamos con scripts
*Podemos decir también que un módulo es un script que contiene a otros scripts.


Creando un módulo:
------------------
*Hemos dicho que un módulo es un script que contiene funciones. Por tanto, lo primero que hacemos es crear un nuevo documento con text editor. al que llamaremos my_first_module.py

Ejemplo:
--------
%cd /content/drive/MyDrive/Colab Notebooks/Mis Scripts  
#Le indicamos a colab que nos cambie y nos situe en ese directorio
#Una vez estemos situados en ese directorio podremos acceder directamente a nuestros scripts.

import my_first_module              #una vez importado el modulo podremos usar sus metodos y propiedades.

my_first_module.description()       #para acceder a sus metodos, se usa de la siguiente forma 'nameModulo.nameMetodo'
total_sum=my_first_module.sum(1,2,3,4,5,6,7,8,9,10)
total_prod=my_first_module.prod(1,2,3,4,5,6,7,8,9,10)
print("\nEl resultado de la suma ha sido {} y el del producto, {}".format(total_sum,total_prod))



renombrando módulo:
-------------------
import 'nameModulo' as 'aliasname'			#la palabra reservada 'as' nos permite renombrar el nombre de nuestro módulo para que cuando 								 trabajemos con el nos sea mas comodo


Variables en un módulo:
-----------------------
*Hasta ahora solo hemos visto como acceder a funciones de un módulo, per los módulos también pueden contener variables. Añadamos a nuestro módulo las 2 siguientes lineas de código:


Ejemplo:
import my_first_module as mfm
mfm.sum1to10					#utilizamos sus propiedades (variables) de ese módulo
mfm.prod1to10					#utilizamos sus propiedades (variables) de ese módulo



*Si recordáis, cuando vimos la función import, observamos que no era necesario importar todo el módulo, sino que podíamos importar funciones o incluso variables concretas del módulo con la sintaxis siguiente, y asi evitar tener que indicar el nombre del módulo previo al nombre de la función o la variable en cuestión.

Ejemplo:
--------

from  my_first_module 	import  sum1to10, prod1to10 			#de modo que ahora para invocar a esas variables lo haremos así

sum1to10								#como observamos ya no necesitamos el nombre del módulo
prod1to10								# " ", aplica también para funciones, etc. 



*Finalmente, así como podemos modificar el nombre de los módulos, también podemos modificar el nombre tanto de las funciones como de las variables del módulo:

Ejemplo:
--------

from 'my_first_module' import 'description' as 'mfm_desc'	#llamamos al metodo del modulo y lo renombramos como 'mfm_desc'



----------------------------------------------------
		Modulos de pyton
----------------------------------------------------
*Python es un software libre que de por sí ya tiene muchos módulos creados que nos son de mucha utilidad.
*Tenemos como por ejemplo a:
	-pandas :para trabajar con dataframes
	-math: para trabajar con funciones y variables matemáticas
	-numpy: para trabajar con elementos númericos.
	-matplotlib : para hacer representaciones gráficas

!y muchos más!



función dir():
--------------
*la función dir(nameScript) aplicada a un script nos devuelve los métodos y variables que contiene definidas.
*Si le aplicamos a nuestro módulo, al que recordad habiamos nombrado como mfm, lo que obtendremos es la siguiente lista de métodos y variables.

dir(mfm)


*Se nos mostraran metodos creados por nosotros y metodos que ya han sido creados por defecto por python, como son por ejemplo: 
	__doc__
	__cached__
	__name__
	__package__
	__init__

*Ahora entendemos el porque los modulos, metodos, clases aceptaban esos métodos que por mas que no lo hayamos definido se podian usar.
*En el caso de módulos tenemos cargar primero los script y luego aplicar el dir()

*curiosidad:
		.__file__ 	#nos devuelve el path donde esta guardado el módulo.

Ejemplo:
import pandas

pandas.__file__			#nos devuelve donde esta ubicado el script pandas. (respecto a donde estemos trabajando). Por ejemplo si trabajamos
				 en colab, nos mostrara el path de colab, si trabajamos en nuestro directorio, nos mostrara el path de nuestro 
				 directorio.



=======================================================================================================================================================
|					Sección 17: Tema15 - Módulos de pytohn: math y cmath							      |
=======================================================================================================================================================
*El módulo math nos proporciona funciones matemáticas según los estandares del lenguaje de programación 'c'. 
*!Cuidado¡  las funciones del módulo math no puede ser usadas con números complejos. Para trabajar con números complejos tenemos el módulo 'cmath'.

import math				#importamos todos los metódos, clases, atributos del módulo math.


-----------------------------------------------------
		MODULO MATH
-----------------------------------------------------

*constantes de math------------------------------------------------------------------------
math.pi			3.141592...		--> número pi
math.e			2.718281...		--> número aureo
math.tau		6.283185...		--> número tau (es el doble de pí)
math.inf		+∞			--> número infinito positvo
-math.inf		-∞			--> número infinito negativo (infinito no es número, es un concepto)
math.nan		nan			--> valor (NaN), valor no identificado


*parte enter de un número-------------------------------------------------------------------
math.floor(x)		n<=x<n+1		--> devuelve el maximo entero de x, nos devuelve el anterior o igual que x
math.ceil(x)		x<=n	 		--> devuelve el mayor entero por exceso como el menor número mayor o igual que x.
						     nos devuelve el mayor entero o igual que haya sobre x.
math.trunc(x)					--> Nos devuelve el número truncado su parte decimal, es decir, nos devuelve solo la parte entera


*Aritmetica---------------------------------------------------------------------------------
math.fmod(x,y)		módulo de X y Y		--> nos devuelve el resto de la división de x,y. es más preciso con los decimales que si usaramos %
math.fsum(lista)	duelve la suma		--> de los elementos de la 'lista'. Es mas preciso que usar sum() cuando los elementos de nuestra 							    lista tienen valores flotantes.		
math.modf(x)		(parteDecimal,parteEntera)	--> devuelve una tupla de la parte decimal y la parte entera


*potencia y logaritmo-----------------------------------------------------------------------
math.exp(x)		e^x			--> nos calcula 'e' a la 'x'. x viene a ser el exponente.
math.expm1(x)		e^x-1			--> este método existe para tener mas precisión y evitar los errores que con lleva restar 1.
						    este método es muy utilizado en el mundo del cálculo númerico.
math.frexp(x)		(m,i)			--> devuelve una tupla con la mantiza y el exponente. de:   x = m * 2^i
						    de ahí obtenemos el valor de m y e
						*Dato: Esto es lo que en verdad se guaradara en la memoria cuando asignamos un valor a x
						 ya que tiene que guardarlo en formato de 64bits.
math.ldexp(x,i)		y=x*2^i			-->nos devuelve el valor de 'y'. Donde 'x' es la mantiza e 'i' el exponente.


*logaritmo------------------------------------

math.log(x)					-->calcula el logaritmo de x con base 'e'
math.log(x,y)					-->calcula el logaritmo de x con base 'y'
math.log1p(x)					-->devuelve el logarimo neperiano de 1+x. La existencia de este método aumenta la precisión
						   cuando el logaritmo de x es proximo a 0.

math.log2(x)					-->calcula el logaritmo de 'x' en base '2' 
math.log10(x)					-->Calcula el logaritmo de 'x' en base '10'
math.pow(x,y)		x^y			-->nos calcula la potencia de 'x' a la 'y', es mas preciso que utilizar '**'. sobre todo con flotantes.
math.sqrt(x)					-->nos devuelve la raiz cuadrada de 'x'. 



*Teoria de números-------------------------------------------------------------------------------


math.abs(x)				-->devuelve el valor absoluto de 'x'.
math.fabs(x)				-->devuelve el valor absoluto de 'x' pero con má presición float.

math.gcd(x,y)				-->gcd(greatest common divisor): Calcula el MCD(máximo común divisor) de 2 números pasados por parámetro
math.lcm(x,y)				-->lcm(least common multiple): Calcula el mcm(mínimo común múltiplo) de 2 números pasados por parámtero
					   (Pero solo esta disponible desde la versión 3.9 hacia adelante)



*METODOS COMBINATORIA
--------------------------------------------------------------------------------------------
math.factorial(x)	x!			--> Calcula el factorial del valor que le pasemos por parametro.
math.comb(x,y)		x!/(y!*(x-y)!)		--> Calula el combinatorio de un número 'x' formado de 'y' en 'y'.
						   (tener cuidado por que este método ya no forma parte de math en las nuevas versiones de python) 



*METODOS VALOR ABSOULTO Y SIGNO
------------------------------------------------------------------------------------------
abs(x)						-->devuelve el valor absolut de x
math.fabs(x)		|x|			--> Devuelve el valor absoluto de un número
math.copysign(x,y)				--> Devuelve el valor abosulto del primer parametro pero luego se le agrega el signo del segundo 							    parametro.





*METODOS FUNCIONES TRIGONOMETRICAS
--------------------------------------------------------------------------------------------
math.radians(x)				--> Se le pasa un valor sexagesimal por parámetro y devuelve su equivalente en radianes
math.degrees(x)				--> Se le pasa un valor en radians por parametro y devuelve su equivalente en sexagesimal.

math.sin(x)				--> Calcula el seno del angulo que le pasemos (estara en radianes el angúlo)
math.cos(x)				--> Cácula el coseno del ángulo que le pasemos en radianes.
math.tan(x)				--> Cálcula la tangente de 'x'

math.asin(y)				--> Cálcula el arcoseno de 'y'. (devuelve el ángulo del cúal su seno es 'y')
math.acos(y)				--> Cálcula el arcocoseno de 'y'.
math.atan(y)				--> Cálcula el arcotangente de 'y'.

math.atan2(x,y)				--> Cálcula el ángula que forman los vectores 'x' e 'y' (ambos parten del origen)

math.hypot(x,y)				--> Cálcula la hipotenusa para esas 2 coordenadas (en el caso de un vecto bidimensional, cálcula su norma)



*METODOS PARA FUNCIONES HIPERBÓLICAS
------------------------------------------------------------------------------------
*De nuevo, los parametros que le pasemos se encontraran en radianes.


math.sinh(x)				-->Cálcula el seno hiperbolico de x, es decir cálcula lo siguiente (e^x - e^(-x))/2
math.cosh(x)				-->Cálcula el coseno hiperbolico de x, es decir cálcula lo siguiente (e^x + e^(-x))/2
math.tanh(x)				-->Cálcula la tangente hiperpolica de x, es decir cálcula lo siguiente (e^x - e^(-x))/(e^x + e^(-x))

math.asinh(y)				-->Cálcula el arcoseno hiperbólico de 'y'
math.acosh(y)				-->Cálcula el arcocoseno hiperbólico de 'y'
math.atanh(y)				-->Cálcula el arcotangente hiperbólico de 'y'.





*METODOS FUNCIONES DE CLASIFICACIÓN
-----------------------------------------------------------------------------------------
*Al momento de redondear existen 2 conceptos: tolerancia relativa y tolerancia absoluta.

math.isclose(x,y,rel_tol=valor)		-->Cálcula si x o y estan dentro del margen de error que indiquemos por parámetro en re_tol=valor.
					   (abajo tenemos mas ejemplos)

math.isfinite(x)			-->Nos devuelve un valor booleano dependiendo si el valor que le pasemos por parámetro no se trato del 						   infinito ni de un valor NaN.
math.isinf(x)				-->Nos devuelve un valor booleano dependiendo si el valor que le pasemos por parámetro es infinito o no.
math.isnan(x)				-->Nos devuelve un valor booleano dependiendo si el valor que le pasemos por parámetro se trata de un NaN
					   (nan)



*METODOS FUNCIONES ESPECIALES
-------------------------------------------------------------------------------	
math.erf(x)				-->Sirve para cálcular la función de error en el valor x que indiquemos por parametro.
					          x
-la función error viene dada por: erf(x)=  (2/pi)*∫ e^(−t)^(2)*dt  (esta integral es la campana de gauss)
					          0




math.erfc(x)				-->Cálcula el complementario de la función math.erf(x)

-la función viene dada por: erfc(x)= 1 - erf(x)




math.gamma(x)				-->Cálcula el valor de la función Gamma (función gamma de Euler)
					∞
-la función gamma viene dada por: Γ(x)=∫ y^(x−1) * e^(−y)*dy
					0

¡Curiosidad! Si cálculamos la función gamma para 'x', siendo 'x' un valor entero. la función gamma nos cálculara el factorial de (x-1)!
Γ(x) = (x-1)!  : Si x es un número entero


math.lgamma(x)				-->Nos devuelve el logaritmo neperiano del valor de la función gamma evaluada en x. Es decir, nos cálcula 
					   log(Γ(x))






--------------------------------------------------------------------------------
			Ejemplos:
--------------------------------------------------------------------------------
math.isclose(4, 4.0000000000000000001)			#Le preguntamos a python si considera que estos números estan suficientemente cerca el uno del 								otro, si uno de ellos tiene a ser el otro. (la tolerancia relativa por defecto es
							rel_tol=1e-09 (9 ceros a la izquierda))
							#rel_tol viene a ser el porcentaje del primer parámetro.

math.isclose(4,5, rel_tol=0.5)		#le preguntamos a python si se cumple al menos  [("4  in 5  ±5*0.5") or ("5 in 4 ±4*0.5")].



Ejemplos 
-----------

*podemos calcular el lcm:
def lcm(a,b):
	return math.fabs(a*b)//math.gcd(a,b)


*metodo .log (para calcular logaritmos)-------------------------------------------------------
	-Si solamente le pasamos 'x' al que queremos aplicar el logaritmo, entonces nos devuelve el resultado de aplicar el logaritmo neperiano
	 (logaritmo en base e) de 'x'.	
	-Si introducimos dos parámetros, el primero sera el número al que le queremos aplicar el logaritmo, y el segundo será la base.



ejemplos:
--------------
math.log(55)			#devuelve 4.007333...	
math.log(55,math.e)		#devuelve 4.007333...
math.log(100,10)		#devuelve 2

math.log1p(x)			

*podremos implementar este método para cácular el combinatorio de un número en caso math.comb no funcione.

def choose(n, k):
  if (n >= k and k >= 0):
    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))
  else:
    return "No se puede calcular el número factorial indicado"


*math.atan2(x,y)
*El proposito de este método es que devuelve el resultado en el intervalo <-pi:pi], pues conoce el simbolo de ambas coordenadas. De modo que puede computar el correcto cuadrante para el ángulo correspondiente al formado por el punto (x,y) con respecto a la parte positiva del eje horizontal.





------------------------------------------------------
		MODULO CMATH
------------------------------------------------------
*Es una extensión del modulo 'math'. 
*Casi toda las operaciones(métodos) del modulo math se pueden usar con el módulo cmath.	


constantes del módulo cmath---------------------------------------
*ademas de tener las mismas constantes que el módulo math
cmath.pi				-->número pi
cmath.e					-->número e
cmath.tau				-->el doble de pi
cmath.inf				-->el infinito
cmath.nan				-->NaN, valor desconocido

cmath.infj				-->se trata de un número complejo donde: la parte real es 0 y la parte compleja es infinito.
cmath.nanj				-->se trata de un número complejo donde: la parte real es 0 y la parte compleja es NaN.


métodos. Coordenadas polares-----------------------------------------------

cmath.phase(x)		arg		-->nos cálcula el argumento del número complejo 'x'. El resultado es devuelvo en radianes dentro del intervalo
					  [-pi,pi] (el ángulo)
cmath.polar(x+yj)   	(modulo,arg)	-->Sirve para pasar coordenadas rectangulares(cartesianas) a coordenadas polares. nos devuelve una tupla con 
					  (valor del modulo, valor del argumento)

cmath.rect(modulo,arg)	(x+yj)		-->nos devuelve las coordenadas cartesianas del número complejo. le pasamos de parámetro el modulo y el 					   argumento

abs(z)					-->Nos calcula el modulo del número complejo


metodos potencias y logaritmos------------------------------------------------
cmath.exp(x)		--> Calcula e^(x), donde x es el número complejo que le pasamos por parámetro
cmath.log(x)		--> Cálcula el logaritmo de 'x' en base 'e' (si no indicamos la base 'e' viene por defecto.)
cmath.log(x,y)		--> Cálcula el logaritmo de 'x' en base 'y'.
cmath.log10(x)		--> Cálcula el logaritmo de 'x' en base 10
cmath.sqrt(x)		--> Cálcula la raíz cuadrada del número complejo.



funciones trigonometricas-----------------------------------------------------
*Siendo z=a+bj y |z|=el módulo y θ=arg(z) 
recordar que:	 z=|z|(cosθ+senθj)
		 e^(iθ)=cosθ+senθj
		 e^(-iθ)=cosθ-senθj
		 z=|z|e^(θi)
		

* siendo senθ=(e^(iθ)-e^(-iθ))/2
	 cosθ=(e^(iθ)+e^(-iθ))/2
	 
* siendo θ=Z
	 senZ=(e^(iZ)-e^(-iZ))/2
	 cosZ=(e^(iZ)+e^(-iZ))/2
	
cmath.sin(z)		--> Cálcula el seno del ángulo complejo
cmath.cos(z)		--> Cálcula el coseno del ángulo complejo
cmath.tan(z)		--> Cálcula la tangente del ángulo complejo
cmath.asin(z)		--> Cálcula el arcoseno del ángulo complejo que pasemos por parámetro
cmath.acos(z)		--> Cálcula el arcocoseno
cmath.atan(z)		--> Cálcula el arcotangente


METODOS FUNCIONES HIPERBOLICAS-------------------------------
cmath.sinh(z)		--> Seno hiperbolico
cmath.cosh(z)		--> coseno hiperbolico
cmath.tanh(z)		--> tangente hiperbolico
cmath.asinh(z)		--> arcoseno hiperbolico
cmath.acosh(z)		--> arcocoseno hiperbolico 
cmath.atanh(z)		--> arcotangente hiperbolico
	
METODOS FUNCIONES DE CLASIFICACIÓN---------------------------
cmath.close(z)		-->es igual que el de math.close
cmath.isfinite(z)	-->comprueba si los 2 valores son finitos
cmath.isinf(z)		-->comprueba si al menos 1 valor es infinito
cmath.isnan(z)		-->comprueba si al menos 1 valor es NaN


cmath.inf		--> el infinito de los reales
cmath.infj		--> el infinito de los complejos

z.real			--> devuelve la parte real del complejo
z.imag			--> devuelve la parte imaginaria del complejo
z.conjugate		--> devuelve el conjugado del complejo.




=======================================================================================================================================================
|					Sección 18: Tema16 - Módulos de python: numpy							      |
=======================================================================================================================================================
*NUMPY es un módulo para trabajar con arrays, que son un tipo especial de lista, son mucho más rapidos para procesar.
*El objeto de 'numpy' recibe el nombre de 'ndarray'. Este tipo de dato es muy usado en el mundo de la ciencia de datos, donde la velocidad y los recursos son de gran importancia.

*Las dimensiones de un array viene dada por el nivel de profundad de este.
*Para saber las dimensiones de un array usamos el método .dim
*¡Cuidado! En las versiones actuales de python, si creamos un array de n-dimensionales, entonces todos los arrays m<n deben contener el mismo número
de elementos. Es decir, si creamos un array de 4 dimensiones, todos los arrays de 3 dimensiones deben tener el mismo número de elementos; por su parte todos los arrays de 2 dimensiones, deben tener el mismo número de elementos; y lo mismo para los arrays de 1 dimensión. Esto se debe a que en caso contrario el atributo .shape no tendría sentido.
*Es decir todos los hijos del array deben tener la misma cantidad de elementos.


siendo: a=np.array([1,2,3,4]

import numpy as np			#importamos los metodos, atributos requeridos para trabajar con arrays
print(np.__version__)			#muestra la versión de np que estamos utilizando
type(a)					#el tipo de dato es 'numpy.ndarray'

*array 0-dimensionales-----------
d=np.array(77)			#ún numero puede ser declarado como un array, pero solo sera tomado como una constante del array.

*array 1_dimensionales-----------
d=np.array([1,4,2,6])		#Son los arrays con solo 1 nivel de profundidad (1 sola fila)

*array 2-dimensionales-----------
d=np.array([[3,4,5],[1,6,2]])	#Son los arrays formados por listas de listas

*array 3-dimensionales-----------
*Son los arrays que tienen por elementos arrays bidimensionales
d=np.array([[[1,2,3],[1,4,2],[1,0,0]],[[4,1,5],[3,2,1],[0,1,0]]])

*array multidimensionales--------
*Un array puede tener un número finito de dimensiones.
*A la hora de crear un array podemos indicar como parámetro el número de dimensiones que queramos que tenga dicho array con el argumento ndim.


-----------------Shape de un array------------------
*shape. Es el número de elementos de cada dimensión, lo cálculamos con el atributo .shape
		-El primer índice corresponde con la mayor dimensión, correspondiente con ndim
		-El último indice se corresponde con la menor dimensión (dimensión 1).




-----------------reshape de un array---------------
*.reshape: permite redimensionar un array

d=np.array([1,2,3,4,5,6,7,8])		#como vemos el total de datos es 8
d=np.reshape(2,4)			#redimensionames el total de datos del array en 2 dimenesiones (2 filas y 4 columnas)


d=np.reshape(4,-1)			#-1 tomara el valor 2, ya que 4*2=8 ; 8 era el total de datos que teniamos



Elementos de un array
-----------------------------------------------------------
*Caso unidimensional

a=np.array([2,3,4,5])
print("primer elemento",a[0])
print("último elemento",a[-1])


*Caso multidimensional

a=np.array([[1,2,3,4],[2,4,1,5]])
a[0][0]	 	#primer elemento de este array
b[0,0]	#primer elemento del array	(otra forma de acceder a los elementos de un array)

b=np.array([[[1,2,3],[3,0,1]]
	   [[5,2,1],[6,1,2]]
           [[7,1,3],[5,2,1]]])

b[0][0][0]	#primer elemento de este array
b[0,0,0]	#primer elemento del array	(otra forma de acceder a los elementos de un array)
b[0,0]		#como el array es 3 dimensiones, entonces mostrara el elemento para dicha posición (en este caso el elemento es un array)
b[-3,-2,-1]	#podemos jugar con los indices, como si fueran listas, tuplas, etc.




			Concepto de slicing
-----------------------------------------------------------------
*En python, slicing hace referencia a tomar elementos desde un índice hasta otro proporcionado.
Ya conocemos la sintaxis:
	-[inicio:fin] donde iremos desde el índice 'inicio' e iremos hasta el indice 'fin-1', y lo haremos de 1 en 1. (por defecto)
	-[inicio:fin:pas] donde iremos desde el índice 'inicio' e iremos hasta el indice 'fin-1', y lo haremos de 'paso' en 'paso'	

*Nos sirve también para obtener sub conjuntos de nuestro array.

ejemplo:
--------
*caso unidimensional

a=np.array(9,8,7,6,5,4,3)
a[1:4]			#muestra array[8,7,6] (sigue la sintaxis del corchete)
a[1:7:3]		#desde el indice '1' hasta el indice '7' de '3' en '3'
a[:3]			#desde el primer indice hasta el 3
a[3:]			#desde el indice 3 hasta el ultimo
a[::]			#todos los elementos
a[::3]			#desde el primer indice hasta el final de 3 en 3

*caso multidimensional
a=np.array([
	   [[4,5],[2,1],[6,2]],
	   [[6,2],[1,6],[0,0]]
	    ])
a.ndim 		#nuestro array es 3 dimensiones
a.shape		#devuelve (2,3,2)

a[0,1,:]	#indicamos que para el array a[0,1], le mostraremos todos los elementos.
a[:2,2,1]	#indicamos que para el array que se genera con a[:2], mostraremos solo los que tiene indice [2,1]
a[:-2,:,-1,-1]	#mostrora par atodos los elementos desde la posición a[:-2], sus elementos de la posición a[:-2,:] lo que tengan indice '-1' y a su vez
		 de estos los indices -1


		Filtrando Arrays
---------------------------------------------------------
*Filtrar un array implica la selección de elementos de un array existente que satisfagan una condición y crear un nuevo array con dichos elementos.
*La sintaxis es muy similar al slicing, pero en vez de eso, entre corchetes indicamos una condición booleana. Los elementos que satisfagan la condición serán los que permanezcan, mientras que el resto serán omitidos.

*Visto de otro modo, la condición crea un array booleano. Aquellas posiciones ocupadas por un True serán las contenidas en el array filtrado, mientras las que esten ocupadas por False (por que no satisfacen la condición), serán descartadas.

	Ejemplo:
----------------------
a=np.array([4,3,2,3,4])
b= a[a==4]		#b sera un nuevo array con los elementos del array 'a' que satisfagan la condición a==4

a==4			#crea un array booleano con aquellos elementos que cumplan la condición True y los que no False


b= a[a%2==0]		#devolvera un array con aquellos elementos que cumplan la condición.

b= a[a<=2]		# El array que se cree, sera unidimensional con los elementos que satisfagan la condición.



	Tipos de datos en numpy
----------------------------------------
*Por defecto , python tiene los siguientes datos:
	-int: integer
	-float: float
	-complex: complex float
	-bool: boolean 
	-str: string

*En numpy encontramos tipos de datos adicionales
	-i: integer				#datos enteros
	-u: unsigned integer			#un número entero sin signo (ocupa menos espacio en la memoria)
	-f: float				#datos float
	-c: complex float			#datos complejos
	-b: boolean				#datos booleanos
	-m: timedelta				#valores de tiempo
	-M: datetime				#valores de fecha y hora
	-O: object				#datos objeto
	-S: string				#datos string
	-U: unicode string			#string en formato unicode
	-V: void				#nada, que no hay datos aquí, vacio

*Para comprobar el tipo de dato de un array, usamos el método .dtype

Ejemplos:
---------

a=np.array([1,2,3])
a.dtype				#indicara que el tipo de dato es int64

a=np.array([1.2,14])		
a.dtype				#indicara que el tipo de dato es float64

a=np.array([1+1j,2-1j])
a.dtype				#indicara que el tipo de dato complex128, esto sucede ya que 64bits se van a la parte real y 64 a la parte imaginaria


a=np.array(['araña','barco','color'])
a.dtype				#el tipo de dato sera <U7 (U hace referencia a unicode; el 7 hace referencia a que el dato mas grande tiene 7 					carácteres)


a=np.array(['a','b','c'])	
a.dtype				#el tipo de dato sera <U1 (ya que el dato mas grande(todos) tiene solo 1 cáracter)


a=np.array([1,2,3,4,5],dtype="S")
print(a)			#[b'1',b'2',b'3',b'4',b'5'] ('b' hace referencia a binario)			
a.dtype				#S1 (String de un elemento)


a=np.array([1,2,3,4,5],dtype="i1")   #le indicamos que el tipo de dato es solo de 1 carácter, por lo tanto solo nos guarda 8bits para el tipo de 					      dato.
a.dtype				     #int8	(aquí vemos que solo seran de 8bits)

a=np.array([1,2,3,4,5],dtype="i2")	#el tipo de dato sera de 2 carácteres, por lo tanto nos guarda 16bits para el tipo de dato.	
a.dtype					#int16

a=np.array([1,2,3,4,5],dtype="f8")	#el tipo de dato sera flotante de 8 carácteres, por lo tanto nos guarda 64bits para el tipo de dato.
a.dtype					#float64

a=np.array([1,2,3,4,5],dtype="c16")	#el tipo de dato sera complejo de 16carácteres, por lo tanto nos guarda 128bits para el tipo de dato
print(a)				#[1+0j,2+0j,3+0j,4+0j,5+0j]
a.dtype					#complex128


a=np.array([1,2,3,4,5],dtype="S2")	#el tipo de dato sera string de 2 carácteres, por lo tanto solo guarda 16bits
print(a)				#[b'1',b'2',b'3',b'4',b'5']
a.dtype					#S2

a=np.array([1,2,3,4,5],dtype="S2")	#el tipo de dato sera string de 2 carácteres, por lo tanto solo guarda 16bits
print(a)				#[b'1',b'2',b'3',b'4',b'5']
a.dtype					#S2

	metodo astype
--------------------------------------

a=np.array([1,2,3,4,5],dtype="f16")	#nuestro array son datos tipo float128
a.dtype					#float128
b=a.astype("i")				#cambiamos el tipo de dato que seran nuestros datos, lo cambiamos a tipo 'i' (32 bits)
b.dtype					#int32


a=np.array([1,2,3,4,5],dtype="f16")	#nuestro array son datos tipo float128
a.dtype					#float128
b=a.astype(int)				#es otra forma de cambiar nuestro tipo de dato a tipo 'int' (python lo entiende que es de 32bits)
b.dtype					#int32


a=np.array([1,3,0,5,-10])	
a.dtype					#int64
b=a.astype(bool)			#es otra forma de cambiar nuestro tipo de dato a tipo 'bool' (todos los elementos que sean igual 0 seran False)
					 los demás seran True	
b.dtype					#bool




		Copias y views de array
------------------------------------------------------
*Copia: una copia de un array crea un nuevo array exactamente igual al original.
*Las copia no es afectada por los cambios al array original.

x=np.array(['a','b','c'])
print(x)
x_copy=x.copy()
print(x_copy)


*view: Una view es una referencia al array original.
*Los cambios aplicados al array original también modifican a la copia y viceversa.

y=np.array([1,2,3])	#creamos una array
y_view=y		#creamos una referencia al array y


*Para asegurarnos de si hemos hecho una copia o una view, podemos usar el método '.base', que nos devolverá 'None' si se trata de una copia y nos devolverá el array original si se trata de una view

z=np.array([1j,0,-1j])
z_copy=z.copy()
z_view=z

print(z_copy.base)	#Nos devolvera 'None' por que z_copy es una copia del array
print(z_view.base)	#Nos devolvera 'el array original (z)' por  que z_view es una referencia del array original



-------------------------------------------------------------------------
			ARRAYS Y BUCLES
-------------------------------------------------------------------------
*Pordemos iterar un array tal cuál lo haciamos con listas:
*utilizando el bucle for para acceder a cada nivel de dimensión


*Pero también podemos apoyarnos en el metodo .reshade(-1) (recordar que con esto aplanamos el bucle a 1 dimensión)
 (Pero no es recomendado ya que el '.reshade' utiliza mucha memoria, tiene mucho coste computacional) (para datos grandes especificamente)



		Bucles .nditer() y .ndenumerate()
--------------------------------------------------------------------
método .nditer()
---------------------------
*Para evitarnos tantas lineas de código y tanto coste computacional, tenemos el método '.nditer()' que nos crea un iterable el cual nos permite imprimir todos los elementos de los arrays 1D, tal cual hemos estado obteniendo hasta ahora.

Ejemplo:
---------
d2=np.array([[1,2],[3,4],[5,6]])

d=np.array(d2) 		

for i in np.nditer(d):
	print(i)		#nos imprimira el elemento de ultima dimensión que tiene nuestro array (es como si hariamos un reshade pero evitando 					el coste computacional)

	

*El método np.nditer tambien nos permite cambiar el tipo de datos de los elementos de un array durante la iteración mediante el parámetro 'op_dtypes'.
*'numpy' no cambia el tipo de dato de los elementos de un array en el sitio, de modo que necesita algún otro espacio para llevar a cabo esta acción.
Este espacio extra es llamado 'buffer 'y se lo proporciona el método '.nditer' con el argumento 'flags=["buffered"]'


Ejemplo:
----------

d2=np.array([[1,2],[3,4],[5,6]])

for i in np.nditer(d2, flags=["buffered"], op_dtypes=['S']):	#flags=['buffered']	indicamos que en memoria haga el cambio.
								 op_dtypes=['S']	los elementos seran de tipo string 'S'.





d2=np.array([[1,2],[3,4],[5,6]])
d=np.array(d2) 		
for i in np.nditer(d[:,::2]):		#todos los elementos de la primera dimensión, todos los elementos de la segunda dimensión de 2 en 2 en índice.
	print(i)			#devuelve 1  3  5




método .ndenumerate()
---------------------------
*A veces necesitamos el índice correspondiente al elemento durante la iteración. El método '.ndenumerate()' nos proporciona dicha información.

d=np.array(['a','b','c'])

np.ndenumerate(d)		#nos devuelve una tupla con 2 elementos (indice, elemento). nos devuelve el indice que ocupa el elemento y luego el 					 elemento para el array d


for  idx,i  in np.ndenumerate(d1) :
	print("Índice: {} Elemento {}".format(idx,i))	



-----------------------------------------------------------------
		Concatenación de arrays
----------------------------------------------------------------
	método np.concatenate(())
------------------------------------------------
*Nos permite concatenar arrays
*axis va desde 0 hasta n-1 dimensiones(mira y concatena dentro de cada dimensión)


Ejemplo
--------
#CONCATENACIÓN PARA ARRAY 1D
a1=np.array([-3,-2,-1])
a2.np.array([1,2,3])
a=np.concatenate((a1,a2))
print(a)			#[-3 -2 -1 1 2 3]


#CONCATENACIÓN PARA ARRAY 2D
b1=np.array([[-6,-5],[-4,-3],[-2,-1]])
b2=np.array([[1,2],[3,4],[5,6]])
b=np.concatenate((b1,b2),axis=0)	#axis=0 indica que lo concatene respecto a la primera dimensión
print(b)				#mientras las dimensión del array concatenado cuadren, sera posible haber concatenado

b=np.concatenate((b1,b2),axis=1)	#axis=1 indica que lo concatene respecto a la segunda dimensión
print(b)				#mientras las dimensión del array concatenado cuadren, sera posible haber concatenado


#CONCATENACIÓN PARA ARRAY 3D
c1=np.array([[[-10,-9],[-8,-7],[-6,-5]],[[-4,-3],[-2,-1],[0, 0]]])
c2=np.array([[[  0, 0],[ 1, 2],[ 3, 4]],[[ 5, 6],[[7, 8],[9,10]]])
c=np.concatenate((c1,c2),axis=2)	#axis=2 indica que lo concatene respecto a la 3ra dimensión (nosotros elegimos en que dimensión queremos unir)


*Obseravación: En este caso, nos vuelven a funcionar todos las configuración del valor 'axis' pues los arrays3D, c1 y c2 tienen tanto el mismo número número de arrays 2D, como el mismo número de arrys 1D en cada array 2D, como el mismo número de elementos dentro de cada array 1D.

*Si indicamos 'axis=0', se nos combinan ambos arrays 3D en un solo array 3D, si seleccionamos 'axis=1', entonces obtenemos como resultado un array 3D con cada uno de los arrays 2D concatenadas. Por último, si indicamos 'axis=2', obtendremos un array 3D donde los arrays 1D han sido concatenados.

*Observación: Si queremos concatenar arrays n-dimensiones, tendremos n-1 opciones para el parametro axis.

  

	CONCATENACIÓN USANDO .STACK((),axis)
------------------------------------------------
*Llevar a cabo un np.stack() es lo mismo que concatenar, solo que el stack se hace sobre un eje nuevo.
*Por ejemplo, podemos concatnear 2 arrays unidimensionales sobre un segundo eje, lo que resultaria poner un array sobre otro: realizar un stack.
*axis va desde 0 hasta n dimensiones(mira y concatena sobre afuera de cada dimensión)
*funciona igual que .concatenate solo que por ejemplo para arrays 1D y axis=0, concatenate mira ya los elementos. Mientras que stack para axis=0 mira hacia afuera. tendriamos que subir 1 nivel más para empezar a ver los elementos y concatenarlos.

Ejemplo:
--------
a1=np.array([-3,-2,-1])
a2=np.array([ 1, 2, 3])

#hacemos stack de arrays 1D con axis=0		
a=np.stack((a1,a2),axis=0)			#Lo concatenara 


#hacemos stack de arrays 1D con axis=1


#hacemos stack de arrays 1D con axis=2



-------------------------------------------------------------------------
|	concatenando por filas, por columnas y por profundidad		|	
-------------------------------------------------------------------------

hstack():
---------
*numpy proporciona la función helper 'hstack()' que lleva a cabo una concatenación por filas:

Ejemplo:

#Caso 1D (se corresponde con el resultado de .concatenate)
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.hstack((a1, a2))
print(a)


#Caso 2D (se corresponde con el resultado de .concatenate() con axis=1)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.hstack((b1, b2))
print(b)


##Caso 3D (se corresponde con el resultado de .concatenate() con axis=1)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.hstack((c1, c2))
print(c)



vstack():
---------
*numpy proporciona la función helper 'vstack' que lleva a cabo una concatenación por columnas:


Ejemplo:

# Caso 1D (se corresponde con el resultado de .stack() con axis = 0)
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.vstack((a1, a2))
print(a)


# Caso 2D (se corresponde con el resultado de .concatenate() con axis = 0)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.vstack((b1, b2))
print(b)


# Caso 3D (se corresponde con el resultado de .concatenate() con axis = 0)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.vstack((c1, c2))
print(c)


dstack():
---------
*numpy proporciona la función helper 'dstack' que lleva a cabo una concatenación por profundidad:

Ejemplos:
---------

# Caso 1D (se corresponde con el resultado de .stack() con axis = 1)
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.dstack((a1, a2))
print(a)


# Caso 2D (se corresponde con el resultado de .stack() con axis = 2)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.dstack((b1, b2))
print(b)


# Caso 3D (se corresponde con el resultado de .concatenate() con axis = 2)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.dstack((c1, c2))
print(c)






	Diviendo arrays 1D
--------------------------------------
*np.array_split(x,i) nos permite dividir arrays en cierta cantidad de grupos que indicamos por párametro


ejemplo:
---------
x=np.array(([1,2,3,4,5,6,7,8]))
y=np.array_split(x,4)				#del array 'x', indicamos con np.array_split que queremos dividirlo en 4 grupos que traten de ser 							homogeneos en elemento.

y=[array([1,2]),array([3,4]),array([5,6]),array([7,8])]


for i in range(2,x.shape[0]+1):
	print("Dividimos en {} arrays: {}".format(i, np.array_split(x,i)))



*dato: np.array_split(x,valor)	devuelve una lista por lo que también podriamos iterar sobre este.


--------------------------------------
	El método .split()
--------------------------------------
*A la hora de dividir arrays tenemos el método .split(), pero falla en caso de que el número de arrays en que queramos dividir el array original no sea
divisor del número de elementos del array.

*Funciona igual que np.array_split(), solo que aquí es estrico que la cantidad de arrays en la que queremos dividir se divisor del cantidad de datos que hay en el array.



------------------------------------------------------
		Diviendo arrays 2D		
------------------------------------------------------
*Podemos dividir también arrays 2D en multiples arrays 2D.

Ejemplo:
- - - - -
x = np.array([[-1, 0, 1], [-2, 0, 2], [-3, 0, 3], 
              [-4, 0, 4], [-5, 0, 5], [-6, 0, 6]])
print("Del array original x =\n", x)
print("Dividiéndolo en 3 con axis = 0 obtenemos:")
y = np.array_split(x, 3, axis = 0)			#0 es el valor por defecto que toma nuestro axis es 0 si no lo ponemos
for i in y:
  print(i)

print("\nDividiéndolo en 3 con axis = 1 obtenemos:")
y = np.array_split(x, 3, axis = 1)
for i in y:
  print(i)


Ejemplo 2:
----------
a = np.array([[1, 2, 3, 4, 5], 
              [6, 7, 8, 9, 10],
              [11, 12, 13, 14, 15], 
              [16, 17, 18, 19, 20]])

print("La shape del array 2D original es:", a.shape)

n = a.shape[-1] # Tomamos el número de elementos que contiene cada array 1D
for m in range(2, n + 1):
  print("\nDividimos el array original 2D en {} arrays con axis = 1".format(m))
  q = n//m
  r = n % m
  print("n = {}, m = {}, q = {}, r = {}".format(n, m, q, r))

  print("Los {} arrays resultantes contienen el mismo número de arrays 1D que el original".format(m), sep = " ")
  if r == 0:
    print("cada uno de ellos con el mismo número de elementos: {}".format(q))
  
  else:
    print("\nEn este caso, para los primeros {} arrays 2D, cada array 1D tiene {} elementos.".format(r, q + 1))
    print("para los arrays 2D restantes, cada array 1D tiene {} elementos".format(q))

  for i in np.array_split(a, m, axis = 1):
    print(i)


Ejemplo3:
---------
b=np.array([[1,2,3,4,5,6],[-1,-2,-3,-4,-5,-6],[0,0,1,1,2,2]])
np.array_split(b,2,axis=1)

'''
mostrara
[array([[ 1,  2,  3],
        [-1, -2, -3],
        [ 0,  0,  1]]), array([[ 4,  5,  6],
        [-4, -5, -6],
        [ 1,  2,  2]])]

''

*Fijate como los agrupa para axis=1, cada dimension del array principal, lo dividimos en 2 partes como indica el split y luego se los junta y se forma un nuevo array. (revisar el ejemplo)
*Lo que sucede cuando separamos para dimensiones superiores es que, para elemento de esa dimensión, se agrupan los primeros valores.


	Diviones por filas, columnas y profundidad:		
-----------------------------------------------------------------
	hsplit()
-------------------------
*Lleva el proceso opuesto de hstack()


Ejemplo:
--------
a=np.array([[1,2,3,4,5],
	    [6,7,8,9,10],
	    [11,12,13,14,15],
 	    [16,17,18,19,20]])

for i in np.hsplit(a, 5):		#es equivalente si usaramos np.array_split(a,5,axis=1), la diferencia es que hsplit necesita que todas las 						dimension tienen que tener el mismo tamaño (mismo número de elementos)	
	print(i)


	vsplit()
-------------------------
*Lleva el proceso opuesto de vstack()

a=np.array([[1,2,3,4,5],
	    [6,7,8,9,10],
	    [11,12,13,14,15],
 	    [16,17,18,19,20]])

for i in np.vsplit(a, 5):		#es equivalente si usaramos np.array_split() axis=0
	print(i)




	dsplit()
-------------------------
*lleva el proceso opuesto de dstack()


	
----------------------------------------------------------------
		Buscando un elemento en un array
----------------------------------------------------------------
*Podemos buscar elemento en concreto de un array con el método .where() que nos devolvera un array de indices en los cuales se encuentra el elemento que estamos buscando.

Ejemplo:
--------

x=np.array([1,0,-1,0,2,0,-2,0])
idx0=np.array(x==0)

#(array([1, 3, 5, 7]),)    nos devuelve una tupla. Donde el primer array hace referencia a la primera dimensión y los indices que cumplen la condición


y = np.array([[2, 3, 6, 7],
              [14, 15, 30, 31]])
z = np.where(y % 2 == 0)

print(z)

#(array([0, 0, 1, 1]), array([0, 2, 0, 2])) nos devuelve una tupla. Donde el primer array se combina con el 2do array posición a posición para saber #el indice de aquellos elementos que cumplen la condición. (el primer array hace referencia a la primera dimensión y el 2do a la 2da dimensión)
#es decir por ejemplo (0,0),(0,2),(1,0),(1,2) así quedaria combinando.


-----------------------------------------------------------------
|		El metodo .searchsorted()			|
-----------------------------------------------------------------	
*El método .searchsorted() lleva a cabo una busqueda binaria en el array y devuelve los indices donde el valor indicado por parámetro sería colocado de modo que se mantuviese el orden de búsqueda:

ejemplo:
--------

a=np.array([-10,-9,-8,-7,-6])
b=np.searchsorted(a,-9.5)
c=np.searchsorted(a,-5)


*¡Observación! Lo que hace .searchsorted es ordenar primero el array, ya sea por:
	-para los números, iran de forma ascendente
	-las letras y string en forma alfabetica ascendente.
*luego devolvera el indice de la posición en la que iria el elemento que le pasemos en el segundo parametro

#entonces 'b' devolvera 1, ya que del array 'a' iria entre la posición 0-1
#c devolvera 5, ya que del array 'a' iria después de la posición 4  

*Atributo 'side'(por defecto vale left), sirve para indicar si el indice que vamos a introducir lo queremos hacer desde la izquierda o derecha

Ejemplo:
--------
a = np.array([-10, -9, -8, -7])
b_left = np.searchsorted(a, -9, side = "left")		#como si no pusieramos el side, devuelve el indice donde se introduciria el elemento, 								corriendo a los demás a la derecha. si coincide ocupa ese indice y lo corre a la derecha.
b_right = np.searchsorted(a, -9, side = "right")	#si coindice, se agrega despues de ese elemento y devuelve el indice. 
c_left = np.searchsorted(a, -7, side = "left")		
c_right = np.searchsorted(a, -7, side = "right")	#	
print("El elemento -9 puede ocupar como pronto el índice", b_left)
print("El elemento -9  puede ocupar como tarde el índice", b_right)
print("El elemento -7 puede ocupar como pronto el índice", c_left)
print("El elemento -7 puede ocupar como tarde  el índice", c_right)


*si le pasasemos una lista por 2do parametro, evaluara elemento a elemento donde iria cada elemento y devolvera el indice en un array.

------------------------------------------------------
		ORDENANDO ARRAYS
------------------------------------------------------
*Ordenar arrays implica reordenar los elementos siguiendo una secuencia ordenada.
*A su vez, una secuencia ordenada es cualquier suceción que tiene un orden ciuos elementos, como por ejemplo el orden alfabetico o númerico, tanto ascendente como descendente.
*Para ordenar los elementos de un array, disponemos del método. sort()

x = np.array([2.5, -2.3, 5.1, -5.7, 10.9, -10.6, 0.4])
print(np.sort(x))				#ordenara los elementos del array unidimensional


----------------------------------------------------
|		EL MODULO RANDOM		   |
----------------------------------------------------
!OJOOOO¡ El metodo 'random' de numpy no es lo mismo que importar el modulo 'random'
es decir: import random != from numpy import random 	(el método random.randrange pertenece al módulo random)




El modulo random
------------------
*numpy tiene el modulo random dedicado a trabajar con números aleatorios.
*Para generar números aleaotrios usamos el método randint, randrange

from numpy import random


random.randint(i,j)				#genera un número entero aleatorio entre i a j, sin considerar el valor de j
random.rand()					#genera un número real aleatorio entre [0,1]




-------------------------
|  Arrays aleatorios	|
-------------------------
*Podemos generar arrays aleatorios tanto con el método .randint() como con el método .rand()

random.randint(i,j,size=valor)			#genera un array unidimensional de tamaño 'size', cuyos elementos seran números enteros aleatorios 							entre i a j 

rando.rand(i)					#i sera el tamaño del 'size', es decir el tamaño del array unidimensional cuyos elementos seran 						números reales entre [0,1]


random.randint(i,j,size=(4,5))			#genera un array de dimensiones 4x5 cuyos elementos ya fueron indicados como se generan

random.rand(3,4)				#genera un array de dimensiones 3x4, cuyos elementos ya fueron indicados como se generan

*size=tupla genera un array multidimensional cuyas dimensiones seran los valores de los elementos de la tupla.


----------------------------------------------------------
|	Elegir un elemento aleatorio de un array	 |
----------------------------------------------------------
*Dado un array podemos elegir un elemento suyo aleatoriamente con el metodo .choice

x=np.array([1,2,3,4,5,-5,-4,-3,-2,-1])
print(radom.choice(x))


-----------------------------------------
|	Permutaciones aleatorias	|
-----------------------------------------
*permutación: Una permutación de un array se refiere a la reordenació de sus elementos.
*El modulo random de numpy nos proporciona dos métodos para crear permutaciones aleatorias de un array dado:
	- .shuffle() : modifica el array original
	- .permutation() : que crea una copia



a=np.array([1,2,3,4])

random.shuffle(a)			#reordena los 


-----------------------------------------------------------
|		Funciones Universales			  |
-----------------------------------------------------------
*Las funciones universales son aquellas que operan sobre el objeto ndarray.
*Podemos comprobar si un metodo se trata de una función universal con la función 'type'. Cuando se trata de una función universal, obtenemos que es de tipo np.ufunc

*Creando nuestras propias función universales
----------------------------------------------
*Para crear una función universal propia, primero necesitamos definir una función tal cual aprendimos. A continuación, hay que añadirla a numpy con el metodo .frompyfunc(), que tomará por parámetros la función function, el número de inputs (arrays), inputs y el número de arrays que devuelve, outputs:


sintaxis:

def nameFuntion(x1,x2,...):
	return Z


myFunction=np.frombyfunc(nameFuntion,#CantidadDeParametros,#Cantidad de valores que devuelve)



		funciones de aritmetica
----------------------------------------------------------
*siendo a y b arrays:


np.add(a,b)		#suma elemento a elemento(misma posición) de los arrays

np.subtract(a,b)	#resta los elementos de los arrays (misma posición)

np.multiply(a,b)	#multiplica elemento a elemento (misma posición de los arrays) (no es lo mismo que un producto de matrices)

np.divide(a,b)		#divide los arrays, elemento a elemento, posición a posición.

np.power(a,b)		#potencia de elemento1 a la potencia de elemento2 de los arrays, posición a posición. (cálcula la potencia)

np.mod(a,b)		#cálcula el resto de dividir elemento a elemento, posición a posición de los arrays.

np.remainder(a,b)	#cálcula también el resto de dividir elemento a elemento.

np.divmod(a,b)		#devuelve una tupla con 2 arrays, el primer array tiene los cocientes de dividir y el 2do contiene el residuo de dividir

np.absolute(a)		#devuelve el valor absolute de elemento a elemento del array.	



		funciones de redondeo
-----------------------------------------------------
*En numpy tenemos 5 formas de redondear los decimales de un número.
	-trunc()  :para truncar
	-fix()	  :también para truncar
	-around() :para redondear
	-floor()  :para redondear a la baja
	-ceil()   :para redondear a la alza.

siend a=np.array([1.231,4.765,5.652])

np.trunc(a)		#truncara todos los decimales y devolvera solo la parte entera de cada elemento del array.
np.fix(a)		#con fix también truncamos la parte decimal para devolver solo la parte entera
np.around(a)		#redondea al entero mas cercano, 
np.around(a,valor)	#redondera cada elemento del array a la cantidad de decimales que le pasemos por parametro 'valor'
np.round(a,valor)	#funciona igual np.que around
np.floor		#cálcula el maximo entero de cada elemento del array, es decir redondea a la baja. (n<=a<n+1)
np.ceil			#Cálcula maximo enetero por exceso de cada elemento del array, es decir redondea para arriba. (a<=n)





		funciones de suma y diferencia
----------------------------------------------------------------
*ya conocemos el método .add que dados 2 arrays suma elemento a elemento.

a=np.array([1,2,3,5])
b=np.array([-2,3.2,5.4,-3])
c=np.array([[[1,2,3][4,5,6],[7,8,9]]])

np.sum(a)				#Suma todos los elementos del array.
np.sum(a,axis=valor)			#valor=0, sumara los primeros elementos de todas sus subs arrays, indice por indice, al final devuelve una 						tupla. Con axis indicamos sobre que eje vamos a sumar


Ejemplos:
----------

d=np.array([[ [1, 2, 3],[ 4, 5, 6],[ 7, 8, 9]],
   [ [5, 5, 5], [5, 5, 5],[ 5, 5, 5]],
   [[-9,-8,-7],[-6,-5,-4],[-3,-2,-1]]])


np.sum(d,axis=0)
#devuelve
array([[-3, -1,  1],
       [ 3,  5,  7],
       [ 9, 11, 13]])


np.sum(d,axis=1)
#devuelve
array([[ 12,  15,  18],
       [ 15,  15,  15],
       [-18, -15, -12]])


np.sum(d,axis=2)
#devuelve
array([[  6,  15,  24],
       [ 15,  15,  15],
       [-24, -15,  -6]])



	Suma acumulada
-------------------------------
x=np.array([2,5,7])
np.cumsum(x)

#devuelve 
array([2,7,14])		#como vemos se van sumando parcialmente los elementos; 2, luego 2+5, luego 2+5+7


	np.diff
----------------------------
*Para calcular las diferencias entre los elementos de un array, disponemos del método .diff()
*sirve para cálcular las diferencias sucecivas entre los elementos de un array.

x=[1,5,7]
np.diff(x)	#devolvera: array[4,2]	 ya que; 5-1  7-5


np.diff(x,axis=valor)	#con axis elegimos sobre que eje queremos restar




	Funciones de producto
------------------------------------
*El metodo .prod() calcula el producto de los elementos de un array.

Ejemplos:
----------
Siendo a=np.array([2,4,6,8]), b=np.array([[[1,2,3],[4,5,6],[7,8,9]],[[2,2,2],[2,2,2],[2,2,2]],[[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]])

np.prod(a)			#Calculara el producto de todos los elementos del array.
np.prod(b,axis=valor)		#Calcula el producto de los elementos para ese eje.


for i in range(b.ndim):
	print("\nEl producto de los elementos de b sobre el axis {} es\n{}".format(i,np.prod(b,axis=i)))



	.cumprod()
-------------------------
*Con el método .cumprod() podemos calcular el producto acumulado de un array.





	funciones de logaritmo
-----------------------------------------
*.log aplica logaritmo a todos los elementos del array.

*Sea a=np.array([5,12,34,7,55])

np.log(a)			#calcula el logaritmo neperiano de todos los elementos de a.


*numpy no ofrece ningún metodo para calcular el logaritmo en cualquier otra base.
*Pero podemos crearla usando np.frompyfunc

Ejemplo:
--------
from math import log			#importamos el metodo log del modulo math

a=np.array(...)
nplog=np.frompyfunc(log,2,1)


print(nplog(a,10))			#calculara el logaritmo a todos los elementos del array 'a' con base '10'.



		MCD y MCM
--------------------------------------------
*Podemos calcular el minimo común multiplo de los elementos de un array con el método.  '.lcm.reduce()'

ejemplo:
---------
b=np.array([15,12,27])
np.lcd.reduce(b)		#calcula el minimo comun multiplo




	funciones trigonometricas e hiperbolicas
----------------------------------------------------------
*En numpy el número pi se obtiene con np.pi
*en numpy disponemos de los métodos:
*Para calcular el seno, coseno y tangente de los elementos de un array(los valores se consideran en radianes)

	-.sin()
	-.cos()
	-.tan()

*Para calcular la conversión de ángulos a radianes y de radianes a ángulos respectivamente.
	-deg2rad()
	-rad2deg()

*Para calcular el arcoseno, el arcocoseno y el arcotangente y hallar ángulos(el resultado es devuelvo en radianes).
	-arcsin()
	-arccos()
	-arctan()




		Conjuntos en numpy
---------------------------------------------------------
*Estos metodos lo que hacen es crear un array con los elementos unicos del array que le pasemos por parametro, en realidad no crea un conjunto, si no que permite que los elementos de los arrays que le pasemos por parametro se comporten como uno.

*Para crear un conjunto a partir de un array, usamos el método .unique(a)
*Para hallar la unión entre 2 arrays 1D, usamos el método .union1D(a,b)
*Para hallar la intersección entre 2 arrays 1D, usamos el método .interesect1d(a,b)
*Para hallar la diferencia entre 2 arrays 1D, disponemos del método .setdiff1d(a,b)
*Para hallar la diferencia simetrica entre 2 arrays 1D, disponemos del méotod .setxor1d(a,b)



*Siendo 'd' un array
===============================================================================================
|				metodos de numpy					      |
===============================================================================================
np.array(iterable)			#crea un array a partir de una lista, tupla
d.ndim					#indica la dimensión que tiene nuestro array
np.array(iterable,ndmin=valor)		#creamos un array indicando cuantas dimensiones tendrán 'valor'
np.array(iterable,dtype='TipoDeDato')	#dtype=valor, dependiendo del tipo de dato que sea valor, ese tipo de dato también sera nuestro array.


*ELEMENTOS DE UN ARRAY Y SLICING
d[i]
d[i,j]
d[:,:]
(*ver mas ejemplos en este tema)


d.shape					#Devuelve una tupla, donde cada elemento representa la cantidad elementos que hay en cada dimensión.
					El primer índice corresponde con la mayor dimensión, correspondiente con ndim
					El último indice se corresponde con la menor dimensión (dimensión -1).

d.shape[i]				#nos muestra la cantidad de elementos para la dimensión de indice 'i'


d.reshape(i,j,...)			#redimensiona el total de datos del array en (i,j,...)dimensiones y para cada dimension cuantos elementos 
					 ejemplo: (5,3) 2 dimensiones, 5 datos para la primera dimension y para la 2da 3 datos (5 filas y 3 columnas)
					¡Recuerda que toda dimension debe tener la misma cantidad de elementos para cada dimensión!
					(no se autoguarda)

d.reshape(i,j...,-1)			#la dimensión -1 cálcula el valor necesario para que cumpla tal que al multiplicar los elementos del shape de 						este nuevo array sea igual en cantidad de datos que el array original 
					ejemplo:d=np.reshape(4,-1) ,-1 tomara el valor 2, ya que 4*2=8 ; 8 era el total de datos que teniamos
					(solo podemos pasar -1 a un solo parámetro)	

d.reshape(-1)				#aplana un array a sola 1 dimensión.

d.size					#nos da el total de datos que tiene nuestro array (la multiplicación de los elementos de nuestro shape)

d 'condición 'valor			#crea un nuevo array donde sus elementos seran valores booleanos dependiendo de que si cumplen la condición 						dada, d==valor .

d[d 'condición' valor]			#filtra un array (crea uno nuevo) con aquellos elementos que cumplen la condición dada.

d[i,j,...]				#para acceder a un elemento del array o sub array utilizamos la metodologia del corchete.


d.dtype					#nos devuelve el tipo de dato que tiene nuestro array.
d.astype('tipodedato')			#cambia el tipo de dato de nuestro array al tipo de dato que le indiquemos por parámetro
-int: integer
	-float: float
	-complex: complex float
	-bool: boolean 
	-str: string

*En numpy encontramos tipos de datos adicionales
	-i: integer				#datos enteros
	-u: unsigned integer			#un número entero sin signo (ocupa menos espacio en la memoria)
	-f: float				#datos float
	-c: complex float			#datos complejos
	-b: boolean				#datos booleanos
	-m: timedelta				#valores de tiempo
	-M: datetime				#valores de fecha y hora
	-O: object				#datos objeto
	-S: string				#datos string
	-U: unicode string			#string en formato unicode
	-V: void				#nada, que no hay datos aquí, vacio



	
d1=d.copy()				#crea una copia del array, esta copia no sufrira cambios si el array original es modificada. tiene otra 					posición de memoria respecto a la original

d2=d					#crea una copia por referencia al array original, si modificamos al array original también afecta el cambio
					 a la copia, y si cambiamos a la copia, también afecta al array original.

d1.base					#Nos devolvera 'None' si el array es una copia del original
d2.base					#Nos devolvera 'd'(el array) si el array es una referencia del original y no una copia.


np.nditer(d)				#Es útil para bucles, ya que nos devuelve cada elemento para el último nivel de profundidad.
np.nditer(d,flags=["buffered"],op_dtypes=["tipoDeDato"])	#hace lo mismo pero cambiaremos el tipo de dato para elemento del ultimo nivel de 									profundidad. buffered hace referencia a que se guardara en la memoria para hacer los 									cambios
np.ndenumerate(d)			#Es útil para bucles, nos devuelve una tupla (i,elemento) para cada elemento de la útilmo nivel de profundidad.
					i: indice del elemento


*CONCATENAR ARRAYS
*Concatenar, siendo n,n1,n2 arrays:
np.concatenate((n1,n2))			#concatena los arrays uniendonse despues del ultimo elemento del array n1.
np.concatenate((n1,n2),axis=valor)	#indicamos que vamos a concatenar con 'axis=valor' indicamos en que dimensión lo vamos a ser. Siendo 
					axis=0 para la primera dimensión.

np.stack((n1,n2),axis=valor)		#Llevar a cabo un np.stack() es lo mismo que concatenar, solo que el stack se hace sobre un eje nuevo.

np.hstack((n1,n2))			#concatena de manera horizontal.
np.vstack((n1,n2))			#concatena de manera vertical.
np.dstack((n1,n2))			#concatena respecto a la profundidad.


*DIVIDIR ARRAYS:

np.array_split(n,valor)			#divide el array 'n' en  'valor' grupos arrays que trataran de ser homogeneos (axis=0 por defecto)
np.array_split(n,valor.axis=valoor)	#divide el array 'n' en  'valor' grupos de arrays que traten de ser homogenea, con axis indicamos en que 
					dimensión queremos dividir (mirar el ejemplo)
np.split(n,valor)			#divide el array 'n' en  'valor' grupos arrays (valor debe ser divisor de la cantidad de elementos que tiene 						nuestro array)

np.hsplit				#divide de manera horizontal (equivale a np.array_split axis=1)

np.vsplit				#divide de manera vertical (equivale a np.array_split axis=0)

np.dsplit				#divide respecto a la profundidad (equivale a np.array_split axis=2)


*PARA ENCONTRAR ELEMENTOS
np.where(n condición valor)		#devuelve tuplas con array que tienen elementos a los indices que cumplen la condición. (para 2 a mas 						dimensiones se combinan los indices de los arrays posición a posición)
					(sirve para buscar elementos dentro de un array por asi decirlo)

np.searchsorted(a,valor)		#nos permite saber donde iria un elemento si lo introdujieramos en nuestro array
np.searchsorted(a,valor,side=left)	#en caso de coincidir, se desplaza los demás y ese elemento a la izquierda
np.searchsorted(a,valor,side=right)	#en caso de coincidir, se agrega desde de ese elemento a su derecha y lo demás se desplaza


np.sort(n)				#ordena los elementos de un array (por defecto de forma ascendente) (no se autoguarda)
					 (los booleanos también se ordenan, recuerda que False=0 y True=1)


np.sort(n,axis=valor)			#si no indicamos el axis, por defecto toma el valor de la última dimensión
					(por eso es que ordena elemento a elemento de cada dimensión del array)
					ejemplo: si axis fuera 0 y el array bidimensional, ordenaria en base a su primer valor de cada dimensión.
					axis=0 es decir nos ordena los elementos dentro de la mayor dimensión.


*PARA NÚMEROS ALEATORIOS
#para 'from numpy import random'

random.randint(i,j)			# permite usar este método que da un numero aleatorio. genera un número 					aleatorio entre i,j (no toma el valor j)

random.randint(i,j,size=valor)		#genera un array unidimensional con cantidad de elementos igual a 'valor'

random.randint(i,j,size=tupla)		#genera un array multidimensional cuyas dimensiones sera cada elemento de la tupla y valor entre [i,j>

random.rand()				#genera un número real aleatorio entre [0,1>
random.rand(valor)			#genera un array unidimensional cuya cantidad de elementos sera igual a 'valor'
random.rand(tupla)			#(tupla sin parentesis), genera un array multidimensional de dimensiones igual al valor de cada elemento de 
					la tupla.


*siendo 'n' un array unidimensional(solo eso.)
random.choice(n)			#elige aleatoriamente un elemento de nuestro array 'n'.
random.choice(n,size=valor)		#genera un array unidimensional con cantidad de elementos igual a 'valor', los números aleatorios son de n.
random.choice(n,size=tupla)		#genera un array de dimensiones igual a los elementos de la tupla, cada elemento de cada dimensión sera 					rellenada con números aleatorios del array n.


*parametro 'p'. Por defecto si no lo pones, cada elemento tiene una probalidad de salir de 1/len(n)
random.choice(n,p=[listaDeProbailidades])	#los elementos de la lista deben estar entre [0,1] y todas ellas deben sumar 1. cada elemento 							representa la posibilidad de salir para cada elemento de nuestro array undimensional.

random.choice(n,p=[lista],size=tupla)	#genera un array de dimensiones de la tupla indicando la posibilidad para cada elemento de nuestro array n.


*siendo 'a' un array.
random.shuffle(a)			#permuta(reordena sus elementos de una manera aleatoria del array 'a') (se autoguarda)
random.permutation(a)			#hace lo mismo que random.shuffle, solo que aquí no se autoguarda, devuelve un array copia permutado



'''*AGREGAR FUNCIONES UNIVERSALES A NUMPY*
def nameFuntion(x1,x2,...):	#Definiendo una funcion
	return Z

myFunction=np.frombyfunc(nameFuntion,#CantidadDeParametros,#Cantidad de valores que devuelve)	#Creamos la función universal


myFunction(a,b,c...)		#tantos arrays pasados como tanto parámetros acepte nuestra función universal creada.
'''				 el tamaño de las dimensiones de cada array debe ser la misma.				


*siendo a y b arrays:

np.add(a,b)		#suma elemento a elemento(misma posición) de los arrays
np.subtract(a,b)	#resta los elementos de los arrays (misma posición)
np.multiply(a,b)	#multiplica elemento a elemento (misma posición de los arrays) (no es lo mismo que un producto de matrices)
np.divide(a,b)		#divido los arrays, elemento a elemento, posición a posición.
np.power(a,b)		#potencia de elemento1 a la potencia de elemento2 de los arrays, posición a posición. (cálcula la potencia)
np.mod(a,b)		#cálcula el resto de dividir elemento a elemento, posición a posición de los arrays.
np.remainder(a,b)	#cálcula también el resto de dividir elemento a elemento.
np.divmod(a,b)		#devuelve una tupla con 2 arrays, el primer array tiene los cocientes de dividir y el 2do contiene el residuo de dividir
np.absolute(a)		#devuelve el valor absolute de elemento a elemento del array.	

*siendo a=np.array([1.231,4.765,5.652])    por ejemplo:

np.trunc(a)		#truncara todos los decimales y devolvera solo la parte entera de cada elemento del array.
np.fix(a)		#con fix también truncamos la parte decimal para devolver solo la parte entera
np.around(a)		#redondea al entero mas cercano, 
np.around(a,valor)	#redondera cada elemento del array a la cantidad de decimales que le pasemos por parametro 'valor'
np.round(a,valor)	#funciona igual np.que around
np.floor		#cálcula el maximo entero de cada elemento del array, es decir redondea a la baja. (n<=a<n+1)
np.ceil			#Cálcula maximo enetero por exceso de cada elemento del array, es decir redondea para arriba. (a<=n)



*--

np.sum(a)		#sumamos todos los elementos del array (es como tener un axis=None)
np.sum(a,axis=valor)	#sumamos sobre el eje que indiquemos en axis.

np.cumsum(a)			#hace una suma acumulada sobre el array 'a'.
np.cumsum(a,axis=valor)		#hace una suma acumulada sobre el eje indicado del array 'a'.


*Siendo x=[1,5,7], y=np.array([[[1,2],[5,6]],[[3,4],[7,8]]])
np.diff(x)			#Sirve para restar los elementos de forma consecutiva de un array
				devolvera: array[4,2]	 ya que; 5-1  7-5   (no se autoguarda)
np.diff(y,axis=valor)		#con axis elegimos sobre que eje queremos restar

np.diff(y,axis=valor,n=valor)	#el parámetro n indica cuantas veces vamos a repetir el proceso de restar(por defecto vale 1), si fuese n=2 una vez 					restado, restaria otra vez ya que n=2 


np.prod(a)			#Calculara el producto de todos los elementos del array.
np.prod(b,axis=valor)		#Calcula el producto de los elementos para ese eje.
np.cumprod(b)			#calcula el producto acumulado de los elementos de b
np.cumprod(b,axis=valor)	#calcula el producto acumulado sobre el eje valor de b.



np.lcm.reduce(a)		#sirve para calcular el minimo común multiplo de los elementos del array 'a'.
np.lcm.reduce(a,axis=valor)	#sirve para calcular el minimo común multiplo sobre el eje axis=valor del array 'a'.
np.gcd.reduce(a)		#sirve para calcular el maximo común divisor de los elementos del array 'a'.
np.gcd.reduce(a,axis=valor)	#sirve para calcular el maximo común disivor sobre el eje axis=valor del array 'a'.


*funciones trigonometricas
np.pi				#para obtener el valor de pi
np.sin(a)			#para calcular el seno de todos los elementos del array 'a'
np.cos(a)			#para calcular el coseno de todos los elementos del array 'a'.
np.tan(a)			#para calcular la tangente de todos los elementos del array 'a'.

np.deg2rad(a)			#convierte los elementos del array a tipo radianes
np.rad2deg(a)			#convierte los elementos del array a tipo grados sexagecimales

np.arcsin(a)			#calcula el arcoseno de los elementos del array 'a'
np.arccos(a)			#calcular el arcocoseno de los elementos del array 'a'
np.arctan(a)			#calcula el arcotangente de los elementos del array 'a'.

*funciones hiperbolicas
np.sinh(a)			#calcula el seno hiperbolico para los elementos del array 'a' 
np.cosh(a)			#calcula el coseno hiperbolico para los elementos del array 'a'
np.tanh(a)			#calcula la tangente hiperbolica para los elementos del array 'a'

np.arcsinh(a)			#calcula el arcoseno hiperbolico para los elementos del array 'a'.
np.arccosh(a)			#calcula el arcocoseno hiperbolico para los elementos del array 'a'.
np.arctanh(a)			#calcula el arcotangente hiperbolico para los elementos del array 'a'.


*tipo conjunto de los arrays, siendo 'a,b'  arrays.
np.unique(a)			#crea un array 1D con los valores unicos de 'a'. el nuevo array estara ordenado alfabetica y númericamente.
np.union1d(a,b)			#Crea un array 1D con los valores unicos, unidos y en orden de los arrays 'a' y 'b'.
np.intersect1d(a,b)		#Crea un array 1D con los valores de la intersección de los arrays 'a' y 'b'.
np.setdiff1d(a,b)		#Crea un array 1D con los valores de la diferencia de conjuntos 'a' y 'b'
np.setxor1d(a,b)		#Crea un array 1D con la diferencia simetrica de 'a' y 'b'




=======================================================================================================================================================
|					Sección 19: Tema17 - Representación gráfica en python							      |
=======================================================================================================================================================
Librerias necesarias:
---------------------
import matplotlib.pyplot as plt
import numpy as np
import datetime as dt
import seaborn as sns
import networkx as nx


General
-------
*Del módulo al que hemos renombrado 'plt':
	-usaremos el metodo .title() para añadir un titulo al plot
	-usaremos el metodo .xlabel() para añadir una etiqueta al eje horizontal del plot 2D
	-usaremos el metodo .ylabel() para añadir una etiqueta al eje vertical del plot 2D
	-usaremos el metodo .legend() para mostrar una leyenda



Colores
-------
*Python trae los siguientes colores por defecto:
	
	nombre	 abreviatura	color
	-------  -----------   --------
	blue	     b		azul
	green	     g		verde
	red	     r  	rojo
	cyan	     c		cian
	magenta	     m		magenta
	yellow	     y		amarillo
	black	     k		negro
	white	     w		blanco


-Colores primarios son: 			b,g,r
-Colores secundarios son:			c,m,y		(es el sistema de las impresoras)

-Cuando no pongamos un color primario: 		k		se toma por defecto el negro
-Cuando no pongamos un color secundario:	w		se toma por defecto el blanco

-el 100% para los colores primerios da:		w		el blanco	
-el 100% para los colores secundarios da:	k		el negro


*Más colores de matplotlib
--------------------------
-El módulo matplotlib dispone de mucho más colores aparte de los colores por defecto(ver la clase sección 19 en colab).



*Colores en formate hexadecimal
-------------------------------
-matplotlib no solo acepta el nombre de los colores, sino también el formato hexadecimal.

*mapa de colores
----------------
-matplotlib tiene disponibles una serie de mapas de colores.
MAPA DE COLOR: Se trata de una lista de colores, donde cada color tiene un valor entre 0 y 100.
-Los mapas de colores disponibles en python pueden verse aquí junto con una breve explicación de cada clase de mapa de color.


Paleta de colores
-----------------
seaborn dispone de unas cuantas paletas de colores que pueden verse aquí.



======================================================================
		NUBE DE PUNTOS CON MATPLOTLIB.PYPLOT
======================================================================
import matplotlib.pyplot as plt
import numpy as np


	Scatter plot
---------------------------------
*Para hacer un gráfico nube de puntos, usamos el método .scatter() del módulo plt.
*Algunos de los parametros de este metodo son:
	-x: scalar, array o lista que indica la primera coordenada de las observaciones
	-y: scalar, array o lista que indica la segunda coordenada de las observaciones
	-c: para cambiar el color de relleno
	-edgecolors: para cambiar el color de entorno
	-alpha: para cambiar la transpariencia
	-marker: para cambiar la forma del punto (en clase tenemos sección 19 tenemos un enlace para ver todas las formas de los puntos)
	-s: para cambiar el tamaño de los puntos
	-linewidths: para cambiar el grosor del contorno
	
plt.show()			#para mostrar todo lo que hemos preparado en matplotlib (mostrar el gráfico)

Ejemplo:
- - - - -
height = [174.3, 153.5, 162.1, 157.9, 174.8, 169.2, 172.0, 160.4, 152.8, 163.3] 
weight = [ 65.7,  59.2,  57.3,  61.5,  77.3,  90.7,  85.4,  63.1,  73.2, 105.5]

plt.title("Altura vs pesos")
plt.xlabel("Alturas (cm)")
plt.ylabel("Pesos (kg)")
plt.scatter(x=height,y=weight, alpha=0.5	
            c="black",edgecolors="red",
            marker="X",s=200,linewidth=2)

plt.show()


Ejemplo2:
- - - - -
*también podemos juntar 2 gráficos en uno mismo. (claro si hablamos de las mismas carácteristicas)

height_boys = [174.3, 153.5, 162.1, 157.9, 174.8, 169.2, 172.0, 160.4, 152.8, 163.3] 
weight_boys = [65.7, 59.2, 57.3, 61.5, 77.3, 90.7, 85.4, 63.1, 73.2, 105.5]

height_girls = [154.2, 156.1, 160.3, 157.9, 162.6, 153.9, 170.1, 165.2, 157.6, 163.5] 
weight_girls = [55.3, 54.2, 47.3, 62.4, 77.5, 60.3, 52.4, 58.1, 50.2, 80.1]


plt.scatter(x=height_boys,y=weight_boys,s=100,marker="^",c="red")
plt.scatter(x=height_girls,y=weight_girls,s=100,marker="v",c="blue")
plt.show()



Ejemplo3:
---------
*también podemos dibujar cada punto con un tamaño diferente, pasando una lista.	

x=[1,2,3,4,5,6,7]
size=[100,150,200,250,300,350,400]			#el tamaño de la lista de colores debe ser el mismo que la cantidad puntos

plt.scatter(x=x,y=x,s=size,c="m",alpha=0.5)
plt.show()



Ejemplo4:
- - - - -
*Sacamos los colores de un 'mapa de colores', para ello usamos el atributo 'cmap="nombreDelmapa"'
*Recuerda que los mapas de colores van del [0-100]

colors=np.array([0,10,20,30,40,50,60])				#pasamos un rango de valores que actuaran sobre le mapa.

plt.scatter(x=x,y=x,c=colors,cmap="plasma",s=200)		#usamos el mapa de colores 'plasma'
plt.colorbar()							#nos mostrara una barra del mapa de color que hayamos utilizado 
plt.show()




Line plot con matplotlib.pyplot
--------------------------------
*Dibuja puntos unidos por una linea.
*Para hacer un gráfico line plot, usamos el método '.plot()' del módulo 'plt'.
*Algunos de los parámetros de estos métodos son:(son muchos parámetros que hay, solo veremos algunos)
	-x: scalar, array o lista que indica la primera coordenadas de las observaciones
	-y: scalar, array o lista que indica la segunda coordenadas de las observaciones
	-color: para cambiar el color del relleno. También podemos referirnos a este parámetro por su diminutivo 'c'.
	-fmt: para establecer un formato básico rápidamente como string. Por ejemplo, 'or' son circulos rojos. El orden recomendado para
	      introducir el formato de este modo es '"[marker][linestyle][color]"', aunque también se admite "[color][marker][linestyle]".
	-liwidth: para cambiar el grosor de la linea. también podemos referirnos a este parametro por su diminutivo 'lw'.
	-linestyle: para cambiar el estilo de la linea. también podemos referirnos a este parametro por su diminutivo 'ls'
	-alpha: para cambiar la transpariencia
	-marker: para cambiar la forma del punto. Si no indicamos este parametro, no se dibujan los puntos.
	-markersize: para cambiar el tamaño de los puntos. también podemos referirnos a este parametro por su diminutivo 'ms'
	-markeredgecolor: para cambiar el color del contorno del punto.También podemos referirnos a este parametro por su diminutivo 'mec'
	-markerfacecolor: para cambiar el color de relleno del punto. También podemos referirnos a este parametro por su diminutivo 'mfc'
	
	
*Para el parametro 'fmt', las opciones disponibles para el "'marker''linestyle''color'" son:

marker		forma				linestyle		estilo de línea		   color		color
------  	-----				------------		---------------		-----------		------
"."		punto				"-" o "solid"		sólido			"b" o "blue"		azul
","		píxel				"--" o "dashed"		discontinuo		"g" o "green"		verde
"o"		círcu	lo			"-." o "dashdot"	guión-punto		"r" o "red"		rojo
"v"		triángulo hacia abajo		":" o "dotted"		puntos			"c" o "cyan"		cian
"^"		triángulo hacia arriba		"None"			sin línea		"m" o "magenta"		magenta
"<"		triángulo hacia izquierda							"y" o "yellow"		amarillo
">"		triángulo hacia derecha								"k" o "black"		negro
"1"		tri hacia abajo									"w" o "white"		blanco
"2"		tri hacia arriba				
"3"		tri hacia izquierda				
"4"		tri hacia derecha				
"s"		cuadrado				
"p"		pentágono				
"*"		estrella				
"h"		hexágono 1				
"H"		hexágono 2				
"+"		cruz				
"x"		x				
"D"		diamante				
"d"		diamante fino				
"|"		barra vertical				
"_"		barra horizontal


Ejemplo1:
- - - - -

height = [174.3, 153.5, 162.1, 157.9, 174.8, 169.2, 172.0, 160.4, 152.8, 163.3] 
weight = [ 65.7,  59.2,  57.3,  61.5,  77.3,  90.7,  85.4,  63.1,  73.2, 105.5]

plt.title('Alturas vs Pesos')
plt.xlabel('Alturas (cm)')
plt.ylabel('Pesos (kg)')

plt.plot(sorted(height),weight,c='blue',ls="--",lw=2,marker="*",ms=20,mfc='m')
plt.show()



Ejemplo2:
- - - - -
plt.title('Alturas vs Pesos')
plt.xlabel('Alturas (cm)')
plt.ylabel('Pesos (kg)')
plt.plot(sorted(height),weight,"*--b",lw=2,mfc="m",ms=20)
plt.show()



Ejemplo3:
- - - - -

rainy_days = [20, 15, 19, 25, 13, 8, 3, 5, 10, 16, 20, 18]

plt.title("Días de lluvia por mes")
# (0 = Enero, 1 = Febrero, ..., 11 = Diciembre)
plt.xlabel("Mes")
plt.ylabel("Total días de lluvia")

plt.plot(rainy_days,c='cyan',marker="o")
plt.show()



Ejemplo4:
- - - - - 

l1=np.array([3,5,1,9])
l2=np.array([8,2,6,4])

plt.plot(l1,c='blue',marker="v")
plt.plot(l2,c='magenta',marker="^")
plt.title('2 lineas en un plot')
plt.show()



BAR PLOT
--------
*!Nota¡ una barra no es lo mismo que un histograma. Esto es útil para valores discretos.
*Para hacer un gráfico de barras, usamos el método .bar() del módulo plt.
*Algunos de los parámetros de este método son:
	-x: float, array o lista que indica la categoria o coordenadas de la barra.
	-height: float, array o lista que indica las alturas de las barras
	-width: para cambiar la anchura de las barras
	-linewidth: para cambiar el tamaño de los bordes de las barras
	-bottom: para cambiar el valor vertical mínimo de las barras
	-align: posición de la marca del eje horizontal con respecto a la base de las barras. Por defecto vale 'center'. [center o edge]
	-color: Para cambiar los colores de las barras. Si pasamos una lista, podemos asignar un color diferente a cada barra
	-edgecolor: Para cambiar el color del borde las barras.


Ejemplos:
- - - - - 
grades=['suspenso','aprobado','notable','excelente']
count=[35,55,23,7]
colo=['#ff7f7d','#ffc07d','#817dff','#7dff86']

plt.title('Notas de los alumnos de una clase')
plt.xlabel('Notas')
plt.ylabel('Número de alumnos')

plt.bar(grades,count,width=0.9,color=colo)
plt.show()

Ejemplos2:
- - - - - -
grades=['suspenso','aprobado','notable','excelente']
count=[35,55,23,7]
colo=['#ff7f7d','#ffc07d','#817dff','#7dff86']

plt.title('Notas de los alumnos de una clase')
plt.xlabel('Notas')
plt.ylabel('Número de alumnos')

plt.barh(grades,count,color=colo,height=0.8)
plt.show()



GRÁFICO DE SECTORES CON MATPLOTLIB.PYPLOT
------------------------------------------
PIE CHART:
----------
*Para hacer un gráfico de sectores, usamoes el método .pie() del módulo plt.
*Algúnos de los parámetros de este metodo son:
	-x: array1D o lista 
	-labels: para especificar las etiquetas
	-colors: Para cambiar los colores de los sectores. Si pasamos una lista, podemos asignar un color diferente a cada sector circular.
	-autopct: para editar el formato en que se muestre el porcentaje
	-labeldistance: para ajustar la distancia radial de las etiquetas
	-radius: para modificar el radio del gráfico
	-startangle: para cambiar el ángulo (en grados) con el que se empieza (por defecto es '0')
	-explode: vector de distancia para indicar como de separados queremos que este el sector correspondiente del resto.
	-shadow: para añadir sombra a los sectores
 	

Ejemplos:
- - - - -
option=['con','sin']
count=[20,80]
plt.title('¿Pizza con o sin piña?')
plt.pie(count,colors=['#ff85b0','#85ffac'],labels=option,autopct="%0.1f%%",labeldistance=1.2,radius=1.2,startangle=180,explode=(0.1,0.0001),
        shadow=1)
plt.show()


Ejemplo2:
- - - - -
plt.pie(count, colors = ["#ff85b0", "#85ffac"], labels = options, 
        startangle = 90, explode = [0.2, 0], shadow = True)
plt.title("¿Pizza con o sin piña?")
plt.legend(title = "Opciones")
plt.show()



HISTOGRAMA CON MATPLOTLIB.PYPLOT
--------------------------------
Histogram
---------
*Util para hacer barras para valores continuos.	
*Para usar un histograma, usamos el método .hist() del módulo plt.
*Algunos de los parámetros de este método son:
	-x: array o lista de observaciones
	-bins: para especificar el tamaño de los intervalos
	-range: para especificar el mínimo y el maximo de las bins.
	-histtype: para indicar que tipo de histograma queremos dibujar.
	-align: para configurar la alineación de las barras del histograma
	-orientation: para modificar la orientación del histograma (verticla u horizontal)
	-color: para modificar el color de las barras 
	-edgecolor: para modificar el color de contorno de las barras.



TIEMPO CON DATETIME
--------------------
*Una fecha en python no es un tipo de dato por si mísmo, pero podemos trabajar con estos objetos tan peculiares con el módulo 'datetime'


import datetime as dt

Ejemplo:

today=dt.datetime.now()
print(today)			#Mostrara la fecha actual y la hora(incluído milisegundos) completa.


today.hour
today.minute
today.second
today.year
today.microsecond
today.day
today.month



CREANDO OBJETOS DATETIME Y EL FORMATO
--------------------------------------
*Para crear objetos datetime usamos el método .datetime() (este método es un constructor)
*Este método toma como parámetro dt.datetine(year,month,day,hour,minute,second,microsecond). Los 3 parámetros relacionados con la fecha, son parámetros obligatorios. Los parámetros restantes, los relacionados con el tiempo son opcionales.

Ejemplo:
- - - - -
d=dt.datetime(2020,9,22,12,30)
print(d)		#mostrara la fecha 2020-09-22  12:30:00


d.strftime(format='nombreFormat')
	
*Valores para 'nombreFormat':
	
%Y	Año, versión completa
%y	Año, versión abreviada (sin siglo)
%B	Mes, versión completa (idioma inglés)
%b	Mes, versión abreviada (idioma inglés)
%m	Mes, versión numérica
%d	Día del mes
%j	Día del año, 001-366
%A	Día de la semana, versión completa (idioma inglés)
%a	Día de la semana, versión abreviada (idioma inglés)
%w	Día de la semana, versión numérica (0 = Domingo, 1 = Lunes, ..., 6 = Sábado)
%W	Semana del año, con lunes como primer día
%U	Semana del año, con domingo como primer día
%H	Hora, 00-23
%I	Hora, 00-12
%p	AM / PM
%M	Minuto, 00-59
%S	Segundo, 00-59
%f	Microsegundo, 000000-999999
%Z	Zona horaria
%z	Offset de UTC
%c	Versión local de fecha y hora
%x	Versión local de fecha
%X	Versión local de hora
%%	Caracter %
%G	Año ISO 8601
%u	Día de la semana ISO 8601
%V	Semana del año ISO 8601


*Observación. Cuando decimos offset de UTC, nos referimos a la cantidad de horas a las que se encuentra la zona horaria del Tiempo Universal Coordinado (UTC)



EJemplos:
---------
print(d.strftime('%d-%m-%Y %H:%M%S'))

print(d.strftime('%d %b %Y, %I:%M%p'))

D=dt.datetime.strptime('06 June 1994','%d %B %Y')
D 



ZONAS HORARIAS
---------------
*Las zonas horarias son un poco mas complejas que lo que hemos visto hasta el momento sobre objetos datetime.
*Por defecto ya hemos visto que un objeto datetime no contiene información acerca de la zona horaria.


import pytz		#permite trabajar con zonas horaricas




Series temporales con matplotlib.pyplot
----------------------------------------
*Ahora que ya sabemos manituplar la fechas, podemos hablar de como representar datos en función del tiempo.
*Para representar series temporales con matplotlib, usamos el metodo .plot_date()

Ejemplo:
--------
dates = ["1/9/2020", "2/9/2020", "3/9/2020", "4/9/2020", "5/9/2020",
         "6/9/2020", "7/9/2020", "8/9/2020", "9/9/2020", "10/9/2020",
         "11/9/2020", "12/9/2020", "13/9/2020", "14/9/2020", "15/9/2020",
         "16/9/2020", "17/9/2020", "18/9/2020", "19/9/2020", "20/9/2020",
         "21/9/2020", "22/9/2020", "23/9/2020", "24/9/2020", "25/9/2020",
         "26/9/2020", "27/9/2020", "28/9/2020", "29/9/2020", "30/9/2020"]

x=[dt.datetime.strptime(d,"%d/%m/%Y").date() for d in dates]		#.date() del objeto 'datetime.datetime' solo obtiene la fecha más no la hora.
									x sera una lista elementos tipo datetime.datetime obtenidos de la lista dates. 		
y=np.random.randint(10000,20000,len(x))

plt.xticks(rotation=90)
plt.title('Total Ventas en Setiembre 2020')
plt.xlabel('Día del mes')
plt.ylabel('Total ventas')
plt.plot_date(x,y,c='blue',ls='--',lw=2,tz="Europe/Madrid")
plt.show()



Dibujar textos con plt.text()
----------------------------------
plt.text(x,				#x tendra el valor que ocupa en el eje 'x'
	 y,				#y tendra el valor que ocupa en el eje 'y'
	 s,				#s vendra a ser el string que deseamos mostrar
	 horizontalalignmnet=''		#para alizar el texto en base al punto de las coordenadas dadas donde ira, 'center' centro del string tratara 						de coincidir con el punto, 'left' el punto estara a la izquiera, 'right' el punto estara a su derecha	
					(forma abreviada 'ha')
	 verticalalignment=''		#lo mismo que 'horizontalalignment' pero para la vertical (forma abreviada 'va')

	 rotation=valor			#para rotar en sentido antihorario, 'valor' estara en grados sexagesimales
	 fontsize=valor			#tamaño de las letras del string
	 bbox=dict(parametros)		#bbox sirve para darle carácteristicas al texto (como bordearlo, darle color, rellenarlo,etc)
	 bbox=dict(boxstyle='name'	#ponerlo dentro de una figura ()
		   facecolor='nameColor'   #color del relleno (forma abreviada 'fc')
		   edgecolor='nameColor'   #color del borde (forma abreviada 'ec')
		   alpha=valor		   #valor de la transparencia, es un escalar.
 		   
)

		EL MODULO SEABORN
======================================================
import seaborn as sns

*Para ver todo lo que nos puede aportar 'seaborn', vamos a trabajar con una serie de datasets de este mismo módulo:
*Algúnos dataset ya incorporados en seaborn son:
	-titanic :pasajeros del titanic
	-penguins:pinguinos
	-tips	 :propinas
	-flights :vuelos


Ejemplo:
--------
titanic=sns.load_dataset('titanic')			#nos permite leer un dataset que tiene por defecto seaborn
titanic.head()

tips=sns.load_dataset('tips')

	Scatter plot
-----------------------------
*Para hacer un gráfico de nuevs de puntos, usamos el método '.scatterplot()' del modulo 'seaborn'.
algunos parametros de .scatterplot son:
	-data: pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	-x: variable que indica las posiciones en el eje horizontal
	-y: variable que indica las posiciones en el eje vertical
	-sizes: para indicar el tamaño de los puntos
	-size: variable que divide las observaciones y produce puntos de diferentes tamaños.
	-markers: para indicar el tipo de punto
	-style: variable que divide las observaciones y produce puntos de diferentes estilos.
	-palette: para indicar los colores o paleta de colores
	-hue: variable que divide las observaciones y produce puntos de diferentes colores
	-color: para modificar el color de todos los elementos.


Ejemplo1:
- - - - -
sns.scatterplot(data=tips,x='tip',y='total_bill',color='purple')
plt.xlabel('propina')
plt.ylabel('total pagado')
plt.title('Propina vs Total pagado')


Ejemplo2:
- - - - -
sns.scatterplot(data=tips,x='tip',y='total_bill',color='purple',hue='sex',palette=['blue','red'])
plt.xlabel('propina')
plt.ylabel('total pagado')
plt.title('Propina vs Total pagado')


Ejemplo3:
- - - - -
sns.scatterplot(data=tips,x='tip',y='total_bill',color='purple',
                hue='sex',palette=['blue','red'],
                style='sex',markers=['^','v'])

plt.xlabel('propina')
plt.ylabel('total pagado')
plt.title('Propina vs Total pagado')

Ejemplo4:
- - - - -
sns.scatterplot(data=tips,x='tip',y='total_bill',color='purple',
                hue='sex',palette=['blue','red'],
                style='sex',markers=['^','v'])


plt.xlabel('propina')
plt.ylabel('total pagado')
plt.title('Propina vs Total pagado')


Ejemplo5:
- - - - -
tips['size'].unique()		#con esto sabemos cuantos valores unicos tiene la columna 'size', estos lo usaremos en dar esa cantidad de valores en 					el atributo sizes

sns.scatterplot(data=tips,x='tip',y='total_bill',color='purple',
                hue='sex',palette=['blue','red'],
                style='sex',markers=['^','v'],
                size='size',sizes=[50,100,150,200,250,300])

plt.xlabel('propina')
plt.ylabel('total pagado')
plt.title('Propina vs Total pagado')


Line plot con seaborn
----------------------
*Para hacer un gráfico line plot, usamos el método .lineplot() del módulo seaborn
Algunos de los parametros son:
	-date	:pd.DataFrame, np.ndarry o estructura de datos de las cuales provienen las variables.
	-x	:Variable que indican las posiciones de los puntos en el eje horizontal
	-y	:Variable que indican las posiciones de los puntos en el eje vertical
	-sizes	:para indicar el tamaño de las lineas
	-size	:variable que divide las observaciones y produce lineas de diferentes tamaños
	-markes	:para indicar el tipo de línea
	-style	:variable que divide las observaciones y produce línea de diferentes estilos
	-palette:Para indicar los colores o paleta de colores
	-hue	:variable que divide las observaciones y produce lineas de diferentes colores
	-color	:para modificar el color de todos los elementos
	

Ejemplo:
- - - - -
flights_jan=flights.query('month == "Jan"')

sns.lineplot(data=flights_jan,x='year',y='passengers')

sns.lineplot(data=flights,x='year',y='passengers',
             hue='month',palette=sns.color_palette('hls',12))
plt.legend()
plt.show()



GRÁFICO DE BARRAS CON SEABORN
-------------------------------------
*Para hacer un gráfico de barras, usamos el método .barplot() del módulo 'seaborn'
*Algunos de los parámetros de este método son:
	-data: pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	-x: variable categorica que indica las categorias de las barras
	-y: variable númerica que indica las alturas de las barras
	-order: para indicar el orden de las variables categoricas
	-palette: para indicar los colores o caletas de colores
	-hue: variable que divide las observaciones y produce barras de diferentes colores
	-color: Para modificar el color de todos los elementos
	-orient: para modificar la horientación de las barras ('v':vertical, 'h':horizontal)
	-ci: tamaño del intervalo de confianza


Ejemplo:
- - - - -
sns.barplot(data=titanic,
            x='class',y='fare',
            hue='who',palette=sns.color_palette('hls',3))
plt.show()  


Ejemplo2:
- - - - -
sns.barplot(data=titanic,
            y='class',x='fare',
            hue='who',palette=sns.color_palette('hls',3), orient='h')
 
plt.show()  


HISTOGRAMA CON SEABORN
------------------------
*Para hacer histogramas con seaborn, se usa el metodo .histplot()
*Algunos de los parámetros para sns.histplot son:

sns.histoplot(
	data: pd.DataFrame, np.ndarray o estructura de datos de cuales proviene las variables
	x: variable que indica la posición de las observaciones en el eje horizontal
	y: variable que indica la posición de las observaciones en el eje vertical
	palette: para indicar los colores o la paleta de colores
	hue: varible que divide las observaciones y produce la líneas de diferentes colores
	color: para modificar el color de todos los elementos
	stat: estadistico para computar cada barra (bin)
	bins: número de barras o extremos de los intervalos de cada barra
	binwith: para modificar la anchura de cada barra
	binrange: para modificar el rango de los valores
	cumulative: booleano para indicar si se trata de un gŕafico acumulativo o no
	kde: para añadir o no una estimador de densidad
	multiple: forma de mostrar múltiples elementos('layer':por capas, 'dodge':por separado,'stack':apilados,'fill':proporción)
	element: representación visual de la estadistica del histograma ('bars':barras,'step':escalones,'poly':polígonos)


Ejemplo1:
- - - - -

sns.histplot(data=penguins,x='body_mass_g',binrange=(2500,7000),kde=True,binwidth=500,
             hue='species', color=sns.color_palette('hls',3))
plt.show()


Ejemplo2:
- - - - -
sns.histplot(data=penguins,x='body_mass_g',binrange=(2500,7000),kde=True,binwidth=500,
             hue='species', color=sns.color_palette('hls',3),multiple='dodge')

plt.show()


Ejemplo 3:
- - - - - -
sns.histplot(data=penguins,x='body_mass_g',stat='count',binwidth=500,binrange=(2500,7500), 
             element='poly',kde=True,hue='species',palette='rocket')



GRÁFICO DE DENSIDAD CON SEABORN
----------------------------------
*Para hacer un gráfico de densidad, usamos el método .kdeplot() del modulo seaborn.
*Algunos de estos parámetros son:
	-data: pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	-x: variable que indica las posiciones de las observaciones en el eje 'x'.
	-y: variable que indica las posiciones de las observaciones en el eje 'y'.
	-palette: para indicar los colores o paletes de colores
	-hue: variable que divide las observaciones y produce líneas de diferentes colores.
	-color: para modificar el color de todos los elementos
	-legend: para indicar si queremos la leyenda 
	-rug: valor booleano para visualizar la variable unidimensional en los ejes de dibujo
	-multiple: forma de mostrar múltiples elementos ('layer': por capas, 'dodge':por separado, 'stack': apilados, 'fill':proporción)


Ejemplo:
--------
sns.kdeplot(data=titanic,x='fare',color='#817dff')
plt.title('Edad por sexo')
plt.xlabel('Edad')
plt.ylabel('Densidad')
plt.show()


Ejemplo2:
- - - - -
sns.kdeplot(data=titanic,x='age',hue='sex',palette='magma',multiple='fill')
plt.xlabel('Edad')
plt.ylabel('Densidad')
plt.show()



GRAFICO CON DISPLOT DE SEABORN
---------------------------------
*sns.displot (OJO: no es distplot )
*Nos permite elegir con el atributo 'kind="tipoGrafico"' el tipo de gráfico que queremos usar
*algunos parametros para sns.displot son:
*depende al valor que tenga 'kind' variaran los parametros que acepte

sns.displot(data=nameData
-data: pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	-x: variable que indica las posiciones de las observaciones en el eje 'x'.
	-y: variable que indica las posiciones de las observaciones en el eje 'y'.
	-palette: para indicar los colores o paletes de colores
	-hue: variable que divide las observaciones y produce líneas de diferentes colores.
	-color: para modificar el color de todos los elementos
	-rug=valorBool	:muestra una sombra, cada rayita de la sombra indica que hay 1 o más observaciones ahí
	-kind='nameGrafico' : 'hist' para hacer un histograma, 'kde' para hacer graficos de densidad (probabilidad), 
			      'ecdf' graficos de densidad acumulada
)			


Ejemplos:
- - - - -
sns.displot(data=titanic,x='age',y='survived',kind='hist')


Ejemplo2:
- - - - -
a=sns.displot(data=titanic,x='age',y='survived',kind='kde',hue='who')


Ejemplo3:
- - - - -
sns.displot(data=penguins,x='flipper_length_mm',y='bill_length_mm',kind='kde', fill=True,hue='species',rug=True)
plt.title('Aletas vs Picos')
plt.show()




BOX PLOT CON SEABORN
----------------------
*Para hacer un gráfico de caja y bigotes, usamos el método .boxplot() del módulo .seaborn
*Algúnos de los parámetros de este metodo son:
	-data: pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	-x: variable indica las categorias
	-y: variable nímerica
	-palette: para indicar los colores o paleta de colores
	-hue: variable que divide las observaciones y produce lineas de diferentes colores
	-color: para modificar el color de todos los elementos
	-linewidth: para modificar la anchura de las lineas	
	-order: para reordenar las categorias
	-orient: para modificar la orientación ('horizonta'  o  'vertical')


*Este tipo de gráfico nos permite añalizar las distribuciones de valores sobre las categorias dadas. 
*La caja de bigotes se interpreta de esta manera:
	-la caja representa el 50%(si la caja es vertical, el extremo de abajo hasta el bigote de abajo representa el 25%, la linea cuantil el 50% y 					   el extremo de arriba 75% hasta el extremo superior del bigote)
	
	-el linea dentro de la caja es el cuantil del 50%
	-los bigotes(las lineas fuera de la caja) tienen una longitud de maxima por defecto 1.5 el tamaño de la caja(varia dependiendo entre que rango 		 varian los valores de las categorias)
	-los autslayer(puntitos negros fuera de los bigotes), representan a los valores que superar la condición del bigote.
		

Ejemplos
- - - - -
sns.boxplot(data=tips,x='day',y='tip')



Ejemplo2
- - - - -
sns.boxplot(data=tips,x='time',y='tip', hue='day')





			MULTIPLES PLOTS
------------------------------------------------------------------
	El método .subplot() de plt
---------------------------------------------
*Con el método '.subplot()' podemos dibujar múltiples plots en una misma figura. 
*Este método toma 3 parámetros que describen la layout de la figura. La layout se organiza en filas y columnas, que son representadas por los primeros parámetros. El tercer parametro representa el indice que ocupa el plot actual.


Ejemplo:
- - - - -
#plot 1
l1=np.array([3,5,1,9])

plt.subplot(2,1,1)
plt.plot(l1,c='magenta',ls=":",lw=2)

#plot 2
l2=np.array([8,2,6,4])

plt.subplot(2,1,2)
plt.plot(l2)

plt.show()


*todo lo que pongas despues al .subplot sera relativo a ese subplot que pusimos, sea .title() ,etc.


#plot 1
l1=np.array([1,3,5,7,2,3,1,2,4,6,8,9,1,2,5])

plt.subplot(2,4,1)
plt.title('subplot1')
plt.hist(l1, histtype='barstacked',edgecolor='k')

#plot 2
l2=np.array([[28,17,55]])
option=['con','sin','elle']

plt.subplot(2,4,2)
plt.title('subplot2')
plt.pie(l2,autopct='%1.0f%%',labels=option,radius=1)

#plot 3

colores=random.randint(0,101,size=344)

plt.subplot(2,4,3)
plt.title('subplot3')
plt.scatter(x=penguins['flipper_length_mm'],y=penguins['bill_length_mm'],c=colores,cmap='viridis')

#plot 4
l4=np.array([1,3,5,7,2,3,1,2,4,6,8,9,1,2,5])


plt.subplot(2,4,4)
plt.title('subplot4')
plt.plot(l4,ls=':',marker='*',mfc='white')

#plot 5
l5=np.array([[1,3,5,7,2,3,1 ],
             [2,4,6,8,9,1,2]])

plt.subplot(2,4,5)
plt.title('subplot5')
plt.bar(l5[0],l5[1],color='magenta')


#plot 6
ll6=['19/6/2021','20/6/2021','21/6/2021','22/6/2021']
t6=random.randint(2000,3000,size=4)

l6=[dt.datetime.strptime(d,'%d/%m/%Y').date() for d in ll6]
plt.subplot(2,4,6)
plt.title('subplot6')
plt.yticks(rotation=90)
plt.xticks(rotation=-45)
plt.plot_date(l6,t6)


#plot 7

plt.subplot(2,4,7)
plt.title('subplot7')
sns.kdeplot(data=penguins,x='flipper_length_mm',y='bill_length_mm',fill=True,cut=True,hue='species',legend=False)



#plot 8
plt.subplot(2,4,8)
plt.title('subplot8')
sns.boxplot(data=penguins,x='species',y='bill_length_mm')
plt.xticks(rotation=45)

plt.suptitle('Ejercicios')
plt.show()



	MULTIPLES PLOTS EN UNO CON .add_subplot()
---------------------------------------------------------------

El método .add_subplot() de plt
---------------------------------
* Con el método 'plt.add_subplot()' también podemos dibujar múltiples plots en una misma figura.
* La ventaja de este metodo es que aquí no es necesario que todos los layout sean del mismo tamaño, pueden haber layout mas grandes
* Para ello tenemos que seguir los siguientes pasos
	-Crear el objeto 'figure' con el método plt.figure()
	-indicar el número de filas y de columnas que queremos con el método .add_gridspec()
	-Crear tantos subplots como queramos mostrar con el método plt.add_subplot() e indicar las posiciones que van a tomar cada una de ellos.


#Paso1
#creamos el objeto figure
fig=plt.figure(constrained_layout=True)			#creamos el objeto figure y lo guardamos en una variable, 'constrained_layout' es un tipo de 
							tamaño y carácteristicas que tendra nuestro objeto

#paso2
#Configuramos que tendrá 3 filas y 4 columnas
gs=fig.add_gridspec(3,4)				#indicamos que nuestro layot 'fig' tendra 3 filas y 4 columnas			

#paso3:
#Creamos los subplots. En este caso creamos 3 layout


#1er layout, * Ocupa todas las filas y todas las columnas salvo la ultima
fig_ax1=fig.add_subplot(gs[:,:-1])			#aquí indicamos que filas y columnas ocupara sobre el layout figure (en el ejemplo con la 								sintaxis del corchete indicamos que ocupe todas las, menos la ultima columna)
fig_ax1.set_title('gs[:,:-1]')				#para agregar el titulo a este layout


#2do layout, * Ocupa todas las filas salvo la ultima para la ultima columna
fig_ax2=fig.add_subplot(gs[:,-1])				#ocupa todas las filas sobre la ultima columna
fig_ax2.set_title('gs[:,:-1]')				



#3er layout, * Ocupa todas la ultima fila y la columna ultima
fig_ax3=fig.add_subplot([-1,-1])			#ocupa de la ultima fila la ultima columna
fig_ax2.set_title('gs[:,:-1]')

plt.show()



EJEMPLO:
- - - - -

figure=plt.figure(constrained_layout=True)
gs=figure.add_gridspec(3,4)

fig1=figure.add_subplot(gs[:,:-1])
fig1.bar(notes,count,color=sns.color_palette('hls',4))		#Ya no es necesario ponet 'plt' para hacer un gráfico, simplemente el nombre de la 									referencia de la ocupación de 'fig' y luego el nombre de la barra

fig2=figure.add_subplot(gs[:-1,-1])
fig2.pie(count,labels=notes,autopct='%1.0f%%',colors=sns.color_palette('hls',4))

fig3=figure.add_subplot(gs[-1,-1])
fig3.barh(notes,count,color=sns.color_palette('hls',4))			

	












-----------------------------------------------------------------------
|		MULTIPLES PLOTS EN UNO CON SEABORN		      |
-----------------------------------------------------------------------
*Es hacer multipes layout en un mismo layout
*para crear la parrilla(el layout principal) usamos el metodo sns.FacetGrid y para indicarle cuantos layout contendra en filas usamos rows='nameColumn', con rows indicamos cuantos layout habran en la fila 


*Los datos representados en este apartado croceden a los dataset 'anscombe' y 'dots'
Es decir, trabajaremos con esos dataset para los ejemplos y así entender mejor este tema
anscombe=sns.load_dataset('anscombe')
dots=sns.load_dataset('dots')


Ejemplo1:
- - - - -
grid=sns.FacetGrid(anscombe,row='dataset')		#creamos en base a la columna 'dataset' de anscombe filas para cada valor de esta.

grid=sns.FacetGrid(anscombe,col='dataset')		#creamos en base a la columna 'dataset' de anscombe columnas para cada valor de esta.
grid=sns.FacetGrid(anscombe,col='dataset',col_wrap=2)	#con 'col_wrap' indicamos cuantas columnas aceptamos por maximó por fila, una vez cumplido 								 crea una fila nueva


grid.cmap(sns.scatterplot,'x','y')			#creamos un gráfico de tipo indicado sobre 'grid' y le pasamos como que trabajara con la 								 columna 'x','y'. (creara este tipo de gráfico a todos los layout)
 


Ejemplo2:
- - - - -
grid=sns.FacetGrid(dots,col='choice',hue='align')	#con hue='aling' indicamos que nos los va a coloear en función a los 'aling' del dataset dots 

grid=sns.FacetGrid(dots,col='choice',hue='align',palette=[colores o paleta])	#con palette indicamos los colores que va recibir(misma cantidad de 											divisiones indicadas con hue)

grid.map(sns.scatterplot,'time','firing_rate')
grid.map(sns.scatterplot,'time','firing_rate',alpha=0.5)			#con alpha indicamos la traspariencia

grid.add_legend()					#para añadir la leyenda de colores que estamos usando





Ejemplo3:
- - - - -
grid=sns.FacetGrid(dots,col='choice',row='align')	#el layout 'choice' se divide para cada 'align' (estos iran en una nueva fila cada 'aling 								 distinto) 
grid.map(sns.scatterplot,'time','firing_rate',alpha=0.5,color='purple')		#'color' pinta a todos los elementos del layout 
grid.add_legend() 				#muestra la leyenda


Ejemplo4:
- - - - -
grid=sns.FacetGrid(dots,col='choice',row='align',margin_titles=True)		#margin_title=True indica que el titulo de cada layout estara divido 
										en filas y columnas (ver ejemplo en gŕafico para entender mejor)
grid.map(sns.scatterplot,'time','firing_rate',alpha=0.5,color='k')




Ejemplo5:
- - - - -
grid=sns.FacetGrid(dots,col='choice',row='align',
		   margin_titles=True,height=5,aspect=2/3)		# con height=5 indicamos la altura de todos los layout
									  con aspect=2/3 indicamos el ancho de cada layout respecto a la altura
									  (es como si en realidad fuera 2/3*5)

grid.map(sns.scatterplot,'time','firing_rate',alpha=0.5,color='k')		



-----------------------------------------------------
|		GRAFOS CON NETWORK		    |
=====================================================
*El módulo 'networkx' nos va a permitir representar grafos.

*GRAFO: Conjunto de objetos llamados nodos unidos por enlaces llamados aristas, que permite representar relaciones binarias entre elementos de un conjunto.


import networkx as nx			#importamos este modulo para trabajar con grafos

G=nx.Graph()				#Creamos un objeto 'Graph' vacio y lo guardamos en la variable 'G'
type(G)					#el tipo de dato es 'networkx.classes.graph.Graph'	

G.add_node(1)				#Con esta instrucción añadimos el nodo 1 al Grago 'G'. (los nodos también pueden ser letras)
					Hay otras formas de añadir nodos. Por ejemplo, a partir de un objeto iterable como una lista y haciendo uso
					del método '.add_nodes_from()'

G.add_nodes_from([2,3])			#añadimos al gráfo 'G' Los nodos 2 y 3 (elementos del iterable "es decir, de una lista")
					*podemos pasar también 'caracteres o string'

G.add_nodes_from('string')		#añade al gráfo 'G' cada caracter del string como un nodo

*Sea 'H' un grafo

G.add_node(H)				#añade el gráfo 'H' como un solo nodo del grafo 'G'.
G.add_nodes_from(H)			#añade todos los nodos 'H' como nos también del grafo 'G'

G.nodes					#nos permite ver cuales son los nodos del grafo 'G'
G.number_of_nodes()			#nos mostrara la cantidad de nodos que tiene nuestro grafo 'G'




	AÑADIENDO ARITAS:
------------------------------------
*Podemos añadir aristas entre los nodos con el método '.add_edge()'. 

G.add_edge(1,2)				#del grafo 'G' añadiremos una arista entre sus nodos 1 y 2 

*Ó bien creariamos la arista en forma de tupla y se la suministramos al método '.add_edge()' del siguiente modo

e=(1,2)				#no importa el orden (2,1) es lo mismo que (1,2) para crear una arista
G.add_edge(*e)			#usamos el asterisco para desempaquetar la tupla

*Por mucho que queramos añadir repetidas veces un mismo nodo o arista, networkx lo ignora y añade únicamente una vez cada nodo o arista.
*También existe la posibilidad de añadir aristas a partir de una lista de tuplas con el método '.add_edges_from()'

e=[(1,2),(2,3)]
G.add_edges_from(e)		#añadimos aristas para esos nodos señalados con 'e'.



G.edges()			#nos muestra las aristas que conforman nuestro nodo 
G.edges([nodo])			#nos muestra las aritas que contengan a ese nodo
G.edges([nodo1,nodo2,...])	#nos muestra las aristas que contengan a cualquiera de esos nodos
G.number_of_edges()		#nos muestra la cantidad de nodos que tiene nuestro Grafo 'G'


G.adj				#nos muestra diccionarios con los vecinos de los nodos y estos a su vez vecinos de otros (con sus respectivos pesos si 					hay aristas)
G.adj[nodo]			#nos muestra los vecinos de ese nodo a los cuales esta conectado (conviene mostrarlo en lista)
list(G.adj[nodo])		#Nos devuelve una lista a los cuales esta conectado mediante una arista ese nodo.

				
G.degree			#nos muestra el grado de todos los nodos del grafo 'G' en un diccionario 'nodo:grado'
G.degree(nodo)			#nos muestra el grado de ese nodo (es decir a cuantos nodos esta conectado o cuantas aristas tiene)
G.degree([nodo1,nodo2,...])	#nos muestra el grado de los nodos indicados del grafo 'G' en un diccionario 'nodo:grado'
list(G.dgree([nodo1,nodo2,..]))	#los mismo que 'G.degree' pero en una lista de tuplas (nodo,grado).


G.add_edge(a,b,weight=valor)	#añadimos un paso a la ariste entre los nodos 'a' y 'b'	
G.add_weighted_edges_from([(a,b,p1),(c,d,p2),...])	#añadimos un peso p1 a la arista entre 'a' y 'b' y un peso 'p2' a la arista entre 'c' y 'd'
							 (Y así sucesivamente) (no caso de que la arista no exista lo crea y le pone el peso indicado)


G.edges[nodo1,nodo2]		#nos mostrara el peso de ese nodo devolviendo {'weight':peso} para esa arista entre los nodos que pasemos 
G.edges[nodo1,nodo2]['height']		#devuelve el peso de esa arista para esos nodos
					


ELIMINANDO NODOS Y ARISTAS
------------------------------
*Podemos eliminar nodos de un grafo 'G' con los métodos '.remove_node()' o '.remove_nodes_from()' 

G.remove_node(nodo)		#eliminara este nodo del gráfo 'G'
G.remove_nodes_from([nodo1,nodo2,...])	#elimina todos los nodos señalados del Gráfo 'G'

*Cuando eliminamos un nodo, automaticamente también se eliminan las aristas a las que estaba vinculado.


G.remove_edge(nodo1,nodo2)		#elimina la arista entre esos nodos
G.remove_edges_from([(a,b),(c,d),...])	#elimina las aristas entre 'a' y 'b', luego entre 'c' y 'd' y asi sucesivamente.

G.clear_edges()			#elimina o limpia todas las aristas del grafo 'G'
G.clear()			#elimina todos los nodos del grafo G, quedando o siendo este grafo como uno vacio


REPRESENTANDO GRAFOS
-----------------------
*Para representar grafos, usamos el método nx.draw()
*Los grafos no tienen una posición fija(un dibujo fijo)

nx.draw(G)				#le pasamos para que dibuje este grafo



nax.drag(G,				#para dibujar ese grafo
	 with_labes=valorBool		#para escribir el valor de los nodos el valor sera True
	 font_weight='name'		#si 'name' vale 'bold', los grafos estaran en negrita (negrita es mas puro, como en word negrita)
	 font_color='nameColor'		#Para cambiar el color del texto de los nodos
	 node_size=valor		#para aumentar el tamaño de los nodos (de las bolitas) 
	 font_size=valor		#para aumentar el tamaño del valor de los nodos (de los textos)
	 node_color='nameColor'		#para cambiar el color de los nodos
	 edge_color='nameColor'		#para cambiar el color de las aristas
	 width=valor			#para modificar el grosor de las aristas	 
	
)


plt.show()				#es quien muestra de mejor manera el grafico del gráfo, en algúnos casos es quien dibuja el gráfo.




===============================================================================================================================
|						MÉTODOS PARA GRÁFICOS							      |
===============================================================================================================================
plt.title()			  	#para añadir un titulo al plot
plt.xlabel() 				#para añadir una etiqueta al eje horizontal del plot 2D
plt.ylabel() 				#para añadir una etiqueta al eje vertical del plot 2D	
plt.show()				#para mostrar el gráfico que creamos
plt.colorbar()				#para mostrar la barra del mapa de color en el caso hayamos utilizado
plt.legend() 				#para mostrar la leyenda
plt.legend(title='name')		#para mostrar la leyenda y un titulo de esta.
plt.xticks(rotation=valor)		#para rotar las etiquetas del eje 'x'. Ejemplo: rotation=90 (90 grados sexagesimales en sentido antihorario)
plt.yticks(rotation=valor)		#para rotar las etiquetas del eje 'y' 

plt.xlim([a,b])				#los limites del eje 'x' visto en el gráfico ira desde 'a' a 'b'
plt.ylim([a,b])				#los limites del eje 'y' visto en el gráfico ira desde 'a' a 'b'


*para : import matplotlib.pyplot as plot
========================================

para graficar puntos en el espacio: plt.scatter
---------------------------------------------

plt.scatter(x=valores,			# 'x' valores para ese eje,
	    y=valores,			# 'y' valores para ese eje (pueden ser listas,etc)
	    c="color",			# 'c' color del punto(puede ser una lista)
	    edgecolors="color",		# 'edgecolors' color del entorno del punto	
	    marker="formaPunto",	# 'marker' define la forma del punto
	    s=valor,			# 's' tamaño del punto (puede ser una lista)
	    linewidth=valor		#'linewidth' grosor del borde del punto
	    alpha=valor)		# 'alpha' varia su valor entre [0-1] y indica el nivel de transparencia(por defecto vale 1)
	*mas parametros
	    cmap='nombreMapa'		# 'cmap' nombre del mapa de colores que vayasemos a utilizar. 
	    cmap='nombreMapa_r'		# 'cmap' el '_r' dentro del nombre del mapa invierte los colores del mapa de colores que vayamos a utilizar. 
					#Cuando utilicemos un mapa de colores, c tomara una lista de valores que varia entre [0-100] 
	    )


*cada uno de los atributos también puede tomar de valor una lista, la lista debe ser el mismo tamaño de los puntos.(Mirad los ejemplos)	
*Se puede juntar 2 o mas scatter para mostrar todo junto en un mismo gráfico

plt.colorbar()				#nos mostrara una barra del 'mapa de color' que hayamos utilizado (en caos hayamos utilizado)
plt.show()				#para mostrar todo lo que hemos preparado en matplotlib (mostrar el gráfico)


para gráficar puntos y lineas. PLT.PLOT
-----------------------------------------------

plt.plot(valoresX,			#valores para el eje horizontal (aquí no se iguala x) Solo se pone los valores y ya.
					 Si no pones un valor en x, por defecto python considerara ahí una lista que va desde 0 a n-1.(coincida con y)
	 valoreSy,			#valores para el eje vertical
	 c='color',			#color de la linea
	 lw=valor,			#grosor de linea
	 ls='estiloLinea',		#estilo de la linea
	 ms=valor,			#tamaño del punto
         mfc='colorPunto',		#color del punto	
	 marker="estiloPunto",		#estilo del punto
      *mas parametros	
	 mec="color",			#color del borde del punto
	 'fmt',				# "[marker][linestyle][color]"  o  "[color][marker][linestyle]" 
						Ejemplo: fmt='or' signifca simbolo 'o' color 'red'
						En resumen 'fmt' remplaza a utilizar 'ls''marker''c' (no se escribe 'fmt', solo el string)
	 alpha=valor,	 		#para cambiar la transpariencia [0-1]
	 cmap="nombremapa "	
	)
	

*Estos son algunos parametros ya que hay muchos para plt.plot
*Se puede hacer 2 o mas plot para mostrar todo en un mismo grafico al final con plt.show()


*investigar el método 'np.linspace' de numpy para gráficar lineas

x1=np.linspace(valor1,			#valor inicial de donde inicia la linea
	       valor2,			#valor final de donde inicia la linea
	       cantidad,		#num=valor, o directamente el 'valor'. tu eliges la cantidad de valores que tendra el array
	       enpoint=valorBool	#con True indicamos que tome el último valor, caso contrario no lo toma        	       
)
		
plt.plot(x1,y,ls='estilo del punto')	#x1 sera el eje 'horizontal' y 'y' el eje 'vertical'			






para gráficar barras (útil para valores discretos)
----------------------------------------------------
*Algúnos parametros que acepta

plt.bar(valoresx,			#en barras es conveniente darles un nombre, por lo tanto usaremos una lista de nombres
	valoresy,			#lista de tamaños para cada barra.
	color='namecolor',		#color de la barra (puede ser una lista)
	align='posición',		#posición de la linea de la barra (por defecto es 'center'). 'edge' 'center' 
	bottom=valor,			#valor minimo para 'valoresy'
	linewidth=valorBorde,		#tamaño del borde de la barra
	edgecolor='colorBorde',		#color del borde de la barra
	width=valor)			#anchura de la barra
	
plt.barh(mismos atributos a excepcion de width, por su remplazo usamos 'height=valor')
	-sirve para colocar la barra ya no sobre las eje 'x', sino sobre el eje 'y'.



Para gráficar sectores
------------------------
*Para hacer un gráfico de sectores, algúnos parametros que acepta son:

plt.pie(valorex,			#valores de los sectores
	labels=['nombres'],		#nombre de los secotres
	colors=['colores'],		#colores para cada sector
	autopct='%1.0f%%', 		#porcentaje(redondeo a entero), también puede ser %1f%%(para los porcentajes reales con el que se hizo los 						cálculos),%1.2f%% (para mostrar los porcentajes con 2 decimales),etc. (0f podemos indicar cuandos decimales 						queremos) (no es necesario que sea '1', puede ser %0.0f%%,%0.1f%%,etc)
							
	labeldistance=valor,		#distancia radial entre las etiquetas y el sector
	radius=valor,			#valor del radio
	startangel=valorSexa,		#el valor estara en sexagesimales del angulo con el que empiezan los sectores(por defecto es 0).(eje 						antihorario) 
	explode=(a1,a2,..),		#vector de distancia para indicar como de separados estaran cada sector del centro. 
							

	shadow=valorBool		#para añadir sombras a los sectores (True aplica)(False no aplica)				
	)


Para hacer histogramas
------------------------
*Para hacer un histograma, usamos el método '.hist()' del módulo 'plt'.
*Algunos de los parámetros de este método son:

plt.hist(x,			#los valores de nuestros datos(arrays,listas,etc)
	 bins=valor,		#cantidad de intervalos del histograma
	 range=(i,j),		#rango de valores de [i a j] a mostrar en el histograma (no es necesario que los datos varien en este rango) 
	 color='nameColor',	#'color' o [colore1,color2,...] de los histogramas
	 edgecolor='Color',	#'color' del borde del histograma
	 align='position'	#position= 'left' o 'mid' o 'right'. Sobre la alineación de las barras del histograma 
	 orientation=		#= 'vertical'(por defecto) o 'horizontal'	.En que orientación mostrar el histograma
	 histtype='nameBarra'	#hay muchos como por ejemplo: 'stepfilled'  'step' 'barstacked' 'bar' 'unequal' 'bins'
				 (forma del histograma)
	 width=valor		#tamaño de las barras, para orientation='vertical' o orientation='uvertical'
	 height=valor		#tamaño de las barras, para orientation='horizontal' o orientation='uhorizontal'
)





*Para : import datetime as dt
==============================
dt.datetime.now()		#muestra la fecha y la hora actual (en formato Ingles)

*Sea t=fecha actual o t=dt.datetime.now()

t.date()		#muestra solo la fecha
t.year			#muestra el año de la fecha
t.month			#muestra el mes de la fecha
t.day			#muestra el día de la fecha
t.hour			#muestra la hora de la fecha
t.minute		#muestra los minutos de la fecha
t.second		#muestra los segundos de la fecha
t.microsecond		#muestra los microsegundos de la fecha

type(t)			#el tipo de dato es datetime.datetime


*Creando objetos datetime y el formato
--------------------------------------
*Sea d una fecha.

dt.datetime(year,month,day,hour,minute,second,microsecond)	#construimos una fecha, solo los 3 primeros parámetros son importantes
							 	(estas variables tienen ese nombre del constructor datetime por lo tanto
								 podemos hacer year=1994 por ejemplo, esto es útil para poner en otro orden las 								variables)
				
d.strftime(format='nameFormat')	#nombre del formato.(ver la lista de valores en el ejemplo de arriba).
					 Ejemplo: format='%Y'  , format='%Y %B %d' (se puede combiar todos los valores)
d.strftime('nameFormat')		(no es necesario escribir el nombre del atributo 'format=')

d.isoformat()				#nos muestra la fecha y hora de 'dt' pero con el formato ISO8601

d=dt.datetime.strptime('fecha','formatoFecha')	#fecha sera un string, y formatoFecha cada formato para el string correspondientemente
						(Crea un objeto datetime.datetime)
					Ejemplo: d=dt.datetime.strptime('22 September 2020','%d %B %Y')
					Ejemplo2: d=dt.datetime.strptime('22/September, 2020','%d/%B, %Y') (el formato sigue el orden del string)
						(el patron debe fecha y formato debe coincidir a la perfección, esto incluye '.'','' ',etc.)

d=[dt.datetime.strptime(fecha,'formatoFecha').date() for fecha in datos] 	#convertimos todo el dato en tipo objeto fecha



*Para trabajar con zonas horaricas : import pytz			#Nos permite trabajar con zonas horaricas
-----------------------------------
pytz.all_timezones					#muestra todas las zonas horarias que existen para cada continente/region. 

pytz.country_names					#Es un diccionario que contiene todas las zonas horarias de la forma {'abreviatura':'pais'}, 								Ejemplo: {'ES':'Spain'}, esto esta guardado en una posición de memoria por lo que debemos usar 								.items() para iterar sobre ella y mostrar su contenido
							*esto se llama la ISO Alpha-2

pytz.country_names['key']				#mostrara el pais para esa clave (recuerda que es un diccionario y que para cada key mostrara 								su valor) Ejemplo: pytz.country_names['ES']  #devuelve 'Spain'
									   pytz.country_names['PE']  #devuelve 'Peru'

pytz.country_timezones					#Es un diccionario también, cuya forma sera {'abreviatura':'zonasHorariasParaesePais'}
pytz.country_timezones['key']				#mostrara todas las zonas horaricas para esa clave del pais


d2=pytz.timezones('continente/region')			#devuelve la zona horarica para esa región.
d=d2.localize(d)					#agrega a 'd' la zona horarica 'd2'.
d.tzinfo						#muestra la zona horaria que estamos utilizando (por defecto muestra None)



*Para construir gráficos de series temporales 
----------------------------------------------
*Algúnos parametro para plt.plot_date son: (ver el ejemplo en el tema de arriba) (para ver mas parametros ver la documentación oficial)

plt.plot_date(x,y,c='color',ls='estiloLinea',lw=valor,tz='continente/region') #tz referencia a la zona horaria, los demás son atributos ya conocidos
											    



MULTIPLESPLOT CON PLT
-----------------------------------------------------------------------------
El método .subplot() de plt
-----------------------------
*Con el método '.subplot()' podemos dibujar múltiples plots en una misma figura. 
*Este método toma 3 parámetros que describen la layout de la figura. La layout se organiza en filas y columnas, que son representadas por los primeros parámetros. El tercer parametro representa el indice que ocupa el plot actual.

plt.subplot(n1,n2,n3)		#n1: hace referencia la cantidad de filas, (que tendrá nuestro layout) 
				#n2: a la cantidad de columnas,  (que tendrá nuestro layout)
				#n3: a la posición actual que ocupa el layout (el indice empieza en 1, el valor maximo que puede tomar el indice es 
				 númeroFilas x NúmeroColumnas)
				(el layout organizado en filas y columnas empieza en filas 1 y columnas 1 como mínimo)
				
				(el layout es la figura)


plt.plot()			#ya explicamos como hacer plt.plot arriba, plt.subplot lo que hace es dibujar varias representaciones en una misma 					figura(este es un ejemplo, pudimos haber elegido a otro tipo de grafico)


plt.figure()			#podemos usar este metodo para dar atributos personalizados o carácteristicas a nuestro layout principal (cambas)



Dibujar textos con plt.text()
----------------------------------
plt.text(x,				#x tendra el valor que ocupa en el eje 'x'
	 y,				#y tendra el valor que ocupa en el eje 'y'
	 s,				#s vendra a ser el string que deseamos mostrar
	 horizontalalignmnet='',	#para alizar el texto en base al punto de las coordenadas dadas donde ira, 'center' centro del string tratara 						de coincidir con el punto, 'left' el punto estara a la izquiera, 'right' el punto estara a su derecha	
					(forma abreviada 'ha')
	 verticalalignment='',		#lo mismo que 'horizontalalignment' pero para la vertical (forma abreviada 'va')
	 rotation=valor,		#para rotar en sentido antihorario, 'valor' estara en grados sexagesimales
	 fontsize=valor,		#tamaño de las letras del string (forma abreviada size)
	 bbox=dict(parametros),		#bbox sirve para darle carácteristicas al texto (como bordearlo, darle color, rellenarlo,etc) 
	 bbox=dict(boxstyle='name',	#ponerlo dentro de una figura ()
		   facecolor='nameColor',  #color del relleno (forma abreviada 'fc')
		   edgecolor='nameColor',  #color del borde (forma abreviada 'ec')
		   alpha=valor		   #valor de la transparencia, es un escalar.
 		   )
)





*PARA : import seaborn as sns
=============================
*Nos permite dar gráficos a grandes estructuras de datos como los de pandas, arrays,etc.
*los metodos con los que tRabaja son casí lo mismo que el modulo pandas
*Para decorar el gráfico, por ejemplo: titulo del gráfico, nombre del eje x o y, podemos usar los decoradores del modulo 'plt'

sns.load_dataset('nameSet')				#nos permite usar un dataset que ya vienen por defecto en seaborn


NUBE DE PUNTOS CON SEARBORN
-----------------------------
*Algúnos atributos para sns.scatterplot son:

sns.scatterplot(data=nameData,			#le pasamos la estructura de datos
		x='nameColumn',			#le pasamos el nombre de la columna que queremos que sea el eje 'x'
		y='nameColumn',			#le pasamos el nombre de la columna que queremos que sea el eje 'y'

		hue='nameColumn'		#cada valor de esa columna tendra un color correspondiente que le pasaremos con 'palette'
		palette=['color1','color2',...],#colores que le pasaremos para cada valor de hue
		
		style='nameColumn'		#cada valor de esa columna tendra un estilo correspondiente que le pasaremos con 'markers'
		markers=['estilo1','estilo2',...],#estilos que le pasaremos para cada valor de style

		size='nameColumn'		#cada valor de esa columna tendra un tamaño correspondiente que le pasaremos con 'sizes'
		sizes=[valor1,valor2,...])	#tamaños que le pasaremos para cada valor de size
y
		color='namecolor'		#pinta todo del color que le pasemos 			

LINE PLOT CON SEABORN
-----------------------
*Algúnos atributos para sns.lineplot son: (son casí lo mismo que el de las nuves de puntos)


sns.lineplot(data=nameData,			#pd.DataFrame, np.ndarray, o estructuras de datos de cuales proviene las variables
	        x='namecolumn',			#le pasamos el nombre de la columna que queremos que sea el eje 'x'
		y='nameColumn',			#le pasamos el nombre de la columna que queremos que sea el eje 'y'

	     size='nameColumn',			#cada valor de esa columna 'nameColumn' tendra un diferente tamaño de linea. 
	    sizes=[valor1,valor2,...],		#aqui pasamos el tamaño que tendra cada linea de la 'nameColumn'

	    style='nameColumn',			#cada valor de esa columna 'nameColumn' tendra un diferente estilo de linea.
	  markers=['estilo1','estilo2',...],	#aqui pasamos el estilo que tendra cada linea de la 'nameColumn' 
					
	      hue='namecolumn',			#cada valor de esa columna 'nameColumn' tendra un diferente color de linea
	  palette=['color1','color2',...],	#aqui pasamos el color que tendra cada linea de la 'nameColumn'
. 

	    color='nameColor'			#pinta todo del color que le pasemos
		)


BARPLOT CON SEABORN
---------------------
*En caso algúnas categorias tengan varios datos, mostrara el promedio de ellas.
*Algúnos atributos para sns.barplot son:

sns.barplot(data=nameData 			#pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	x='nameColumn' 				#variable categorica que indica las categorias de las barras
	y='nameColumn'	 			#variable númerica que indica las alturas de las barras
	order=[colo Ordenaremos la x]		#para indicar el orden de las variables categoricas
	palette=colores 			#para indicar los colores o caletas de colores
	hue='nameColumn'	 		#variable que divide las observaciones y produce barras de diferentes colores
	color='nameColor' 			#Para modificar el color de todos los elementos
	ci=valor 				#tamaño del intervalo de confianza (es una linea que muestra entre que valores vario los valores para 							cada categoria sobre el promedio, ci=None quita la linea de confianza)
	orient='orientacion' 			#para modificar la orientación de las barras ('v':vertical, 'h':horizontal)
						(al usar orient el 'x' pasa a ser el 'y', y el 'y' el 'x') (osea hay que invertir esos valores)
						(por defecto vale 'v')		


HISTOGRAMA CON SEABORN
-------------------------
*Para hacer un histograma, usamos el método .histplot() del módulo seaborn.
*los histogramas por lo general nos muestran las frecuencias con la que repiten algúnas variables, por eso no es recomendable usar 'y'. 
*Algunos de los parámetros para sns.histplot son:

sns.histoplot(data=nameDate		#pd.DataFrame, np.ndarray o estructura de datos de cuales proviene las variables
		x='NameColumn' 		#variable que indica la posición de las observaciones en el eje horizontal
		y='NameColumn' 		#variable que indica la posición de las observaciones en el eje vertical
					(no usa, por que por lo general con los histogramas vemos las frecuencias para algúnos rangos o variables)
					(si usamos 'y' en vez de 'x', mostraremos el histograma de forma horizontal)
		palette=[colores] 	#para indicar los colores o la paleta de colores
		hue='nameColumn' 	#varible que divide las observaciones y produce la líneas de diferentes colores
		color='nameColor' 	#para modificar el color de todos los elementos
		stat='nameShow'		#estadistico para computar cada barra (bin), aquí elegimos que ver que los datos, 
					'count' para ver la cantidad de datos por barra, 'density': densidad, 'probability': ver la probabilidad
					'frequency': ver la frecuencia de datos.

		bins=valor o lista	 #si damos un 'valor' sera el número de barras. Si damos una 'lista', la longitud de la lista sera la cantidad 						  de barras y cada 2 elementos determinan un intervalo para cada barra.
 
		binwith=valor 		#para modificar la anchura de cada barra (en unidades)
		binrange=(a,b)		#para modificar el rango de los valores en el que variara el histograma
		cumulative=valorBool	#booleano para indicar si se trata de un gŕafico acumulativo o no
		kde=valorBool 		#para añadir o no una estimador de densidad (por defecto vale False)
					
		multiple='name'		#forma de mostrar múltiples elementos('layer':por capas,'dodge':porseparado,'stack':apilados,'fill':proporción)
					(por defecto vale 'layer')
		element='tipoHistograma' #representación visual de la estadistica del histograma ('bars':barras,'step':escalones,'poly':polígonos)
					 aquí podemos seleccionar que tipo o forma de histograma queremo
					 (por defecto vale 'bars')


GRÁFICO DE DENSIDAD CON SEABORN
---------------------------------
*Los gráficos de densidad indican la probabilidad de aparecer.
*Algunos de estos parámetros para 'sns.kdeplot' son:

sns.kdeplot(data=nameDate		#pd.DataFrame, np.ndarray o estructura de datos de cuales proviene las variables
		x='NameColumn' 		#variable que indica la posición de las observaciones en el eje horizontal
		y='NameColumn' 		#variable que indica la posición de las observaciones en el eje vertical
					(no usa, por que por lo general con los histogramas vemos las frecuencias para algúnos rangos o variables)
					(si usamos 'y' en vez de 'x', mostraremos el histograma de forma horizontal)
		palette=[colores] 	#para indicar los colores o la paleta de colores
		hue='nameColumn' 	#varible que divide las observaciones y produce la líneas de diferentes colores
		color='nameColor' 	#para modificar el color de todos los elementos
		
		multiple='name'		#forma de mostrar múltiples elementos('layer':por capas,'dodge':porseparado,'stack':apilados,'fill':proporción)
					(por defecto vale 'layer')
		legend=valorBool	#indicamos con un True si queremos que nos muestre la leyenda.		
		



GRAFICO CON DISPLOT DE SEABORN
---------------------------------------
*es sns.displot (OJO: no es distplot, son diferentes )
*Nos permite elegir con el atributo 'kind="tipoGrafico"' el tipo de gráfico que queremos usar
*algunos parametros para sns.displot son:
*depende al valor que tenga 'kind' variaran los parametros que acepte

sns.displot(data=nameData		#pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	x='nameColumn'	 		#variable que indica las posiciones de las observaciones en el eje 'x'.
	y='nameColumn' 		#variable que indica las posiciones de las observaciones en el eje 'y'.
	palette=[colors] 		#para indicar los colores o paletes de colores (se pasa una paleta de colors o una lista de colores)
	hue='nameColumn' 		#variable que divide las observaciones y produce líneas de diferentes colores.
	color='nameColor' 		#para modificar el color de todos los elementos
	rug=valorBool			#muestra una sombra, cada rayita de la sombra indica que hay 1 o más observaciones ahí
	kind='nameGrafico' 		#'hist' para hacer un histograma, 'kde' para hacer graficos de densidad (probabilidad), 
			      		 'ecdf' graficos de densidad acumulada. (por defecto vale 'hist')
	fill=valorBoll			#el relleno, colorea. 
	bins=valor			#para 'hist' indica la cantidad de barras que tendra el histograma
	height=valor			#el tamaño del gráfico
)			

*dependiendo del valor que tome 'kind' aceptara y tendra diferentes parametros  (si es 'hist' aceptara los parametros de los histogramas, ya explicados arriba, así para los demas)


BOX PLOT CON SEABORN (CAJA DE BIGOTES)
----------------------
*Para hacer un gráfico de caja y bigotes, usamos el método .boxplot() del módulo .seaborn
*Algúnos de los parámetros de este metodo son:

sns.boxplot(data=nameData 		#pd.DataFrame, np.ndarray o estructura de datos de las cuales provienen las variables.
	    x='nameColumn'		#variable indica las categorias
	    y='nameColumn' 		#variable nímerica
	    palette=[colors] 		#para indicar los colores o paleta de colores
	    hue='nameColumn' 		#variable que divide las observaciones y produce lineas de diferentes colores
	    color='nameColor'	 	#para modificar el color de todos los elementos
	    linewidth=valor 		#para modificar la anchura de las lineas	
	    order='orient' 		#para reordenar las categorias
	    orient='orient' 		#para modificar la orientación ('horizonta'  o  'vertical')


MULTIPLOT CON SUBPLOT
---------------------------------------------------------------------------------------------
*Permite tener varios layout(gráficos) en un mismo layour.(en un mismo gráfico)
*Todo lo que pongamos despues de un snsn.subplot() sera relativo a este  (así para cada subplot)
*sns.subplot(a,b,c)			#a:indicamos el número de filas (valor minimo es 1) (no es '0' como en listas) 
					 b:indicamos el número de columnas (valor minimo es 1)
					 c:indicamos la posición del layout (la posición va desde 1 hasta a*b)




plt.suptitle('name')			#añade un titulo global al layot en el que ingresamos layot(gráficos)


*


EL METODO .add_subplot() de plt
--------------------------------
* Una gran super figura puede estar dentro de otra super figura.
* Con el método 'plt.add_subplot()' también podemos dibujar múltiples plots en una misma figura.
* La ventaja de este metodo es que aquí no es necesario que todos los layout sean del mismo tamaño, pueden haber layout mas grandes
* Para ello tenemos que seguir los siguientes pasos
	-Crear el objeto 'figure' con el método plt.figure()
	-indicar el número de filas y de columnas que queremos con el método .add_gridspec()
	-Crear tantos subplots como queramos mostrar con el método plt.add_subplot() e indicar las posiciones que van a tomar cada una de ellos.


namefig=plt.figure(constrained_layout=True)		#creamos el objeto figure y lo guardamos en una variable, 'constrained_layout' es un 								tipo de tamaño y carácteristicas que tendra nuestro objeto
			
namefig=plt.figure(mas parametros)			#aquí es donde podemos agregar mas parámetros para nuestro figure que vamos a crear
							(por ejemplo un parametro es figsize=(valor1,valor2)) valor1:altura y valor2: ancho del layout 								principal (investigar la documentación para mas parámetros)

gs=namefig.add_gridspec(a,b)				#indicamos que nuestro layout 'namefig' tendra a filas y b columnas. Y hacemos la referencia a 								esos espacion guardando en una variable


fig1=namefig.add_subplot(gs[i;j,a:b])			#aquí indicamos que filas y columnas ocupara sobre el layout que estamos creando 'fig1'. 
							indicamos el espacio haciendo referencia al espacio 'gs' y usando la sintaxis del corchete.
							(aquí el '0' hace referencia la primera fila o columna)

fig1.set_title('gs[:,:-1]')				#para agregar el titulo a este layout 'fig1' que creamos
fig1.set_xlabel('name')					#agregamos un nombre a 'x' de ese layout, como vemos podemos agregar los decoradores que ya 								conocemos simplemente le anteponemos un set_


*nameFig.bar(o cualquier otro gráfico que aprendimos a usar con plt), para crear un gráfico simplemente cambiamos 'plt' por el layout que estamos creando
*la cantidad de figuras (layout) no es necesario que ocupen todo el espacio disponible del cambas(layout principal donde se dibujarna otros layout).


plt.show()						#Para mostrar el layout general con los layout creados




MULTIPLES PLOTS EN UNO CON SEABORN		    
---------------------------------------------------------------------
*Es hacer multipes layout en un mismo layout
*para crear la parrilla(el layout principal) usamos el metodo sns.FacetGrid y para indicarle cuantos layout contendra en filas usamos rows='nameColumn', con rows indicamos cuantos layout habran en la fila 


*Los datos representados en este apartado croceden a los dataset 'anscombe' y 'dots'
Es decir, trabajaremos con esos dataset para los ejemplos y así entender mejor este tema
anscombe=sns.load_dataset('anscombe')
dots=sns.load_dataset('dots')



grid=sns.FacetGrid(nameData			#nombre de dataset, array o estructura de datos de la cual obtendremos las variables, hacemos una 							referencia guardandola en una variable
		  #row='nameColumn'		#si queremos dibujar solo en filas usamos row e igualamos a una 'columna', creara un layout para cada 							categoria de esta columna del dataset
		  #col='nameColumn'		#hara lo mismo pero esta vez dibujara solo en columnas
		   col_wrap=valor		#creara un limite de columnas igual a 'valor' y luego creara una nueva fila (asi sucecivamente)
		  #col='nameColumn, row='nameColumn'	#se dividira cada layout de col en otros layout para cada categoria de row
		   hue='nameColumn'		#pinta los datos en base a cada categoria de esta columna 'NameColumn'
		   palette='colores o mapa'	#para elegir el color para cada categoria generada con hue
		   margin_title=valorBool	#cuando creamos con 'row' y 'col' cada titulo de cada layout tendrá 2 nombres, con esto igual a True
						 dividimos esos nombres en la parte de arriba y la derecha.  
		   height=valor			#altura de todos los layout
		   aspect=valor			#ancho de los layout en base a la altura (el valor que demos se multiplicara internamente con el valor 							de la altura)
		)

grid.cmap()					#creara un estilo de gráfico para todos los layout de la variable 'grid'
grid.cmap(nameGrafico,				#en nameGrafico elegimos el tipo de gráfico (ejemplo: sns.scatter , plt.hist, etc)
	  'x',					#'x' pondremos el nombre la columna que queremos que sea el eje 'x'
	  'y',					#'y' pondremos el nombre la columna que queremos que sea el eje 'y'
	  alpha=valor,				#valor ronda entre [0 a 1], indica la transpariencia que tendra las datos de nuestro gráfico
	  color='nameColor'			#color que tendra todos los datos del gráfico
)	  		

grid.add_legend()				#para añadir la leyenda de colores que estamos usando y que representa







CONSTRUIR FIGURAS (Circulo, poligonos, etc)
=============================================
Entendiendo plt.subplots
fig,(ax1,ax2,...axn)=plt.subplots(n1,n2)	#fig es el nombre de la figura de Layout general, 'n1' al número de filas ,'n2' al número columnas
						(ax1,ax2,ax3,...axn)	habra tantos ax como n1*n2. cada 'ax' hace referencia a la posición que ocupa 							en el subplots.


un Circulo: (plt.Circle)
-------------------------
*Creando un circulo solo para un 'ax'.

fig,ax=plt.subplots(1,1)				#1 fila y 1 columna, por lo tanto solo habra 1 'ax' en la figura 'fig'(la que también hemos 								contruidos)

nameCircle=plt.Circle((x,y),				#aquí indicamos las coordenadas del centro
		  r,					#aquí indicamos el valor del radio
		  color='nameColor'			#aquí indicamos el color
		  fill=valorBool			#'True' para que colore el relleno.			
)

							(si hubiera mas 'ax' a cada 'ax' le hariamos algo similar a lo de abajo)
ax.add_artist(nameCircle)				#'.add_artist' sirve para dibujar el circulo sobre esa posición 'ax'
ax.set_aspect(valor)					#para que sea el mismo de tamaño en 'valor' tanto para el eje 'x' e 'y'. mejorando el aspecto 
plt.show()						#dibujar el layout 'fig' y los sub-layout que tengan


un Poligono: (plt.Polygon)
---------------------------
*Creando un poligono solo para un 'ax'

fig,ax=plt.subplots(1,1)

vertices=np.array([x1,y1],[x2,y2],[x3,y3],...[xn,yn])	# creamos los vertices (lo dibujara respetando este orden ¡tener cuidado!)
namePoligon=plt.Polygon(vertices,			#vertices hace referencia a los vertices que tendra el poligono (la cual ya le pasamos con una 								variable)
			color='nameColor',		#Color del relleno
			fill=valorBool			#True para que pinte el relleno (por defecto vale esto), falso para no pintar el relleno
)	

ax.add_artist(namePoligon)				#para dibujar en el layout 'ax' del layout principal 'fig' el poligono indicado 
plt.show()						#mostrar el layout 'fig' y todos sus sub-layout



*Otra forma de hacer estas figuras sin 'plt.subplots'
Ejemplo1:
- - -- - - 

vertex = np.array([[0.1, 0.1], [0.3, 0.6], [0.4, 0.2], [0.8, 0.9],])
polygon = plt.Polygon(vertex, color = "#BF3EFF")

fig=plt.figure(constrained_layout=True)
gs=fig.add_gridspec(2,2)
fig1=fig.add_subplot(gs[:,:])


fig1.add_artist(polygon)
plt.show()

*también podriamos hacerlo con seaborn
*no puede repetirse el mismo nombre de una figura al usar '.add_artist', al menos cambiale el nombre a la variable


*PARA : import networkx as nx
==============================
GRAFOS CON NETWORK
=====================================================
*El módulo 'networkx' nos va a permitir representar grafos.

*GRAFO: Conjunto de objetos llamados nodos unidos por enlaces llamados aristas, que permite representar relaciones binarias entre elementos de un conjunto.


import networkx as nx			#importamos este modulo para trabajar con grafos

G=nx.Graph()				#Creamos un objeto 'Graph' vacio y lo guardamos en la variable 'G'
type(G)					#el tipo de dato es 'networkx.classes.graph.Graph'	

G.add_node(nodo				#Con esta instrucción añadimos el nodo al Grago 'G'. (los nodos también pueden ser letras)
					Hay otras formas de añadir nodos. Por ejemplo, a partir de un objeto iterable como una lista y haciendo uso
					del método '.add_nodes_from()'

G.add_nodes_from([nodo1,nodo2,...])	#añadimos al gráfo 'G' El nodo1,nodo2,... (elementos del iterable "es decir, de una lista")
					*podemos pasar también 'caracteres o string'

G.add_nodes_from('string')		#añade al gráfo 'G' cada caracter del string como un nodo

*Sea 'H' un grafo

G.add_node(H)				#añade el gráfo 'H' como un solo nodo del grafo 'G'.
G.add_nodes_from(H)			#añade todos los nodos 'H' como nos también del grafo 'G'

G.nodes					#nos permite ver cuales son los nodos del grafo 'G'
G.number_of_nodes()			#nos mostrara la cantidad de nodos que tiene nuestro grafo 'G'




	AÑADIENDO ARITAS:
------------------------------------
*Podemos añadir aristas entre los nodos con el método '.add_edge()'. 
*Ó bien creariamos la arista en forma de tupla y se la suministramos al método '.add_edge()' del siguiente modo
*Por mucho que queramos añadir repetidas veces un mismo nodo o arista, networkx lo ignora y añade únicamente una vez cada nodo o arista.
*También existe la posibilidad de añadir aristas a partir de una lista de tuplas con el método '.add_edges_from()'



G.add_edge(nodo1,nodo2)			#del grafo 'G' añadiremos una arista entre sus nodos nodo1 y nodo2 

e=(1,2)					#no importa el orden (2,1) es lo mismo que (1,2) para crear una arista
G.add_edge(*e)				#usamos el asterisco para desempaquetar la tupla y de esta forma formar una arista entre esos nodos de la tupla

e=[(1,2),(2,3)]				
G.add_edges_from(e)			#añadimos aristas para esos nodos señalados con 'e'.


G.edges()				#nos muestra las aristas que conforman nuestro nodo 
G.edges([nodo])				#nos muestra las aritas que contengan a ese nodo
G.edges([nodo1,nodo2,...])		#nos muestra las aristas que contengan a cualquiera de esos nodos
G.number_of_edges()			#nos muestra la cantidad de nodos que tiene nuestro Grafo 'G'


G.adj					#nos muestra diccionarios con los vecinos de los nodos y estos a su vez vecinos de otros
G.adj[nodo]				#nos muestra los vecinos de ese nodo a los cuales esta conectado (conviene mostrarlo en lista)
list(G.adj[nodo])			#Nos devuelve una lista a los cuales esta conectado mediante una arista ese nodo.
				
G.degree				#nos muestra el grado de todos los nodos del grafo 'G' en un diccionario 'nodo:grado'
G.degree(nodo)				#nos muestra el grado de ese nodo (es decir a cuantos nodos esta conectado o cuantas aristas tiene)
G.degree([nodo1,nodo2,...])		#nos muestra el grado de los nodos indicados del grafo 'G' en un diccionario 'nodo:grado'
list(G.dgree([nodo1,nodo2,..]))		#los mismo que 'G.degree' pero en una lista de tuplas (nodo,grado).


G.add_edge(a,b,weight=valor)				#añadimos un paso a la ariste entre los nodos 'a' y 'b'	
G.add_weighted_edges_from([(a,b,p1),(c,d,p2),...])	#añadimos un peso p1 a la arista entre 'a' y 'b' y un peso 'p2' a la arista entre 'c' y 'd'
							 (Y así sucesivamente) (no caso de que la arista no exista lo crea y le pone el peso indicado)


G.edges[nodo1,nodo2]			#nos mostrara el peso de esa arista devolviendo {'weight':peso} para esa arista entre los nodos que pasemos 
G.edges[nodo1,nodo2]['height']		#devuelve el peso de esa arista para esos nodos
G.adj					#nos muestra los nodos, las aristas y el peso de estos en diccionarios.					


ELIMINANDO NODOS Y ARISTAS
------------------------------
*Podemos eliminar nodos de un grafo 'G' con los métodos '.remove_node()' o '.remove_nodes_from()' 

G.remove_node(nodo)				#eliminara este nodo del gráfo 'G'
G.remove_nodes_from([nodo1,nodo2,...])		#elimina todos los nodos señalados del Gráfo 'G'

*Cuando eliminamos un nodo, automaticamente también se eliminan las aristas a las que estaba vinculado.


G.remove_edge(nodo1,nodo2)			#elimina la arista entre esos nodos
G.remove_edges_from([(a,b),(c,d),...])		#elimina las aristas entre 'a' y 'b', luego entre 'c' y 'd' y asi sucesivamente.

G.clear_edges()					#elimina o limpia todas las aristas del grafo 'G'
G.clear()					#elimina todos los nodos del grafo G, quedando o siendo este grafo como uno vacio


REPRESENTANDO GRAFOS
-----------------------
*Para representar grafos, usamos el método nx.draw()
*Los grafos no tienen una posición fija(un dibujo fijo)

nax.draw(G,				#le pasamos 'G', para dibujar ese grafo
	 with_labes=valorBool		#para escribir el valor de los nodos el valor sera True
	 font_weight='name'		#si 'name' vale 'bold', los grafos estaran en negrita (negrita es mas puro, como en word negrita)
	 font_color='nameColor'		#Para cambiar el color del texto de los nodos
	 node_size=valor		#para aumentar el tamaño de los nodos (de las bolitas) 
	 font_size=valor		#para aumentar el tamaño del valor de los nodos (de los textos) (puede ser un iterable)
	 node_color='nameColor'		#para cambiar el color de los nodos
	 edge_color='nameColor'		#para cambiar el color de las aristas
	 width=valor			#para modificar el grosor de las aristas

)

plt.show()				#es quien muestra de mejor manera el grafico del gráfo, en algúnos casos es quien dibuja el gráfo.









=======================================================================================================================================================
|					Sección 20: Tema18 - TRABAJANDO CON ARCHIVOS TXT EN PYTHON						      |
=======================================================================================================================================================
	*leyendo el primer txt:
------------------------------------------
Ejemplo1:
----------
f=open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_read.txt')
print(f.read())
f.close()


Ejemplo2:
-----------
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_read.txt') as f:		#indicamos que queremos abrir el fichero de la 		  print(f.read())										ruta data y guardalo con el alias 'f', el 														programa intentara hacer todo lo que haya 														dentro de la identación de este código
	
*aquí ya no es necesario cerrar el fichero
*es mejor este método ya que nos evitamos errores como que el fichero este dañado, corrompido, etc. 



	*Leyendo parcialmente un archivo
-------------------------------------------------------
*Del ejercicio anterior, f.read(7) lee los 7 primeros carácteres del archivo 'f'

f.readline()	#lee la primera linea
f.readline()	#lee la siguiente linea (la segunda)



	*Escribiendo un archivo txt
----------------------------------------------
Ejemplo
--------
f=open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_write.txt',mode='w')
f.write('lo borre csm')

#f se comporta como una lista (donde cada indice representa una linea (ojo no es que podamos iterar con los corchetes))


f=open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_write.txt',mode='r')
for line in f:				#para cada linea(guardando en 'line') de 'f' 
	print(line)			#mostramos cada linea



Creando un txt vacio
---------------------
f=open('/content/drive/MyDrive/Colab/first_read.txt',mode='x')


	actualizando ficheros:
----------------------------------------
f=open(file='/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_read.txt',mode='a')
f.write('\nTeeeeeee vacilaron')
f.close()


	Eliminando ficheros:
----------------------------------------
Ejemplos:
- - - - -
import os
os.remove('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_read.txt')


Ejemplo2:
- - - - -
path='/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/first_read.txt'

if os.path.exists(path):
	os.remove(path)	

else:
	print('El archivo que se quiere eliminar no existe')




	Eliminando carpetas
----------------------------------------
os.rmdir('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/carpeta_temporal')	#elimina esta carpeta



	leyendo csv con open
-----------------------------------------
import csv
import os


with ('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_examples.csv','r') as f:
	reader=csv.reader(f)		#parseamos nuestro fichero 'f' para que este listo a ser leida, modificada, etc y lo guardamos en reader
	for row in reader:		#para cada fila del fichero reader
		print(row)		#imprimimos cada fila.



	comillas en las entradas
-----------------------------------------
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_quotation_example.csv') as f:
    reader=csv.reader(f,quoting=csv.QUOTE_NONNUMERIC)
    for row in reader:
        print(row)



		dialectos
----------------------------------------------
*Los dialectos ayudan agrupar patrones de formato especifico como el delimitador, las comillas, los espacios adicionales tras los demilitadores
*En caso de querer usar nuestro dialecto personalizado, reader nos ofrece el parametro 'dialect' al cual podemos pasarle dicho dialecto

Ejemplo:
- - - - -
#El dialecto que queremos usar se crea antes
csv.register_dialect('my_dialect',			#nombre que tendra nuestro dialecto que vamos a registrar
		     delimiter="|"			#indicamos que el delimitador que viene es '|'
		     skipinitialspace=True,		#indicamos que no haya espacio adicional despues del demilitador
		     quoting=csv.QUOTE_NONNUMERIC)	#que entre comille los no numericos.


with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_quotation_example.csv') as f:
	reader=csv.reader(f,dialect='my_dialect')
	for row in reader:
		print(row)


	DICCIONARIOS y CSV
-----------------------------------------------
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_quotation_example.csv') as f:
	reader=csv.DictReader(f,dialect='my_dialect')
	for row in reader:
		print(row)		#tuplas comportandose como diccionarios para OrderedDict
	

with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv') as f:
	reader=csv.DictReader(f)
	for row in reader:
		print(dict(row))	#cada fila ya sera ahora si un diccionario



		ESCRIBIENDO CSV
------------------------------------------------------
data = [["id", "Name", "City", "Age"], 
        [1234, "Arturo", "Madrid", 22], 
        [2345, "Beatriz", "Barcelona", 25],
        [3456, "Carlos", "Sevilla", 18], 
        [4567, "Dolores", "Cuenca", 34]]


with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv','w') as f:
	write=csv.writer()
	for row in data:
		write.writerow(row)		#escribira en el fichero la información pasada con row





===============================================================================================================================														     |			MODULO	DE IO,CSV, SO para escribir y crear ficheros
===============================================================================================================================
open('ruta')			#nos permite abrir el fichero de la ruta dada

*f=open('ruta')			#abrimos un fichero y lo guardamos en una posición de memoria a cual llamamos 'f'.
f.read()			#nos permite leer el fichero que tenemos abierto
f.read(valor)			#lee los 'valor' primeros carácteres
print(f.read())			#muestra el contenido del archivo en pantalla

f.close()			#nos permite cerrar el fichero(quitar el fichero 'f' de la memoria)



with open('ruta') as f:		#abrira el fichero de la ruta dada y le dara el alias 'f' para trabajar con él		
	algoritmo		#intentara ejecutar todo el algoritmo que tenga dentro(respeta la identación) y se cerrara al terminar la identación.


OPEN() por defecto mode='r' Para leer
---------------------------------------------------------------------

*f=open('ruta')			#abrimos un fichero y lo guardamos en una posición de memoria a cual llamamos 'f'.
f.read()			#nos permite leer el fichero que tenemos abierto
f.read(valor)			#lee los 'valor' primeros carácteres
print(f.read())			#muestra el contenido del archivo en pantalla

f.readline()			#nos lee solo la primera linea del fichero 'f'(poner 2 o mas veces este código hace que continue leyendo las filas 					siguientes, es decir si rescribes 5 veces f.readline() mostrara las 5 primeras lineas) (ver ejemplo)
x
f.readine(valor)		#lee los primeros 'valor' carácteres empezando desde la primera linea, ejecutarlo mas veces continuara leyendo mas 					carácteres


*f=open('ruta'			#en 'ruta' ponemos la ruta del fichero (la variable se llama 'file')
	mode=''			# 'r': modo solo lectura(valor por defecto), 'w': modo escritura(en caso el fichero no exista lo creara con esa ruta y 					nombre)
)			
*tener cuidado por que para cada valor del 'mode' cambia los metodos que recibe


OPEN(mode='w') Para escribir
----------------------------------------------------------------------


*f=open('ruta/archivo'		#en 'ruta' ponemos la ruta del fichero (la variable se llama 'file')
	mode=''			# 'r': modo solo lectura(valor por defecto), 'w': modo escritura(en caso el fichero no exista lo creara con esa ruta y 					nombre)
)
f.write('texto')		#escribira en el fichero (en caso el fichero al usar 'w' exista lo sobreescribira)




OPEN(mode='x') para crear un archivo vacio
--------------------------------------------------------------------
f=open('ruta/nameArchivo',mode='x')		#crea un archivo vacio (en caso de existir saltara un error)


OPEN(mode='a') para actualizar y modificar archivos
---------------------------------------------------------------------
f=open('ruta/nameArchivo',mode='a')		#mode='a' permite actualizar y modificar el fichero indicado
f.write('texto')				#ahora .write() no sobreescribira, sino que escribira desdes lo que le pasemos por texto.
						(las almohadillas de python se ejecutaran como código)
				
.


Eliminando ficheros:
----------------------------------------------------------------------
import os		#(importamos este modulo par poder eliminar ficheros, 'os' viene de sistema operativo, ya que eliminar un fichero no le 			corresponde a python, sino al sistema operativo en cuestión)

os.remove('ruta/nameArchivo')	#elimina el fichero indicado para la ruta indicada (en caso de no existir saltara un error)
os.path.exists('ruta/archivo')	#devuelve un booleano comprobando si existe ese archivo o no
os.rmdir('ruta')		#elimina la carpeta indicada (siempre y cuando este vacia)



leyendo y trabajando csv con open()
====================================================
import cvs		#este modulo tiene bastante metodos y propiedades que te permite trabajar de forma optima con este tipo de ficheros

csv.reader('ruta/archivo')			#permite a un fichero.csv ser parseado, es decir ser lista para ser leida, modificada, iterada, etc 							(OJO no como una lista) (no se autoguarda, hay que guardarlo en una variable para trabajar con estas)
csv.reader('ruta/archivo',delimiter='separador') 	#generalmente los separadores son una ',' pero en algúnos casos puede que sea otro simbolo, en 								delimiter indicamos el separador que estamos usando para que se transforme en comas
							(en comas recien el fichero su contenido es tomado como un 'csv')	
		
csv.reader('ruta/archivo',skipinitialspace=valorBool)	#(Valor por defecto False), Elimina el espacio en blanco tras el delimitador (la ,) del csv
							Es útil hacer esto para tener el dato correctamente, ya que se suele poner un espacio despues 								de la coma para poder visualizarlo mejor, pero no forma parte de la información realmente 										
csv.reader('ruta/archivo',quoting=valor)	#con 'quoting' elegimos como se comportaran las comillas en base al valor que le pasemos 
						 csv.QUOTE_ALL: Indica que todos los valores estaran entre comillas (valor por defecto)
						 csv.QUOTE_MINIMAL: Indica que los valores que estaran entre comillas son valores que contienen  								    	    caracteres minimos como el delimitador, comillas, o cualquier carácter de 									    terminación de linea
						 csv.QUOTE_NONNUMERIC: Indica que los valores que estaran entre comillas son entradas que contienen 									       entradas no númericas (que pondra comilla a los valores que no son numericos)
						 csv.QUOTE_NONE: Indica que ninguno de los valores estaran entre comillas.

	

#El dialecto que queremos usar para los csv se puede crear antes.
csv.register_dialect('name_dialect',			#nombre que tendra nuestro dialecto que vamos a registrar en csv
		     delimiter="separador"		#indicamos que el delimitador que viene (ya explicado)
		     skipinitialspace=valorBool,	#indicamos que no haya espacio adicional despues del demilitador (ya explicado)
		     quoting=valor)			#que entre comille los no numericos. (ya explicado)

csv.reader('ruta/archivo',dialect='name_dialect')	#indicamos el dialecto que tendra (dando el nombre de este) previamente creado arriba


csv.DictReader('ruta/archivo')		#transforma el archivo 'csv' en un tipo de diccionario, donde cada campo para cada linea ira con su valor
					

Escribiendo CSV
----------------------------------------------------------
*Para crear nuestros propios CSV


Ejemplo:
--------
data = [["id", "Name", "City", "Age"], 
        [1234, "Arturo", "Madrid", 22], 
        [2345, "Beatriz", "Barcelona", 25],
        [3456, "Carlos", "Sevilla", 18], 
        [4567, "Dolores", "Cuenca", 34]]

#forma1:
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv','w') as f:
	name=csv.writer(f)			#escribira en el fichero f
	for row in data:			#para cada valor del data
		name.writerow(row)		#escribira en el fichero 'f' la información pasada con row (cada valor del data)

#forma2:
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv','w') as f:
	name=csv.writer(f)			#escribir en f
	name.writerows(data)			#escribira en el fichero 'f' la información pasada con row (cada valor del data)

Ejemplo2:
---------
data = [{"id": 1234, "Name": "Arturo", "City": "Madrid", "Age": 22},
        {"id": 2345, "Name": "Beatriz", "City": "Barcelona", "Age": 25},
        {"id": 3456, "Name": "Carlos", "City": "Sevilla", "Age": 18},
        {"id": 4567, "Name": "Dolores", "City": "Cuenca", "Age": 34}]

#La cabecera es la lista de las keys de cualquiera de las entradas de data
header=list(data[0].keys())	#creamos la lista de cabeceras


#forma 1:
----------
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv','w') as f:
	name=csv.DictWriter(f,fieldnames=header)	#pasamos la lista de cabeceras
	
	name.writeheader()				#escribe en la primera linea la cabecera que hayamos indicado en fieldnames		
	
	for d in data:
		name.writerow(d)			#escribe los valores de cada cabecera

#forma 2:
----------
with open('/content/drive/MyDrive/Colab Notebooks/Mis Scripts/Seccion 20/csv_example.csv','w') as f:
	name=csv.DictWriter(f,fieldnames=header)	#pasamos la lista de cabeceras
	name.writeheader()				#escribe en la primera linea la cabecera que hayamos indicado en fieldnames		
	name.writerows(data)				#escribe los valores de cada cabecera para todo la data




=======================================================================================================================================================
|					Sección 21: Tema19 - Errores y excepciones en Python							      |
=======================================================================================================================================================
*Estos son algúnos de los errores mas tipicos en Python

	Excepción			Causa
	-------------			-----------------------
	ArithmeticError			Cuando falla una operación numérica
	AssertionError			Cuando falla una declaración assert
	AtributeError			Cuando falla una asignación de atributo o referencia
	EOFError			Cuando la función input() llega a la condición fin de archivo (end-of-file)
	FloatingPointError		Cuando falla una operación en coma flotante
	ImportError			Cuando un módulo importando no es encontrado
	IndentationError		Cuando la indentación no es correcta
	IndexError			Cuando el índice de una secuencia se sale del rango
	KeyError			Cuando una clave de un diccionario no es encontrada
	KeyboardInterrupt		Cuando el usuario pulsa la tecla de interrupción
	LookupError			Cuando el error no puede ser encontrado
	MemoryError			Cuando una operación se queda sin memoria
	NameError			Cuando se llama a una variable que no se encuentra a nivel global ni local
	NotImplementedError		Cuando un método abstracto requiere de una clase heredada para sobreescribir el método
	OverflowError			Cuando el resultado de una operación aritmética es demasiado grande para ser representado
	RuntimeError			Cuando un error no entra dentro de ninguna categoría
	TabError			Cuando la indentación consiste de tabulaciones y espacios en blanco inconsistentes
	TypeError			Cuando a una función u operación se le suministra un objeto de tipo incorrecto
	ValueError			Cuando una función obtiene un argumento del tipo correcto pero de valor incorrecto
	ZeroDivisionError		Cuando el divisor de una división es 0



	MANEJO DE EXCEPCIONES
--------------------------------------------
*Como programadores, necesitamos ser los mas especificos posible. Esto implica ser consciente de los errores que podrían ocurrir. Por suerte, Python permite a los programadores tratar con errores de forma creciente. 
	
	-  try / except
	-  try / finally
	-  assert
	-  raise
	-  with / as



try / except
---------------
*El bloque try: permite comprobar si hay errores de código (intenta ejecutar el código)
*El bloque except: permite manejar el error (si hay un error en 'try' se ejecuta este bloque)


Ejemplo1:
---------
a,b=5,0
try:
    a/b
except ZeroDivisionError:		#el error que indiquemos sera el que esperamos que suceda en try
    print('no se puede dividir entre {}'.format(b))


Ejemplo2:
----------
a,b=5,0
try:
    a/b
except ZeroDivisionError as message:	#
    print(message)


Ejemplo3:
----------
a,b=5,0
try:
    a/b
except ZeroDivisionError as message:
    print(message)
	
except: 				#El error sera generico(es decir, que tomamos cualquier error que suceda)       
    print('waaa')


Ejemplo4:
---------
a,b=5,0
try:
    a/b
except ZeroDivisionError as message:
    print(message)

else:					#se ejecuta en caso no se cumpla la excepción(Es decir, si no hay errores en Try)
    print('Nada ha salido mal')



try/finally
------------

finally:				#ejecuta el código haya o no un error.
	codigo


ASSERT
---------
*La palabra reservada assert se útiliza para debugear el código. Nos permite comprobar si una condición en nuestro código devuelve True.
De lo contrario, el programa nos devolverá un 'AssertionError' (assert es una precondición)

Ejemplo1:
---------
x='salida'
assert x=='hola'

Ejemplo2:
---------
x='salida'
assert x=='hola', 'x deberia ser una hola'


RAISE
-------------
*Como programadores podemos elegir cuando mostrar una excepción dada una condición. Para mostrar excepciones, usamos la palabra reservada False.


Ejemplo1:
- - - - -
radius = -7
if radius < 0:
  raise Exception("El radio no puede tomar valores menores a 0")

Ejemplo2: 
- - - - -
radius = "-5"

if not type(radius) is int and not type(radius) is float:
  raise TypeError("El radio debe ser de tipo numérico (int o float)")
elif radius < 0:
  raise Exception("El radio no puede tomar valores menores a 0")


WITH / AS
-----------
*La palabra reservada 'with' se utiliza para manejar excepciones y conseguir así un código mas limpio y legible. Simplifica el manejo de recursos comunos tales como flujo de archivos.

-En el siguiente 'chunk' no utilizamos la palabra reservada 'with'


file = open("path_del_archivo", "w")
try: 
    file.write("¡Hola, caracola!") 
finally: 
    file.close() 



-Mientras que en el siguiente sí que utilizamos with / as y observamos que el código queda mucho más limpio y legible.

with open("path_del_archivo", "w") as file: 
    file.write("¡Hola, caracola!") 



*Ambos chunks de código darían el mismo resultado. No obstante, el segundo tiene menos líneas de código, pues entre otras cosas no le hace falta la línea file.close(), tal cual vimos en el tema anterior.

La palabra reservada with se asegura la adquisición y liberación adecuadas de recursos.


===============================================================
|	Metodos y Modulos de errores y excepciones	      |
===============================================================
dir(locals()['__builtins__'])		#muestra en una lista todos los errores que contiene predeterminado Python y algúnas palabras reservadas
!pip install nombre_del_modulo		#para instalar un modulo con el que queramos trabajar


*TRY / EXCEPT /FINALLY
-------------------------
try:					#intentara ejecutar todo el codigo que este dentro de su identación
	código
except nameError:			#en caso haya el error indicado(nameError) en 'try', se ejecutara el código de su identación 
					(podemos meter muchos 'except' en caso de que queramos señalar muchos errores mas que pueda haber en el try)
	código		
				
except:					#para cualquier error que suceda en 'try', se ejecutara el código de abajo 		
	codigo

else:					#en caso no haya ningún error se ejecutara este código
	codigo

finally:				#ejecuta el código independiente si haya errores o no
	codigo



*ASSERT
---------
assert condicion			#genera un error tipo 'AssertionError' en caso no se cumpla nuestra condición
assert condicion,mensaje		#agregamos un mensaje en caso no se cumpla nuestra condición


*RAISE
---------
raise Exception('mensaje')		#creamos nuestro propio error generico
raise nameError('mensaje')		#creamos nuestro propio error de tipo indicado en 'nameError'





-------------------------------------------------------------------------------------------------------------------------------------------------
							comentarios y tips:									|
-------------------------------------------------------------------------------------------------------------------------------------------------
*cuando importemos una libreria (al ser este un modulo), la sintaxis general de sus metodos es ejemplo: math.funcion(), math.variable
*Con from ya no es necesario utilizar el nombre del modulo
*si pasas un número de flotante con decimales a entero, al hacer el casting solo tomara la parte entera, no redondeara ni nada, la parte decimal se pierde 


Metodos de math:
----------------
math.sqrt(valor)		-->
math.pi				-->
math.factorial(valor)		-->


-----------------------
expresiones especiales|
-----------------------
None			->indica la ausencia de valor



=================================================================
|			Metodos					|
=================================================================

variable[x]	-->nos devolvera el carácter de indice x
variable[x:y]	-->nos devolvera todos los carácteres desde el indice x hasta el (y-1)
variable[:y]	-->desde el inicio hasta el indice y-1
variable[x:]	-->desde el carácter x hasta el final
variable[-x:]	-->los ultimos x elementos
variable[:-x]	-->desde el inicio hasta la posición -x
variable[::-1]		-->El tercer parametro es de como va aumentar el indice, seria desde el ultímo al primero
variable[-1::-1]	-->Seria desde el último primero 
variable[-1:-x:-1]	-->de la última posición hasta -x+1

variable.lower()			-->Convierte todos los carácteres a minuscula
variable.islower()			-->devuelve un valor booleano, si variable es minuscula True, caso contrario False
variable.upper()			-->Convierte todos los carácteres a mayusculas
variable.isupper()			-->devuelve un valor boobleano, si variable es mayuscula True, caso contrario False
variable.count("texto")			-->Cuenta cuantas veces aparece una letra en la variable
variable.capitalize()			-->Convierte a mayuscula el primer carácter de variable string
variable.title()			-->Convierte a mayuscudf=[]
with open(path,mode='r') as f:
    reader=csv.reader(f)
    for row in reader:
        df.append(row)
        print(row)la el primer carácter de cada palabra de un string
variable.swapcase()			-->Convierte a mayuscula los carácteres de minuscula y los de minuscula a mayusculas de un string
variable.replace("texto1","texto2" )	-->remplaza el texto1 por el texto2 en todas que aparezca el texto1 del string variable
variable.split("texto1")		-->rompe el string en el carácter que le indiquemos y elimina dicho carácter y devuelve en forma de lista
	variable.split(" ")		-->devolvera cada palabra como elemento de una lista, ya que el carácter eliminado es el " "

variable.strip()			-->Elimina los espacios sobrantes al inicio y al final de cada variable tipo string
variable.rstrip() 			-->Elimina los espacios sobrantes al final de cada variable string
variable.lstrip()			-->Elimina los espacios sobrantes al inicio de cada variable string

variable.find('texto')			-->Buscara el primer carácter que forme el texto y encuentre en variable y devolvera su indice del 1er carácter
variable.find('texto',x)		-->Buscara el caracter desde el indice 'x'(start) hasta el final
variable.find('texto',x,y)		-->Buscara el carácter desde el indice 'x'(start) hasta el indice 'y'(end)
					*Si .find devuelve -1 significa que no encontro el carácter			


variable.index('texto')			-->Hace lo mismo que .find y tiene la misma sintaxis. En lo único que difieren es que cuando no encuentran 
					   el carácter buscado .find devuelve -1 ; en cambio .index arroja un error
variable.rindex('texto')		-->Busca el carácter y devuelve el último indice en el que fue encontrado.
					   (también aceptan de paramteros un start y un end)
len(variable)				-->Nos devuelve el número de caracteres que tiene el string(Los espacios en blanco también se cuenta)


input(texto)				-->Sirve para que el usuario introduzca un string por consola

ord("caracter")				-->Recibe de parametro un carácter y devolvera su valor entero en ASCII
chr(valor)				-->Recibe de parametro un valor entero y devolvera su carácter correspondiente en ASCII

bool(input())				-->Si el input recibe "0","no escribe nada",False. En cualquiera de estos casos devolvera False  

max(x,y,z)				-->Siendo los parametros tipo int o float, devuelve el mayo de ellos
min(x,y,z...)				-->Devuelve el menor de ellos

suma(lista)				-->Sumara todos los elementos de la lista
suma(dicci.values())			-->Sumara todas los valores de cada clave del diccionario

max(valor1,valor2,...)			--> Devuelve el número mayor
min(valor1,valor2,...)			--> Devuelve el número menor

round(valor,CantidadDecimales)		--> Redondea el valor a la cantidad de decimales que le indiquemos.




casting de carácters:
---------------------
Transforma un dato:

int			tipo numeros enteros
float			tipo mueros decimales
str			tipo cadena de carácteres.
bool			tipo valor booleano
list			Convierte objetos iterables a tipo de lista.




=====================
librerias utilizadas|
=====================
import 'namelibreria' as 'nameAlisas'	->Importa un libreria y le ponemos un alias(conviene poner alias si el nombre de dicha libreria es extensa) 
import cmath		--> se utiliza para trabajar con los argumentos de los números complejos
import math		--> se utiliza para trabajar con todos los metodos de math
			    math.modf(variflotante)
import numpy		--> Para tarabajar con matrice
from functools import reduce	-->para trabajar con la función reduce(nameFunción,iterable)
from numpy import random	-->permite usar el motodo random para generar números aleatorios.
import pandas as pd		-->Permite trabajar con dataframes.
from IPython.display import display, Latex	-->nos permite imprimir en python texto Latex
	display(Latex('$expresion1 //over expresion2$'))

import random

-------------------------
Objetos iterables	|
-------------------------
range()			-->devuelve valores iterables.
list()			-->la lista es un objeto iterable	


ejemplo de range():
a=list(range(1,5))	#devuelve a=[1,2,3,4] Como vemos range devuelve un rango de valores.
b=set(range(1,6))	#devuelve b={1,2,3,4,5}

 
-----------------------------------------
|	función trigonometricas		|
-----------------------------------------
*para math y cmath

math.sin(valor)		#nos calcula el seno del angulo en radianes
math.cos(valor)		#nos calcula el coseno del angulo en radianes

math.sinh()		#
math.cosh()		#


